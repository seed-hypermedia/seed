// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v4.24.4
// source: documents/v3alpha/comments.proto

package documents

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Request to create a comment.
type CreateCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Requred. Account ID to which the comment is applied.
	TargetAccount string `protobuf:"bytes,1,opt,name=target_account,json=targetAccount,proto3" json:"target_account,omitempty"`
	// Required. Path within the account where the comment is applied.
	TargetPath string `protobuf:"bytes,2,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	// Required. Version of the document at the time of the comment.
	TargetVersion string `protobuf:"bytes,3,opt,name=target_version,json=targetVersion,proto3" json:"target_version,omitempty"`
	// Optional. When current comment is a reply to another comment,
	// this must be the ID of the comment being replied to.
	// Account and path of the parent comment must be the same as the current comment.
	ReplyParent string `protobuf:"bytes,4,opt,name=reply_parent,json=replyParent,proto3" json:"reply_parent,omitempty"`
	// Required. Content of the comment.
	Content []*BlockNode `protobuf:"bytes,5,rep,name=content,proto3" json:"content,omitempty"`
	// Required. Name of the key to use for signing the comment.
	SigningKeyName string `protobuf:"bytes,6,opt,name=signing_key_name,json=signingKeyName,proto3" json:"signing_key_name,omitempty"`
	// Optional. ID of the capability that allows publishing comments for the target account and path.
	// Anyone can create comments to anything, but having a capability to comment makes sure your comments are propagated along with the content.
	Capability    string `protobuf:"bytes,7,opt,name=capability,proto3" json:"capability,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateCommentRequest) Reset() {
	*x = CreateCommentRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateCommentRequest) ProtoMessage() {}

func (x *CreateCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateCommentRequest.ProtoReflect.Descriptor instead.
func (*CreateCommentRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{0}
}

func (x *CreateCommentRequest) GetTargetAccount() string {
	if x != nil {
		return x.TargetAccount
	}
	return ""
}

func (x *CreateCommentRequest) GetTargetPath() string {
	if x != nil {
		return x.TargetPath
	}
	return ""
}

func (x *CreateCommentRequest) GetTargetVersion() string {
	if x != nil {
		return x.TargetVersion
	}
	return ""
}

func (x *CreateCommentRequest) GetReplyParent() string {
	if x != nil {
		return x.ReplyParent
	}
	return ""
}

func (x *CreateCommentRequest) GetContent() []*BlockNode {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *CreateCommentRequest) GetSigningKeyName() string {
	if x != nil {
		return x.SigningKeyName
	}
	return ""
}

func (x *CreateCommentRequest) GetCapability() string {
	if x != nil {
		return x.Capability
	}
	return ""
}

// Request to get a comment.
type GetCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. ID of the comment to retrieve.
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetCommentRequest) Reset() {
	*x = GetCommentRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCommentRequest) ProtoMessage() {}

func (x *GetCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCommentRequest.ProtoReflect.Descriptor instead.
func (*GetCommentRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{1}
}

func (x *GetCommentRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// Request to get multiple comments.
type BatchGetCommentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. List of comment IDs to retrieve.
	Ids           []string `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchGetCommentsRequest) Reset() {
	*x = BatchGetCommentsRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetCommentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetCommentsRequest) ProtoMessage() {}

func (x *BatchGetCommentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetCommentsRequest.ProtoReflect.Descriptor instead.
func (*BatchGetCommentsRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{2}
}

func (x *BatchGetCommentsRequest) GetIds() []string {
	if x != nil {
		return x.Ids
	}
	return nil
}

// Response with multiple comments.
type BatchGetCommentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of comments requested.
	Comments      []*Comment `protobuf:"bytes,1,rep,name=comments,proto3" json:"comments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchGetCommentsResponse) Reset() {
	*x = BatchGetCommentsResponse{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetCommentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetCommentsResponse) ProtoMessage() {}

func (x *BatchGetCommentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetCommentsResponse.ProtoReflect.Descriptor instead.
func (*BatchGetCommentsResponse) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{3}
}

func (x *BatchGetCommentsResponse) GetComments() []*Comment {
	if x != nil {
		return x.Comments
	}
	return nil
}

// Request to list comments.
type ListCommentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. Account ID to list the comments for.
	TargetAccount string `protobuf:"bytes,1,opt,name=target_account,json=targetAccount,proto3" json:"target_account,omitempty"`
	// Required. Path within the account to list the comments for.
	TargetPath string `protobuf:"bytes,2,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	// Optional. The maximum number of comments to return.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Optional. The page token obtained from a previous request (if any).
	PageToken     string `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCommentsRequest) Reset() {
	*x = ListCommentsRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCommentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCommentsRequest) ProtoMessage() {}

func (x *ListCommentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCommentsRequest.ProtoReflect.Descriptor instead.
func (*ListCommentsRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{4}
}

func (x *ListCommentsRequest) GetTargetAccount() string {
	if x != nil {
		return x.TargetAccount
	}
	return ""
}

func (x *ListCommentsRequest) GetTargetPath() string {
	if x != nil {
		return x.TargetPath
	}
	return ""
}

func (x *ListCommentsRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListCommentsRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

// Response with a list of comments.
type ListCommentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of comments.
	Comments []*Comment `protobuf:"bytes,1,rep,name=comments,proto3" json:"comments,omitempty"`
	// Token to retrieve the next page of comments (if necessary).
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCommentsResponse) Reset() {
	*x = ListCommentsResponse{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCommentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCommentsResponse) ProtoMessage() {}

func (x *ListCommentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCommentsResponse.ProtoReflect.Descriptor instead.
func (*ListCommentsResponse) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{5}
}

func (x *ListCommentsResponse) GetComments() []*Comment {
	if x != nil {
		return x.Comments
	}
	return nil
}

func (x *ListCommentsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

// Comment is a unit of discussion.
type Comment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID of the current comment.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Account ID that this comment targets.
	TargetAccount string `protobuf:"bytes,2,opt,name=target_account,json=targetAccount,proto3" json:"target_account,omitempty"`
	// Path within the account this comment targets.
	TargetPath string `protobuf:"bytes,3,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	// Version of the document this comment targets.
	TargetVersion string `protobuf:"bytes,4,opt,name=target_version,json=targetVersion,proto3" json:"target_version,omitempty"`
	// Optional. The ID of the top-level non-reply comment of the conversation thread.
	ThreadRoot string `protobuf:"bytes,5,opt,name=thread_root,json=threadRoot,proto3" json:"thread_root,omitempty"`
	// Optional. The ID of the comment to which this comment is a direct reply.
	// For initial comments this field is empty.
	ReplyParent string `protobuf:"bytes,6,opt,name=reply_parent,json=replyParent,proto3" json:"reply_parent,omitempty"`
	// Account ID of the author of the comment.
	Author string `protobuf:"bytes,7,opt,name=author,proto3" json:"author,omitempty"`
	// Content of the comment.
	Content []*BlockNode `protobuf:"bytes,8,rep,name=content,proto3" json:"content,omitempty"`
	// Timestamp when the comment was created.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Optional. ID of the capability this comment was created with, if any.
	Capability    string `protobuf:"bytes,10,opt,name=capability,proto3" json:"capability,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Comment) Reset() {
	*x = Comment{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Comment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Comment) ProtoMessage() {}

func (x *Comment) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Comment.ProtoReflect.Descriptor instead.
func (*Comment) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{6}
}

func (x *Comment) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Comment) GetTargetAccount() string {
	if x != nil {
		return x.TargetAccount
	}
	return ""
}

func (x *Comment) GetTargetPath() string {
	if x != nil {
		return x.TargetPath
	}
	return ""
}

func (x *Comment) GetTargetVersion() string {
	if x != nil {
		return x.TargetVersion
	}
	return ""
}

func (x *Comment) GetThreadRoot() string {
	if x != nil {
		return x.ThreadRoot
	}
	return ""
}

func (x *Comment) GetReplyParent() string {
	if x != nil {
		return x.ReplyParent
	}
	return ""
}

func (x *Comment) GetAuthor() string {
	if x != nil {
		return x.Author
	}
	return ""
}

func (x *Comment) GetContent() []*BlockNode {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *Comment) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Comment) GetCapability() string {
	if x != nil {
		return x.Capability
	}
	return ""
}

var File_documents_v3alpha_comments_proto protoreflect.FileDescriptor

const file_documents_v3alpha_comments_proto_rawDesc = "" +
	"\n" +
	" documents/v3alpha/comments.proto\x12\x1acom.seed.documents.v3alpha\x1a!documents/v3alpha/documents.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xb3\x02\n" +
	"\x14CreateCommentRequest\x12%\n" +
	"\x0etarget_account\x18\x01 \x01(\tR\rtargetAccount\x12\x1f\n" +
	"\vtarget_path\x18\x02 \x01(\tR\n" +
	"targetPath\x12%\n" +
	"\x0etarget_version\x18\x03 \x01(\tR\rtargetVersion\x12!\n" +
	"\freply_parent\x18\x04 \x01(\tR\vreplyParent\x12?\n" +
	"\acontent\x18\x05 \x03(\v2%.com.seed.documents.v3alpha.BlockNodeR\acontent\x12(\n" +
	"\x10signing_key_name\x18\x06 \x01(\tR\x0esigningKeyName\x12\x1e\n" +
	"\n" +
	"capability\x18\a \x01(\tR\n" +
	"capability\"#\n" +
	"\x11GetCommentRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"+\n" +
	"\x17BatchGetCommentsRequest\x12\x10\n" +
	"\x03ids\x18\x01 \x03(\tR\x03ids\"[\n" +
	"\x18BatchGetCommentsResponse\x12?\n" +
	"\bcomments\x18\x01 \x03(\v2#.com.seed.documents.v3alpha.CommentR\bcomments\"\x99\x01\n" +
	"\x13ListCommentsRequest\x12%\n" +
	"\x0etarget_account\x18\x01 \x01(\tR\rtargetAccount\x12\x1f\n" +
	"\vtarget_path\x18\x02 \x01(\tR\n" +
	"targetPath\x12\x1b\n" +
	"\tpage_size\x18\x03 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x04 \x01(\tR\tpageToken\"\x7f\n" +
	"\x14ListCommentsResponse\x12?\n" +
	"\bcomments\x18\x01 \x03(\v2#.com.seed.documents.v3alpha.CommentR\bcomments\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\x82\x03\n" +
	"\aComment\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12%\n" +
	"\x0etarget_account\x18\x02 \x01(\tR\rtargetAccount\x12\x1f\n" +
	"\vtarget_path\x18\x03 \x01(\tR\n" +
	"targetPath\x12%\n" +
	"\x0etarget_version\x18\x04 \x01(\tR\rtargetVersion\x12\x1f\n" +
	"\vthread_root\x18\x05 \x01(\tR\n" +
	"threadRoot\x12!\n" +
	"\freply_parent\x18\x06 \x01(\tR\vreplyParent\x12\x16\n" +
	"\x06author\x18\a \x01(\tR\x06author\x12?\n" +
	"\acontent\x18\b \x03(\v2%.com.seed.documents.v3alpha.BlockNodeR\acontent\x12;\n" +
	"\vcreate_time\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12\x1e\n" +
	"\n" +
	"capability\x18\n" +
	" \x01(\tR\n" +
	"capability2\xc6\x03\n" +
	"\bComments\x12f\n" +
	"\rCreateComment\x120.com.seed.documents.v3alpha.CreateCommentRequest\x1a#.com.seed.documents.v3alpha.Comment\x12`\n" +
	"\n" +
	"GetComment\x12-.com.seed.documents.v3alpha.GetCommentRequest\x1a#.com.seed.documents.v3alpha.Comment\x12}\n" +
	"\x10BatchGetComments\x123.com.seed.documents.v3alpha.BatchGetCommentsRequest\x1a4.com.seed.documents.v3alpha.BatchGetCommentsResponse\x12q\n" +
	"\fListComments\x12/.com.seed.documents.v3alpha.ListCommentsRequest\x1a0.com.seed.documents.v3alpha.ListCommentsResponseB3Z1seed/backend/genproto/documents/v3alpha;documentsb\x06proto3"

var (
	file_documents_v3alpha_comments_proto_rawDescOnce sync.Once
	file_documents_v3alpha_comments_proto_rawDescData []byte
)

func file_documents_v3alpha_comments_proto_rawDescGZIP() []byte {
	file_documents_v3alpha_comments_proto_rawDescOnce.Do(func() {
		file_documents_v3alpha_comments_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_documents_v3alpha_comments_proto_rawDesc), len(file_documents_v3alpha_comments_proto_rawDesc)))
	})
	return file_documents_v3alpha_comments_proto_rawDescData
}

var file_documents_v3alpha_comments_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_documents_v3alpha_comments_proto_goTypes = []any{
	(*CreateCommentRequest)(nil),     // 0: com.seed.documents.v3alpha.CreateCommentRequest
	(*GetCommentRequest)(nil),        // 1: com.seed.documents.v3alpha.GetCommentRequest
	(*BatchGetCommentsRequest)(nil),  // 2: com.seed.documents.v3alpha.BatchGetCommentsRequest
	(*BatchGetCommentsResponse)(nil), // 3: com.seed.documents.v3alpha.BatchGetCommentsResponse
	(*ListCommentsRequest)(nil),      // 4: com.seed.documents.v3alpha.ListCommentsRequest
	(*ListCommentsResponse)(nil),     // 5: com.seed.documents.v3alpha.ListCommentsResponse
	(*Comment)(nil),                  // 6: com.seed.documents.v3alpha.Comment
	(*BlockNode)(nil),                // 7: com.seed.documents.v3alpha.BlockNode
	(*timestamppb.Timestamp)(nil),    // 8: google.protobuf.Timestamp
}
var file_documents_v3alpha_comments_proto_depIdxs = []int32{
	7, // 0: com.seed.documents.v3alpha.CreateCommentRequest.content:type_name -> com.seed.documents.v3alpha.BlockNode
	6, // 1: com.seed.documents.v3alpha.BatchGetCommentsResponse.comments:type_name -> com.seed.documents.v3alpha.Comment
	6, // 2: com.seed.documents.v3alpha.ListCommentsResponse.comments:type_name -> com.seed.documents.v3alpha.Comment
	7, // 3: com.seed.documents.v3alpha.Comment.content:type_name -> com.seed.documents.v3alpha.BlockNode
	8, // 4: com.seed.documents.v3alpha.Comment.create_time:type_name -> google.protobuf.Timestamp
	0, // 5: com.seed.documents.v3alpha.Comments.CreateComment:input_type -> com.seed.documents.v3alpha.CreateCommentRequest
	1, // 6: com.seed.documents.v3alpha.Comments.GetComment:input_type -> com.seed.documents.v3alpha.GetCommentRequest
	2, // 7: com.seed.documents.v3alpha.Comments.BatchGetComments:input_type -> com.seed.documents.v3alpha.BatchGetCommentsRequest
	4, // 8: com.seed.documents.v3alpha.Comments.ListComments:input_type -> com.seed.documents.v3alpha.ListCommentsRequest
	6, // 9: com.seed.documents.v3alpha.Comments.CreateComment:output_type -> com.seed.documents.v3alpha.Comment
	6, // 10: com.seed.documents.v3alpha.Comments.GetComment:output_type -> com.seed.documents.v3alpha.Comment
	3, // 11: com.seed.documents.v3alpha.Comments.BatchGetComments:output_type -> com.seed.documents.v3alpha.BatchGetCommentsResponse
	5, // 12: com.seed.documents.v3alpha.Comments.ListComments:output_type -> com.seed.documents.v3alpha.ListCommentsResponse
	9, // [9:13] is the sub-list for method output_type
	5, // [5:9] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_documents_v3alpha_comments_proto_init() }
func file_documents_v3alpha_comments_proto_init() {
	if File_documents_v3alpha_comments_proto != nil {
		return
	}
	file_documents_v3alpha_documents_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_documents_v3alpha_comments_proto_rawDesc), len(file_documents_v3alpha_comments_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_documents_v3alpha_comments_proto_goTypes,
		DependencyIndexes: file_documents_v3alpha_comments_proto_depIdxs,
		MessageInfos:      file_documents_v3alpha_comments_proto_msgTypes,
	}.Build()
	File_documents_v3alpha_comments_proto = out.File
	file_documents_v3alpha_comments_proto_goTypes = nil
	file_documents_v3alpha_comments_proto_depIdxs = nil
}
