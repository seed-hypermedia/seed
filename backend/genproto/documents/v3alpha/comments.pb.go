// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v4.24.4
// source: documents/v3alpha/comments.proto

package documents

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Request to create a comment.
type CreateCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Requred. Account ID to which the comment is applied.
	TargetAccount string `protobuf:"bytes,1,opt,name=target_account,json=targetAccount,proto3" json:"target_account,omitempty"`
	// Required. Path within the account where the comment is applied.
	TargetPath string `protobuf:"bytes,2,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	// Required. Version of the document at the time of the comment.
	TargetVersion string `protobuf:"bytes,3,opt,name=target_version,json=targetVersion,proto3" json:"target_version,omitempty"`
	// Optional. When current comment is a reply to another comment,
	// this must be the ID of the comment being replied to.
	// Account and path of the parent comment must be the same as the current comment.
	ReplyParent string `protobuf:"bytes,4,opt,name=reply_parent,json=replyParent,proto3" json:"reply_parent,omitempty"`
	// Required. Content of the comment.
	Content []*BlockNode `protobuf:"bytes,5,rep,name=content,proto3" json:"content,omitempty"`
	// Required. Name of the key to use for signing the comment.
	SigningKeyName string `protobuf:"bytes,6,opt,name=signing_key_name,json=signingKeyName,proto3" json:"signing_key_name,omitempty"`
	// Optional. ID of the capability that allows publishing comments for the target account and path.
	// Anyone can create comments to anything, but having a capability to comment makes sure your comments are propagated along with the content.
	Capability    string `protobuf:"bytes,7,opt,name=capability,proto3" json:"capability,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateCommentRequest) Reset() {
	*x = CreateCommentRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateCommentRequest) ProtoMessage() {}

func (x *CreateCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateCommentRequest.ProtoReflect.Descriptor instead.
func (*CreateCommentRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{0}
}

func (x *CreateCommentRequest) GetTargetAccount() string {
	if x != nil {
		return x.TargetAccount
	}
	return ""
}

func (x *CreateCommentRequest) GetTargetPath() string {
	if x != nil {
		return x.TargetPath
	}
	return ""
}

func (x *CreateCommentRequest) GetTargetVersion() string {
	if x != nil {
		return x.TargetVersion
	}
	return ""
}

func (x *CreateCommentRequest) GetReplyParent() string {
	if x != nil {
		return x.ReplyParent
	}
	return ""
}

func (x *CreateCommentRequest) GetContent() []*BlockNode {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *CreateCommentRequest) GetSigningKeyName() string {
	if x != nil {
		return x.SigningKeyName
	}
	return ""
}

func (x *CreateCommentRequest) GetCapability() string {
	if x != nil {
		return x.Capability
	}
	return ""
}

// Request to get a comment.
type GetCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. ID of the comment to retrieve.
	// The ID must be a record ID (`{publicKey}/{tsid}`) of the comment.
	// For convenience we also accept versions (CIDs).
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetCommentRequest) Reset() {
	*x = GetCommentRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCommentRequest) ProtoMessage() {}

func (x *GetCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCommentRequest.ProtoReflect.Descriptor instead.
func (*GetCommentRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{1}
}

func (x *GetCommentRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// Request to get multiple comments.
type BatchGetCommentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. List of comment IDs to retrieve.
	// See [GetCommentRequest] for the format of the IDs.
	Ids           []string `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchGetCommentsRequest) Reset() {
	*x = BatchGetCommentsRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetCommentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetCommentsRequest) ProtoMessage() {}

func (x *BatchGetCommentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetCommentsRequest.ProtoReflect.Descriptor instead.
func (*BatchGetCommentsRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{2}
}

func (x *BatchGetCommentsRequest) GetIds() []string {
	if x != nil {
		return x.Ids
	}
	return nil
}

// Response with multiple comments.
type BatchGetCommentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of comments requested.
	Comments      []*Comment `protobuf:"bytes,1,rep,name=comments,proto3" json:"comments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchGetCommentsResponse) Reset() {
	*x = BatchGetCommentsResponse{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchGetCommentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetCommentsResponse) ProtoMessage() {}

func (x *BatchGetCommentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetCommentsResponse.ProtoReflect.Descriptor instead.
func (*BatchGetCommentsResponse) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{3}
}

func (x *BatchGetCommentsResponse) GetComments() []*Comment {
	if x != nil {
		return x.Comments
	}
	return nil
}

// Request to list comments.
type ListCommentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. Account ID to list the comments for.
	TargetAccount string `protobuf:"bytes,1,opt,name=target_account,json=targetAccount,proto3" json:"target_account,omitempty"`
	// Required. Path within the account to list the comments for.
	TargetPath string `protobuf:"bytes,2,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	// Optional. The maximum number of comments to return.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Optional. The page token obtained from a previous request (if any).
	PageToken     string `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCommentsRequest) Reset() {
	*x = ListCommentsRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCommentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCommentsRequest) ProtoMessage() {}

func (x *ListCommentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCommentsRequest.ProtoReflect.Descriptor instead.
func (*ListCommentsRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{4}
}

func (x *ListCommentsRequest) GetTargetAccount() string {
	if x != nil {
		return x.TargetAccount
	}
	return ""
}

func (x *ListCommentsRequest) GetTargetPath() string {
	if x != nil {
		return x.TargetPath
	}
	return ""
}

func (x *ListCommentsRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListCommentsRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

// Request to list comments by author.
type ListCommentsByAuthorRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. Account ID of the author to list comments for.
	Author string `protobuf:"bytes,1,opt,name=author,proto3" json:"author,omitempty"`
	// Optional. The maximum number of comments to return.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Optional. The page token obtained from a previous request (if any).
	PageToken     string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCommentsByAuthorRequest) Reset() {
	*x = ListCommentsByAuthorRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCommentsByAuthorRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCommentsByAuthorRequest) ProtoMessage() {}

func (x *ListCommentsByAuthorRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCommentsByAuthorRequest.ProtoReflect.Descriptor instead.
func (*ListCommentsByAuthorRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{5}
}

func (x *ListCommentsByAuthorRequest) GetAuthor() string {
	if x != nil {
		return x.Author
	}
	return ""
}

func (x *ListCommentsByAuthorRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListCommentsByAuthorRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

// Response with a list of comments.
type ListCommentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of comments.
	Comments []*Comment `protobuf:"bytes,1,rep,name=comments,proto3" json:"comments,omitempty"`
	// Token to retrieve the next page of comments (if necessary).
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCommentsResponse) Reset() {
	*x = ListCommentsResponse{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCommentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCommentsResponse) ProtoMessage() {}

func (x *ListCommentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCommentsResponse.ProtoReflect.Descriptor instead.
func (*ListCommentsResponse) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{6}
}

func (x *ListCommentsResponse) GetComments() []*Comment {
	if x != nil {
		return x.Comments
	}
	return nil
}

func (x *ListCommentsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

// Comment is a unit of discussion.
type Comment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID of the current comment.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Account ID that this comment targets.
	TargetAccount string `protobuf:"bytes,2,opt,name=target_account,json=targetAccount,proto3" json:"target_account,omitempty"`
	// Path within the account this comment targets.
	TargetPath string `protobuf:"bytes,3,opt,name=target_path,json=targetPath,proto3" json:"target_path,omitempty"`
	// Version of the document this comment targets.
	TargetVersion string `protobuf:"bytes,4,opt,name=target_version,json=targetVersion,proto3" json:"target_version,omitempty"`
	// Optional. The ID of the top-level non-reply comment of the conversation thread.
	ThreadRoot string `protobuf:"bytes,5,opt,name=thread_root,json=threadRoot,proto3" json:"thread_root,omitempty"`
	// Optional. Version of the thread root comment (if this is a reply).
	ThreadRootVersion string `protobuf:"bytes,12,opt,name=thread_root_version,json=threadRootVersion,proto3" json:"thread_root_version,omitempty"`
	// Optional. The ID of the comment to which this comment is a direct reply.
	// For initial comments this field is empty.
	ReplyParent string `protobuf:"bytes,6,opt,name=reply_parent,json=replyParent,proto3" json:"reply_parent,omitempty"`
	// Optional. Version of the parent comment (if this is a reply).
	ReplyParentVersion string `protobuf:"bytes,13,opt,name=reply_parent_version,json=replyParentVersion,proto3" json:"reply_parent_version,omitempty"`
	// Account ID of the author of the comment.
	Author string `protobuf:"bytes,7,opt,name=author,proto3" json:"author,omitempty"`
	// Content of the comment.
	Content []*BlockNode `protobuf:"bytes,8,rep,name=content,proto3" json:"content,omitempty"`
	// Timestamp when the comment was created.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Optional. ID of the capability this comment was created with, if any.
	Capability string `protobuf:"bytes,10,opt,name=capability,proto3" json:"capability,omitempty"`
	// Version of this comment.
	Version string `protobuf:"bytes,11,opt,name=version,proto3" json:"version,omitempty"`
	// Timestamp when the comment was last updated.
	UpdateTime    *timestamppb.Timestamp `protobuf:"bytes,14,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Comment) Reset() {
	*x = Comment{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Comment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Comment) ProtoMessage() {}

func (x *Comment) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Comment.ProtoReflect.Descriptor instead.
func (*Comment) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{7}
}

func (x *Comment) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Comment) GetTargetAccount() string {
	if x != nil {
		return x.TargetAccount
	}
	return ""
}

func (x *Comment) GetTargetPath() string {
	if x != nil {
		return x.TargetPath
	}
	return ""
}

func (x *Comment) GetTargetVersion() string {
	if x != nil {
		return x.TargetVersion
	}
	return ""
}

func (x *Comment) GetThreadRoot() string {
	if x != nil {
		return x.ThreadRoot
	}
	return ""
}

func (x *Comment) GetThreadRootVersion() string {
	if x != nil {
		return x.ThreadRootVersion
	}
	return ""
}

func (x *Comment) GetReplyParent() string {
	if x != nil {
		return x.ReplyParent
	}
	return ""
}

func (x *Comment) GetReplyParentVersion() string {
	if x != nil {
		return x.ReplyParentVersion
	}
	return ""
}

func (x *Comment) GetAuthor() string {
	if x != nil {
		return x.Author
	}
	return ""
}

func (x *Comment) GetContent() []*BlockNode {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *Comment) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Comment) GetCapability() string {
	if x != nil {
		return x.Capability
	}
	return ""
}

func (x *Comment) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Comment) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

// Request to update a comment.
type UpdateCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. Full snapshot of the updated comment record.
	// Clients should update objects received from GetComment or CreateComment calls.
	// The server will ignore output-only fields like timestamps.
	Comment *Comment `protobuf:"bytes,1,opt,name=comment,proto3" json:"comment,omitempty"`
	// Required. Name of the key to use for signing the comment update.
	SigningKeyName string `protobuf:"bytes,2,opt,name=signing_key_name,json=signingKeyName,proto3" json:"signing_key_name,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *UpdateCommentRequest) Reset() {
	*x = UpdateCommentRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateCommentRequest) ProtoMessage() {}

func (x *UpdateCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateCommentRequest.ProtoReflect.Descriptor instead.
func (*UpdateCommentRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{8}
}

func (x *UpdateCommentRequest) GetComment() *Comment {
	if x != nil {
		return x.Comment
	}
	return nil
}

func (x *UpdateCommentRequest) GetSigningKeyName() string {
	if x != nil {
		return x.SigningKeyName
	}
	return ""
}

// Request to delete a comment.
type DeleteCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. ID of the comment to delete.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Required. Name of the key to use for signing the comment deletion.
	SigningKeyName string `protobuf:"bytes,2,opt,name=signing_key_name,json=signingKeyName,proto3" json:"signing_key_name,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DeleteCommentRequest) Reset() {
	*x = DeleteCommentRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteCommentRequest) ProtoMessage() {}

func (x *DeleteCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteCommentRequest.ProtoReflect.Descriptor instead.
func (*DeleteCommentRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{9}
}

func (x *DeleteCommentRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DeleteCommentRequest) GetSigningKeyName() string {
	if x != nil {
		return x.SigningKeyName
	}
	return ""
}

// Request to get the number of replies for a given comment.
type GetCommentReplyCountRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required. ID of the comment to get replies for.
	// The ID must be a record ID (`{publicKey}/{tsid}`) of the comment.
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetCommentReplyCountRequest) Reset() {
	*x = GetCommentReplyCountRequest{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCommentReplyCountRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCommentReplyCountRequest) ProtoMessage() {}

func (x *GetCommentReplyCountRequest) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCommentReplyCountRequest.ProtoReflect.Descriptor instead.
func (*GetCommentReplyCountRequest) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{10}
}

func (x *GetCommentReplyCountRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// Response with the reply count for a comment.
type GetCommentReplyCountResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of replies to the comment.
	ReplyCount    int64 `protobuf:"varint,1,opt,name=reply_count,json=replyCount,proto3" json:"reply_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetCommentReplyCountResponse) Reset() {
	*x = GetCommentReplyCountResponse{}
	mi := &file_documents_v3alpha_comments_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCommentReplyCountResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCommentReplyCountResponse) ProtoMessage() {}

func (x *GetCommentReplyCountResponse) ProtoReflect() protoreflect.Message {
	mi := &file_documents_v3alpha_comments_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCommentReplyCountResponse.ProtoReflect.Descriptor instead.
func (*GetCommentReplyCountResponse) Descriptor() ([]byte, []int) {
	return file_documents_v3alpha_comments_proto_rawDescGZIP(), []int{11}
}

func (x *GetCommentReplyCountResponse) GetReplyCount() int64 {
	if x != nil {
		return x.ReplyCount
	}
	return 0
}

var File_documents_v3alpha_comments_proto protoreflect.FileDescriptor

const file_documents_v3alpha_comments_proto_rawDesc = "" +
	"\n" +
	" documents/v3alpha/comments.proto\x12\x1acom.seed.documents.v3alpha\x1a!documents/v3alpha/documents.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"\xb3\x02\n" +
	"\x14CreateCommentRequest\x12%\n" +
	"\x0etarget_account\x18\x01 \x01(\tR\rtargetAccount\x12\x1f\n" +
	"\vtarget_path\x18\x02 \x01(\tR\n" +
	"targetPath\x12%\n" +
	"\x0etarget_version\x18\x03 \x01(\tR\rtargetVersion\x12!\n" +
	"\freply_parent\x18\x04 \x01(\tR\vreplyParent\x12?\n" +
	"\acontent\x18\x05 \x03(\v2%.com.seed.documents.v3alpha.BlockNodeR\acontent\x12(\n" +
	"\x10signing_key_name\x18\x06 \x01(\tR\x0esigningKeyName\x12\x1e\n" +
	"\n" +
	"capability\x18\a \x01(\tR\n" +
	"capability\"#\n" +
	"\x11GetCommentRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"+\n" +
	"\x17BatchGetCommentsRequest\x12\x10\n" +
	"\x03ids\x18\x01 \x03(\tR\x03ids\"[\n" +
	"\x18BatchGetCommentsResponse\x12?\n" +
	"\bcomments\x18\x01 \x03(\v2#.com.seed.documents.v3alpha.CommentR\bcomments\"\x99\x01\n" +
	"\x13ListCommentsRequest\x12%\n" +
	"\x0etarget_account\x18\x01 \x01(\tR\rtargetAccount\x12\x1f\n" +
	"\vtarget_path\x18\x02 \x01(\tR\n" +
	"targetPath\x12\x1b\n" +
	"\tpage_size\x18\x03 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x04 \x01(\tR\tpageToken\"q\n" +
	"\x1bListCommentsByAuthorRequest\x12\x16\n" +
	"\x06author\x18\x01 \x01(\tR\x06author\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\"\x7f\n" +
	"\x14ListCommentsResponse\x12?\n" +
	"\bcomments\x18\x01 \x03(\v2#.com.seed.documents.v3alpha.CommentR\bcomments\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\xbb\x04\n" +
	"\aComment\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12%\n" +
	"\x0etarget_account\x18\x02 \x01(\tR\rtargetAccount\x12\x1f\n" +
	"\vtarget_path\x18\x03 \x01(\tR\n" +
	"targetPath\x12%\n" +
	"\x0etarget_version\x18\x04 \x01(\tR\rtargetVersion\x12\x1f\n" +
	"\vthread_root\x18\x05 \x01(\tR\n" +
	"threadRoot\x12.\n" +
	"\x13thread_root_version\x18\f \x01(\tR\x11threadRootVersion\x12!\n" +
	"\freply_parent\x18\x06 \x01(\tR\vreplyParent\x120\n" +
	"\x14reply_parent_version\x18\r \x01(\tR\x12replyParentVersion\x12\x16\n" +
	"\x06author\x18\a \x01(\tR\x06author\x12?\n" +
	"\acontent\x18\b \x03(\v2%.com.seed.documents.v3alpha.BlockNodeR\acontent\x12;\n" +
	"\vcreate_time\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12\x1e\n" +
	"\n" +
	"capability\x18\n" +
	" \x01(\tR\n" +
	"capability\x12\x18\n" +
	"\aversion\x18\v \x01(\tR\aversion\x12;\n" +
	"\vupdate_time\x18\x0e \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\"\x7f\n" +
	"\x14UpdateCommentRequest\x12=\n" +
	"\acomment\x18\x01 \x01(\v2#.com.seed.documents.v3alpha.CommentR\acomment\x12(\n" +
	"\x10signing_key_name\x18\x02 \x01(\tR\x0esigningKeyName\"P\n" +
	"\x14DeleteCommentRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12(\n" +
	"\x10signing_key_name\x18\x02 \x01(\tR\x0esigningKeyName\"-\n" +
	"\x1bGetCommentReplyCountRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"?\n" +
	"\x1cGetCommentReplyCountResponse\x12\x1f\n" +
	"\vreply_count\x18\x01 \x01(\x03R\n" +
	"replyCount2\x99\a\n" +
	"\bComments\x12f\n" +
	"\rCreateComment\x120.com.seed.documents.v3alpha.CreateCommentRequest\x1a#.com.seed.documents.v3alpha.Comment\x12`\n" +
	"\n" +
	"GetComment\x12-.com.seed.documents.v3alpha.GetCommentRequest\x1a#.com.seed.documents.v3alpha.Comment\x12}\n" +
	"\x10BatchGetComments\x123.com.seed.documents.v3alpha.BatchGetCommentsRequest\x1a4.com.seed.documents.v3alpha.BatchGetCommentsResponse\x12q\n" +
	"\fListComments\x12/.com.seed.documents.v3alpha.ListCommentsRequest\x1a0.com.seed.documents.v3alpha.ListCommentsResponse\x12\x81\x01\n" +
	"\x14ListCommentsByAuthor\x127.com.seed.documents.v3alpha.ListCommentsByAuthorRequest\x1a0.com.seed.documents.v3alpha.ListCommentsResponse\x12f\n" +
	"\rUpdateComment\x120.com.seed.documents.v3alpha.UpdateCommentRequest\x1a#.com.seed.documents.v3alpha.Comment\x12Y\n" +
	"\rDeleteComment\x120.com.seed.documents.v3alpha.DeleteCommentRequest\x1a\x16.google.protobuf.Empty\x12\x89\x01\n" +
	"\x14GetCommentReplyCount\x127.com.seed.documents.v3alpha.GetCommentReplyCountRequest\x1a8.com.seed.documents.v3alpha.GetCommentReplyCountResponseB3Z1seed/backend/genproto/documents/v3alpha;documentsb\x06proto3"

var (
	file_documents_v3alpha_comments_proto_rawDescOnce sync.Once
	file_documents_v3alpha_comments_proto_rawDescData []byte
)

func file_documents_v3alpha_comments_proto_rawDescGZIP() []byte {
	file_documents_v3alpha_comments_proto_rawDescOnce.Do(func() {
		file_documents_v3alpha_comments_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_documents_v3alpha_comments_proto_rawDesc), len(file_documents_v3alpha_comments_proto_rawDesc)))
	})
	return file_documents_v3alpha_comments_proto_rawDescData
}

var file_documents_v3alpha_comments_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_documents_v3alpha_comments_proto_goTypes = []any{
	(*CreateCommentRequest)(nil),         // 0: com.seed.documents.v3alpha.CreateCommentRequest
	(*GetCommentRequest)(nil),            // 1: com.seed.documents.v3alpha.GetCommentRequest
	(*BatchGetCommentsRequest)(nil),      // 2: com.seed.documents.v3alpha.BatchGetCommentsRequest
	(*BatchGetCommentsResponse)(nil),     // 3: com.seed.documents.v3alpha.BatchGetCommentsResponse
	(*ListCommentsRequest)(nil),          // 4: com.seed.documents.v3alpha.ListCommentsRequest
	(*ListCommentsByAuthorRequest)(nil),  // 5: com.seed.documents.v3alpha.ListCommentsByAuthorRequest
	(*ListCommentsResponse)(nil),         // 6: com.seed.documents.v3alpha.ListCommentsResponse
	(*Comment)(nil),                      // 7: com.seed.documents.v3alpha.Comment
	(*UpdateCommentRequest)(nil),         // 8: com.seed.documents.v3alpha.UpdateCommentRequest
	(*DeleteCommentRequest)(nil),         // 9: com.seed.documents.v3alpha.DeleteCommentRequest
	(*GetCommentReplyCountRequest)(nil),  // 10: com.seed.documents.v3alpha.GetCommentReplyCountRequest
	(*GetCommentReplyCountResponse)(nil), // 11: com.seed.documents.v3alpha.GetCommentReplyCountResponse
	(*BlockNode)(nil),                    // 12: com.seed.documents.v3alpha.BlockNode
	(*timestamppb.Timestamp)(nil),        // 13: google.protobuf.Timestamp
	(*emptypb.Empty)(nil),                // 14: google.protobuf.Empty
}
var file_documents_v3alpha_comments_proto_depIdxs = []int32{
	12, // 0: com.seed.documents.v3alpha.CreateCommentRequest.content:type_name -> com.seed.documents.v3alpha.BlockNode
	7,  // 1: com.seed.documents.v3alpha.BatchGetCommentsResponse.comments:type_name -> com.seed.documents.v3alpha.Comment
	7,  // 2: com.seed.documents.v3alpha.ListCommentsResponse.comments:type_name -> com.seed.documents.v3alpha.Comment
	12, // 3: com.seed.documents.v3alpha.Comment.content:type_name -> com.seed.documents.v3alpha.BlockNode
	13, // 4: com.seed.documents.v3alpha.Comment.create_time:type_name -> google.protobuf.Timestamp
	13, // 5: com.seed.documents.v3alpha.Comment.update_time:type_name -> google.protobuf.Timestamp
	7,  // 6: com.seed.documents.v3alpha.UpdateCommentRequest.comment:type_name -> com.seed.documents.v3alpha.Comment
	0,  // 7: com.seed.documents.v3alpha.Comments.CreateComment:input_type -> com.seed.documents.v3alpha.CreateCommentRequest
	1,  // 8: com.seed.documents.v3alpha.Comments.GetComment:input_type -> com.seed.documents.v3alpha.GetCommentRequest
	2,  // 9: com.seed.documents.v3alpha.Comments.BatchGetComments:input_type -> com.seed.documents.v3alpha.BatchGetCommentsRequest
	4,  // 10: com.seed.documents.v3alpha.Comments.ListComments:input_type -> com.seed.documents.v3alpha.ListCommentsRequest
	5,  // 11: com.seed.documents.v3alpha.Comments.ListCommentsByAuthor:input_type -> com.seed.documents.v3alpha.ListCommentsByAuthorRequest
	8,  // 12: com.seed.documents.v3alpha.Comments.UpdateComment:input_type -> com.seed.documents.v3alpha.UpdateCommentRequest
	9,  // 13: com.seed.documents.v3alpha.Comments.DeleteComment:input_type -> com.seed.documents.v3alpha.DeleteCommentRequest
	10, // 14: com.seed.documents.v3alpha.Comments.GetCommentReplyCount:input_type -> com.seed.documents.v3alpha.GetCommentReplyCountRequest
	7,  // 15: com.seed.documents.v3alpha.Comments.CreateComment:output_type -> com.seed.documents.v3alpha.Comment
	7,  // 16: com.seed.documents.v3alpha.Comments.GetComment:output_type -> com.seed.documents.v3alpha.Comment
	3,  // 17: com.seed.documents.v3alpha.Comments.BatchGetComments:output_type -> com.seed.documents.v3alpha.BatchGetCommentsResponse
	6,  // 18: com.seed.documents.v3alpha.Comments.ListComments:output_type -> com.seed.documents.v3alpha.ListCommentsResponse
	6,  // 19: com.seed.documents.v3alpha.Comments.ListCommentsByAuthor:output_type -> com.seed.documents.v3alpha.ListCommentsResponse
	7,  // 20: com.seed.documents.v3alpha.Comments.UpdateComment:output_type -> com.seed.documents.v3alpha.Comment
	14, // 21: com.seed.documents.v3alpha.Comments.DeleteComment:output_type -> google.protobuf.Empty
	11, // 22: com.seed.documents.v3alpha.Comments.GetCommentReplyCount:output_type -> com.seed.documents.v3alpha.GetCommentReplyCountResponse
	15, // [15:23] is the sub-list for method output_type
	7,  // [7:15] is the sub-list for method input_type
	7,  // [7:7] is the sub-list for extension type_name
	7,  // [7:7] is the sub-list for extension extendee
	0,  // [0:7] is the sub-list for field type_name
}

func init() { file_documents_v3alpha_comments_proto_init() }
func file_documents_v3alpha_comments_proto_init() {
	if File_documents_v3alpha_comments_proto != nil {
		return
	}
	file_documents_v3alpha_documents_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_documents_v3alpha_comments_proto_rawDesc), len(file_documents_v3alpha_comments_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_documents_v3alpha_comments_proto_goTypes,
		DependencyIndexes: file_documents_v3alpha_comments_proto_depIdxs,
		MessageInfos:      file_documents_v3alpha_comments_proto_msgTypes,
	}.Build()
	File_documents_v3alpha_comments_proto = out.File
	file_documents_v3alpha_comments_proto_goTypes = nil
	file_documents_v3alpha_comments_proto_depIdxs = nil
}
