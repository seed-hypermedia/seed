// @generated by protoc-gen-es v1.4.1 with parameter "target=ts,import_extension=none"
// @generated from file pay/accounts/v1/accounts.proto (package accounts.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { price_info } from "./prices_pb";

/**
 * The capabilities that the user can interact with using the account session.
 *
 * @generated from enum accounts.v1.SessionCapabilities
 */
export enum SessionCapabilities {
  /**
   * @generated from enum value: SES_ACCOUNT_MANAGEMENT = 0;
   */
  SES_ACCOUNT_MANAGEMENT = 0,

  /**
   * @generated from enum value: SES_ACCOUNT_ONBOARDING = 1;
   */
  SES_ACCOUNT_ONBOARDING = 1,

  /**
   * @generated from enum value: SES_BALANCES = 2;
   */
  SES_BALANCES = 2,

  /**
   * @generated from enum value: SES_DOCUMENTS = 3;
   */
  SES_DOCUMENTS = 3,

  /**
   * @generated from enum value: SES_FINANCIAL_ACCOUNT = 4;
   */
  SES_FINANCIAL_ACCOUNT = 4,

  /**
   * @generated from enum value: SES_FINANCIAL_ACCOUNT_TRANSACTION = 5;
   */
  SES_FINANCIAL_ACCOUNT_TRANSACTION = 5,

  /**
   * @generated from enum value: SES_FINANCIAL_ISSUING_CARD = 6;
   */
  SES_FINANCIAL_ISSUING_CARD = 6,

  /**
   * @generated from enum value: SES_FINANCIAL_CARDS_LIST = 7;
   */
  SES_FINANCIAL_CARDS_LIST = 7,

  /**
   * @generated from enum value: SES_FINANCIAL_NOTIFICATION_BANNER = 8;
   */
  SES_FINANCIAL_NOTIFICATION_BANNER = 8,

  /**
   * @generated from enum value: SES_FINANCIAL_PAYMENT_DETAILS = 9;
   */
  SES_FINANCIAL_PAYMENT_DETAILS = 9,

  /**
   * @generated from enum value: SES_FINANCIAL_PAYMENTS = 10;
   */
  SES_FINANCIAL_PAYMENTS = 10,

  /**
   * @generated from enum value: SES_FINANCIAL_PAYOUTS = 11;
   */
  SES_FINANCIAL_PAYOUTS = 11,

  /**
   * @generated from enum value: SES_FINANCIAL_PAYOUTS_LIST = 12;
   */
  SES_FINANCIAL_PAYOUTS_LIST = 12,

  /**
   * @generated from enum value: SES_FINANCIAL_TAX_REGISTRATIONS = 13;
   */
  SES_FINANCIAL_TAX_REGISTRATIONS = 13,

  /**
   * @generated from enum value: SES_FINANCIAL_TAX_SETTINGS = 14;
   */
  SES_FINANCIAL_TAX_SETTINGS = 14,
}
// Retrieve enum metadata with: proto3.getEnumType(SessionCapabilities)
proto3.util.setEnumType(SessionCapabilities, "accounts.v1.SessionCapabilities", [
  { no: 0, name: "SES_ACCOUNT_MANAGEMENT" },
  { no: 1, name: "SES_ACCOUNT_ONBOARDING" },
  { no: 2, name: "SES_BALANCES" },
  { no: 3, name: "SES_DOCUMENTS" },
  { no: 4, name: "SES_FINANCIAL_ACCOUNT" },
  { no: 5, name: "SES_FINANCIAL_ACCOUNT_TRANSACTION" },
  { no: 6, name: "SES_FINANCIAL_ISSUING_CARD" },
  { no: 7, name: "SES_FINANCIAL_CARDS_LIST" },
  { no: 8, name: "SES_FINANCIAL_NOTIFICATION_BANNER" },
  { no: 9, name: "SES_FINANCIAL_PAYMENT_DETAILS" },
  { no: 10, name: "SES_FINANCIAL_PAYMENTS" },
  { no: 11, name: "SES_FINANCIAL_PAYOUTS" },
  { no: 12, name: "SES_FINANCIAL_PAYOUTS_LIST" },
  { no: 13, name: "SES_FINANCIAL_TAX_REGISTRATIONS" },
  { no: 14, name: "SES_FINANCIAL_TAX_SETTINGS" },
]);

/**
 * @generated from message accounts.v1.CheckAccountsRequest
 */
export class CheckAccountsRequest extends Message<CheckAccountsRequest> {
  /**
   * Required. The list of accounts to check
   *
   * @generated from field: repeated string uids = 1;
   */
  uids: string[] = [];

  constructor(data?: PartialMessage<CheckAccountsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.CheckAccountsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckAccountsRequest {
    return new CheckAccountsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckAccountsRequest {
    return new CheckAccountsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckAccountsRequest {
    return new CheckAccountsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckAccountsRequest | PlainMessage<CheckAccountsRequest> | undefined, b: CheckAccountsRequest | PlainMessage<CheckAccountsRequest> | undefined): boolean {
    return proto3.util.equals(CheckAccountsRequest, a, b);
  }
}

/**
 * @generated from message accounts.v1.CheckAccountsResponse
 */
export class CheckAccountsResponse extends Message<CheckAccountsResponse> {
  /**
   * From the list of CheckAccountsRequest.uids, we return
   * only the accounts from that list that are valid and
   * can be used.
   *
   * @generated from field: repeated string uids = 1;
   */
  uids: string[] = [];

  constructor(data?: PartialMessage<CheckAccountsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.CheckAccountsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckAccountsResponse {
    return new CheckAccountsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckAccountsResponse {
    return new CheckAccountsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckAccountsResponse {
    return new CheckAccountsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckAccountsResponse | PlainMessage<CheckAccountsResponse> | undefined, b: CheckAccountsResponse | PlainMessage<CheckAccountsResponse> | undefined): boolean {
    return proto3.util.equals(CheckAccountsResponse, a, b);
  }
}

/**
 * We define the absolute minimum required to create an account.
 * the rest of the information will be collected by the service
 * provider during the onboarding process.
 *
 * @generated from message accounts.v1.NewAccountRequest
 */
export class NewAccountRequest extends Message<NewAccountRequest> {
  /**
   * Required. The user identificator to create the account for.
   * It must exist in hyper.media protocol. The user must provide proof
   * of ownership of this ID by signing a message with the private key.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * Required. The URL that the user will try to monetize. We will check
   * <url>/hm/api/config and make sure the `registeredAccountUid` seen
   * matches the provided uid. If the URL is a free url, it should be in the
   * form of <domain>/hm/<uid> in which case we will only check that URL exists.
   * If the user upgrades and gets a custom domain later, they can update the
   * account with the new URL using CreateAccountSession or CreateAccountLink.
   *
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * Optional. The public facing name of the business no monetize. If its a
   * blog, it could be the blog name. If its a business, it could be the
   * business name. This is used for display purposes to the customer and does
   * not need to be unique. If not provided, it will be set to the uid of the
   * account.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  constructor(data?: PartialMessage<NewAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.NewAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewAccountRequest {
    return new NewAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewAccountRequest {
    return new NewAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewAccountRequest {
    return new NewAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NewAccountRequest | PlainMessage<NewAccountRequest> | undefined, b: NewAccountRequest | PlainMessage<NewAccountRequest> | undefined): boolean {
    return proto3.util.equals(NewAccountRequest, a, b);
  }
}

/**
 * The response with the list of events.
 *
 * @generated from message accounts.v1.AccountResponse
 */
export class AccountResponse extends Message<AccountResponse> {
  /**
   * The newly created account.
   *
   * @generated from field: accounts.v1.Account account = 1;
   */
  account?: Account;

  constructor(data?: PartialMessage<AccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.AccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "message", T: Account },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountResponse {
    return new AccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountResponse {
    return new AccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountResponse {
    return new AccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AccountResponse | PlainMessage<AccountResponse> | undefined, b: AccountResponse | PlainMessage<AccountResponse> | undefined): boolean {
    return proto3.util.equals(AccountResponse, a, b);
  }
}

/**
 * The account request.
 *
 * @generated from message accounts.v1.AccountRequest
 */
export class AccountRequest extends Message<AccountRequest> {
  /**
   * Required. The id of the account.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  constructor(data?: PartialMessage<AccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.AccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountRequest {
    return new AccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountRequest {
    return new AccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountRequest {
    return new AccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AccountRequest | PlainMessage<AccountRequest> | undefined, b: AccountRequest | PlainMessage<AccountRequest> | undefined): boolean {
    return proto3.util.equals(AccountRequest, a, b);
  }
}

/**
 * The request to create an account link.
 *
 * @generated from message accounts.v1.AccountLinkRequest
 */
export class AccountLinkRequest extends Message<AccountLinkRequest> {
  /**
   * Required. The id of the account to create a link for.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * Required. The URL the user will be redirected to if the account link is
   * expired, has been previously-visited, or is otherwise invalid
   *
   * @generated from field: string refresh_url = 2;
   */
  refreshUrl = "";

  /**
   * Required. The URL the user will be redirected to after completing the
   * account link.
   *
   * @generated from field: string return_url = 3;
   */
  returnUrl = "";

  /**
   * @generated from field: accounts.v1.AccountLinkRequest.AccountLinkType type = 4;
   */
  type = AccountLinkRequest_AccountLinkType.account_onboarding;

  constructor(data?: PartialMessage<AccountLinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.AccountLinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "refresh_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "return_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "type", kind: "enum", T: proto3.getEnumType(AccountLinkRequest_AccountLinkType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountLinkRequest {
    return new AccountLinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountLinkRequest {
    return new AccountLinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountLinkRequest {
    return new AccountLinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AccountLinkRequest | PlainMessage<AccountLinkRequest> | undefined, b: AccountLinkRequest | PlainMessage<AccountLinkRequest> | undefined): boolean {
    return proto3.util.equals(AccountLinkRequest, a, b);
  }
}

/**
 * Required. The type of the account link to create.
 * Can be either account_onboarding or account_update.
 *
 * @generated from enum accounts.v1.AccountLinkRequest.AccountLinkType
 */
export enum AccountLinkRequest_AccountLinkType {
  /**
   * For onboarding the account.
   *
   * @generated from enum value: account_onboarding = 0;
   */
  account_onboarding = 0,

  /**
   * For updating the account information.
   *
   * @generated from enum value: account_update = 1;
   */
  account_update = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(AccountLinkRequest_AccountLinkType)
proto3.util.setEnumType(AccountLinkRequest_AccountLinkType, "accounts.v1.AccountLinkRequest.AccountLinkType", [
  { no: 0, name: "account_onboarding" },
  { no: 1, name: "account_update" },
]);

/**
 * @generated from message accounts.v1.AccountBalanceResponse
 */
export class AccountBalanceResponse extends Message<AccountBalanceResponse> {
  /**
   * The current balance of the account. One item per currency.
   *
   * @generated from field: repeated accounts.v1.price_info available = 1;
   */
  available: price_info[] = [];

  /**
   * The pending balance of the account.
   * This is the amount that is not yet available.
   * One item per currency.
   *
   * @generated from field: repeated accounts.v1.price_info pending = 2;
   */
  pending: price_info[] = [];

  /**
   * The reserved balance of the account.
   * This is the amount that is reserved.
   * Used to offset negative balances or to cover future payments.
   * One item per currency.
   *
   * @generated from field: repeated accounts.v1.price_info reserved = 3;
   */
  reserved: price_info[] = [];

  constructor(data?: PartialMessage<AccountBalanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.AccountBalanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "available", kind: "message", T: price_info, repeated: true },
    { no: 2, name: "pending", kind: "message", T: price_info, repeated: true },
    { no: 3, name: "reserved", kind: "message", T: price_info, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountBalanceResponse {
    return new AccountBalanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountBalanceResponse {
    return new AccountBalanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountBalanceResponse {
    return new AccountBalanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AccountBalanceResponse | PlainMessage<AccountBalanceResponse> | undefined, b: AccountBalanceResponse | PlainMessage<AccountBalanceResponse> | undefined): boolean {
    return proto3.util.equals(AccountBalanceResponse, a, b);
  }
}

/**
 * @generated from message accounts.v1.ListTransactionsRequest
 */
export class ListTransactionsRequest extends Message<ListTransactionsRequest> {
  /**
   * Required. The id of the account to list transactions for.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * Optional. The maximum number of transactions to return. Default is 100.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Optional. The page token to use for pagination.
   * If not provided, all transactions will be returned.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListTransactionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.ListTransactionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListTransactionsRequest | PlainMessage<ListTransactionsRequest> | undefined, b: ListTransactionsRequest | PlainMessage<ListTransactionsRequest> | undefined): boolean {
    return proto3.util.equals(ListTransactionsRequest, a, b);
  }
}

/**
 * The request to list transactions for the account.
 *
 * @generated from message accounts.v1.ListTransactionsResponse
 */
export class ListTransactionsResponse extends Message<ListTransactionsResponse> {
  /**
   * The list of transactions for the account.
   *
   * @generated from field: repeated accounts.v1.transaction transactions = 1;
   */
  transactions: transaction[] = [];

  /**
   * The token to be used for requesting the next page of transactions.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListTransactionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.ListTransactionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactions", kind: "message", T: transaction, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTransactionsResponse {
    return new ListTransactionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTransactionsResponse {
    return new ListTransactionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTransactionsResponse {
    return new ListTransactionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListTransactionsResponse | PlainMessage<ListTransactionsResponse> | undefined, b: ListTransactionsResponse | PlainMessage<ListTransactionsResponse> | undefined): boolean {
    return proto3.util.equals(ListTransactionsResponse, a, b);
  }
}

/**
 * @generated from message accounts.v1.transaction
 */
export class transaction extends Message<transaction> {
  /**
   * The amount of the transaction.
   *
   * @generated from field: float amount = 1;
   */
  amount = 0;

  /**
   * The currency of the transaction.
   *
   * @generated from field: string currency = 2;
   */
  currency = "";

  /**
   * The description of the transaction.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * The status of the transaction.
   *
   * @generated from field: string status = 4;
   */
  status = "";

  /**
   * The id of the account that send the transaction.
   *
   * @generated from field: string payer_uid = 5;
   */
  payerUid = "";

  /**
   * The id of the account that receives the transaction.
   *
   * @generated from field: string payee_uid = 6;
   */
  payeeUid = "";

  /**
   * The time when the transaction was settled.
   *
   * @generated from field: google.protobuf.Timestamp settled = 7;
   */
  settled?: Timestamp;

  /**
   * The URL to the receipt of the transaction.
   *
   * @generated from field: string receipt_url = 8;
   */
  receiptUrl = "";

  /**
   * Where the transaction was originated, document, comment, ...
   * If available it shoudl be a hypermedia URL
   *
   * @generated from field: string source = 9;
   */
  source = "";

  /**
   * The fee charged for the transaction.
   * This is the amount that the payment provider charges for processing the
   * transaction.
   *
   * @generated from field: float application_fee = 10;
   */
  applicationFee = 0;

  constructor(data?: PartialMessage<transaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.transaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "payer_uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "payee_uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "settled", kind: "message", T: Timestamp },
    { no: 8, name: "receipt_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "application_fee", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): transaction {
    return new transaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): transaction {
    return new transaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): transaction {
    return new transaction().fromJsonString(jsonString, options);
  }

  static equals(a: transaction | PlainMessage<transaction> | undefined, b: transaction | PlainMessage<transaction> | undefined): boolean {
    return proto3.util.equals(transaction, a, b);
  }
}

/**
 * The response with the account link information.
 *
 * @generated from message accounts.v1.AccountLinkResponse
 */
export class AccountLinkResponse extends Message<AccountLinkResponse> {
  /**
   * The link that the user will be redirected to in order to complete the
   * account link. This link will open the payment provider's platform in the
   * user's browser. The user will be able to complete the onboarding or update
   * process there. After the user completes the process, they will be
   * redirected to the return_url provided in the AccountLinkRequest.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * When the link will expire. After this time, the user will have to create a
   * new account link
   *
   * @generated from field: google.protobuf.Timestamp link_expiration = 2;
   */
  linkExpiration?: Timestamp;

  constructor(data?: PartialMessage<AccountLinkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.AccountLinkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "link_expiration", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountLinkResponse {
    return new AccountLinkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountLinkResponse {
    return new AccountLinkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountLinkResponse {
    return new AccountLinkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AccountLinkResponse | PlainMessage<AccountLinkResponse> | undefined, b: AccountLinkResponse | PlainMessage<AccountLinkResponse> | undefined): boolean {
    return proto3.util.equals(AccountLinkResponse, a, b);
  }
}

/**
 * Request an account session secret to be used with embedded components.
 *
 * @generated from message accounts.v1.AccountSessionRequest
 */
export class AccountSessionRequest extends Message<AccountSessionRequest> {
  /**
   * Required. The id of the account to create a session for.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * Required. What components the user will be able to interact with using this
   * session. Usually, you only interact with one component at a time, but you
   * can request multiple components to be available in the session.
   *
   * @generated from field: repeated accounts.v1.SessionCapabilities components = 2;
   */
  components: SessionCapabilities[] = [];

  constructor(data?: PartialMessage<AccountSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.AccountSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "components", kind: "enum", T: proto3.getEnumType(SessionCapabilities), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountSessionRequest {
    return new AccountSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountSessionRequest {
    return new AccountSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountSessionRequest {
    return new AccountSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AccountSessionRequest | PlainMessage<AccountSessionRequest> | undefined, b: AccountSessionRequest | PlainMessage<AccountSessionRequest> | undefined): boolean {
    return proto3.util.equals(AccountSessionRequest, a, b);
  }
}

/**
 * The response with the account session information.
 *
 * @generated from message accounts.v1.AccountSessionResponse
 */
export class AccountSessionResponse extends Message<AccountSessionResponse> {
  /**
   * The session secret that the user will use to interact with the embedded
   * components. This secret should be used only once and is valid for a short
   * period of time. After the session expires, the user will need to create a
   * new session to interact with the embedded components.
   *
   * @generated from field: string secret = 1;
   */
  secret = "";

  /**
   * The account uid to be managed. For reconciliation purposes.
   *
   * @generated from field: string uid = 2;
   */
  uid = "";

  /**
   * When the session will expire. After this time, the secret will no longer
   * be valid and the user will need to start a new account session.
   *
   * @generated from field: google.protobuf.Timestamp session_expiration = 3;
   */
  sessionExpiration?: Timestamp;

  /**
   * If the account session is for production or not. If false, the
   * session is for testing purposes and will not affect real payments.
   *
   * @generated from field: bool is_production = 4;
   */
  isProduction = false;

  constructor(data?: PartialMessage<AccountSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.AccountSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "secret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "session_expiration", kind: "message", T: Timestamp },
    { no: 4, name: "is_production", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountSessionResponse {
    return new AccountSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountSessionResponse {
    return new AccountSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountSessionResponse {
    return new AccountSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AccountSessionResponse | PlainMessage<AccountSessionResponse> | undefined, b: AccountSessionResponse | PlainMessage<AccountSessionResponse> | undefined): boolean {
    return proto3.util.equals(AccountSessionResponse, a, b);
  }
}

/**
 * Account represents a user account on the platform.
 *
 * @generated from message accounts.v1.Account
 */
export class Account extends Message<Account> {
  /**
   * The unique identifyer of the account
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * The site of the account. This will be used to check if the account
   * has a valid and real hyper.media home page.
   * It must be a subdomain, a custom domain. or a free hyper.media url.
   * Also, this URL will be used when creating the automatic donation
   * product for the account.
   * If the user later upgrades and gets a custom domain, they can update the
   * account with the new URL using CreateAccountSession or CreateAccountLink.
   *
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * Whether the account is fully onboarded or not.
   * If false, the account is not yet ready to accept payments.
   *
   * @generated from field: bool details_submitted = 3;
   */
  detailsSubmitted = false;

  /**
   * Country of the account. Blank if the account has not
   * been onboarded yet.
   *
   * @generated from field: string country = 4;
   */
  country = "";

  /**
   * The currency the account is denominated in.
   *
   * @generated from field: string currency = 5;
   */
  currency = "";

  /**
   * A list of capabilities enabled for the account.
   *
   * @generated from field: repeated string capabilities = 6;
   */
  capabilities: string[] = [];

  /**
   * Whether the account has payouts enabled or not.
   * If false, the account is not yet ready to take money to external bank
   * accounts.
   *
   * @generated from field: bool payouts_enabled = 7;
   */
  payoutsEnabled = false;

  /**
   * When the account was actually created.
   *
   * @generated from field: google.protobuf.Timestamp created_time = 8;
   */
  createdTime?: Timestamp;

  constructor(data?: PartialMessage<Account>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accounts.v1.Account";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "details_submitted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "capabilities", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "payouts_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "created_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Account {
    return new Account().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Account {
    return new Account().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Account {
    return new Account().fromJsonString(jsonString, options);
  }

  static equals(a: Account | PlainMessage<Account> | undefined, b: Account | PlainMessage<Account> | undefined): boolean {
    return proto3.util.equals(Account, a, b);
  }
}

