// @generated by protoc-gen-es v1.4.1 with parameter "target=ts,import_extension=none"
// @generated from file pay/customers/v1/customers.proto (package customers.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Price } from "../../accounts/v1/prices_pb";

/**
 * The components that the user can interact with using the customer session.
 *
 * @generated from enum customers.v1.SessionComponents
 */
export enum SessionComponents {
  /**
   * @generated from enum value: SES_COMP_BUY_BUTTON = 0;
   */
  SES_COMP_BUY_BUTTON = 0,

  /**
   * @generated from enum value: SES_COMP_PAYMENT_ELEMENT = 1;
   */
  SES_COMP_PAYMENT_ELEMENT = 1,

  /**
   * @generated from enum value: SES_COMP_PRICING_TABLE = 2;
   */
  SES_COMP_PRICING_TABLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SessionComponents)
proto3.util.setEnumType(SessionComponents, "customers.v1.SessionComponents", [
  { no: 0, name: "SES_COMP_BUY_BUTTON" },
  { no: 1, name: "SES_COMP_PAYMENT_ELEMENT" },
  { no: 2, name: "SES_COMP_PRICING_TABLE" },
]);

/**
 * @generated from enum customers.v1.UIMode
 */
export enum UIMode {
  /**
   * Default mode, usually a full page checkout.
   *
   * @generated from enum value: UI_MODE_CUSTOM = 0;
   */
  UI_MODE_CUSTOM = 0,

  /**
   * Embedded mode, used for embedded components.
   *
   * @generated from enum value: UI_MODE_EMBEDDED = 1;
   */
  UI_MODE_EMBEDDED = 1,

  /**
   * Hosted mode, used for hosted pages.
   *
   * @generated from enum value: UI_MODE_HOSTED = 2;
   */
  UI_MODE_HOSTED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UIMode)
proto3.util.setEnumType(UIMode, "customers.v1.UIMode", [
  { no: 0, name: "UI_MODE_CUSTOM" },
  { no: 1, name: "UI_MODE_EMBEDDED" },
  { no: 2, name: "UI_MODE_HOSTED" },
]);

/**
 * The customer request.
 *
 * @generated from message customers.v1.NewCustomerRequest
 */
export class NewCustomerRequest extends Message<NewCustomerRequest> {
  /**
   * Required. The uid of the account we are creating the customer for.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * Optional. Non unique, public facing name of the customer.
   * Could be a nickname or a full name. This is used for display purposes
   * only and does not need to be unique. It can be used to identify
   * the customer in the UI.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<NewCustomerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.NewCustomerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewCustomerRequest {
    return new NewCustomerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewCustomerRequest {
    return new NewCustomerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewCustomerRequest {
    return new NewCustomerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NewCustomerRequest | PlainMessage<NewCustomerRequest> | undefined, b: NewCustomerRequest | PlainMessage<NewCustomerRequest> | undefined): boolean {
    return proto3.util.equals(NewCustomerRequest, a, b);
  }
}

/**
 * The customer request.
 *
 * @generated from message customers.v1.CustomerRequest
 */
export class CustomerRequest extends Message<CustomerRequest> {
  /**
   * Required. The uid of the customer.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  constructor(data?: PartialMessage<CustomerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.CustomerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomerRequest {
    return new CustomerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomerRequest {
    return new CustomerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomerRequest {
    return new CustomerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CustomerRequest | PlainMessage<CustomerRequest> | undefined, b: CustomerRequest | PlainMessage<CustomerRequest> | undefined): boolean {
    return proto3.util.equals(CustomerRequest, a, b);
  }
}

/**
 * The customer portal session request.
 *
 * @generated from message customers.v1.CustomerPortalSessionRequest
 */
export class CustomerPortalSessionRequest extends Message<CustomerPortalSessionRequest> {
  /**
   * Required. The uid of the customer.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * Optional. The URL to redirect the user to after the user cancelled or goes
   * back from the customer portal page. If not provided, the user will be
   * redirected to the default customer portal page https://seed.hyper.media.
   *
   * @generated from field: string return_url = 2;
   */
  returnUrl = "";

  constructor(data?: PartialMessage<CustomerPortalSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.CustomerPortalSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "return_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomerPortalSessionRequest {
    return new CustomerPortalSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomerPortalSessionRequest {
    return new CustomerPortalSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomerPortalSessionRequest {
    return new CustomerPortalSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CustomerPortalSessionRequest | PlainMessage<CustomerPortalSessionRequest> | undefined, b: CustomerPortalSessionRequest | PlainMessage<CustomerPortalSessionRequest> | undefined): boolean {
    return proto3.util.equals(CustomerPortalSessionRequest, a, b);
  }
}

/**
 * The response with the customer portal session link.
 *
 * @generated from message customers.v1.CustomerPortalSessionResponse
 */
export class CustomerPortalSessionResponse extends Message<CustomerPortalSessionResponse> {
  /**
   * The session URL that the customer can use to access the customer portal.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  constructor(data?: PartialMessage<CustomerPortalSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.CustomerPortalSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomerPortalSessionResponse {
    return new CustomerPortalSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomerPortalSessionResponse {
    return new CustomerPortalSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomerPortalSessionResponse {
    return new CustomerPortalSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CustomerPortalSessionResponse | PlainMessage<CustomerPortalSessionResponse> | undefined, b: CustomerPortalSessionResponse | PlainMessage<CustomerPortalSessionResponse> | undefined): boolean {
    return proto3.util.equals(CustomerPortalSessionResponse, a, b);
  }
}

/**
 * The response with the customer information.
 *
 * @generated from message customers.v1.CustomerResponse
 */
export class CustomerResponse extends Message<CustomerResponse> {
  /**
   * The newly created customer.
   *
   * @generated from field: customers.v1.Customer customer = 1;
   */
  customer?: Customer;

  constructor(data?: PartialMessage<CustomerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.CustomerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "customer", kind: "message", T: Customer },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomerResponse {
    return new CustomerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomerResponse {
    return new CustomerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomerResponse {
    return new CustomerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CustomerResponse | PlainMessage<CustomerResponse> | undefined, b: CustomerResponse | PlainMessage<CustomerResponse> | undefined): boolean {
    return proto3.util.equals(CustomerResponse, a, b);
  }
}

/**
 * Request a customer session secret to be used with embedded components.
 *
 * @generated from message customers.v1.CustomerSessionRequest
 */
export class CustomerSessionRequest extends Message<CustomerSessionRequest> {
  /**
   * Required. The uid of the customer to create a session for.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * Required. Which component the user will be able to interact with using this
   * session. Only one component can be specified at a time.
   *
   * @generated from field: customers.v1.SessionComponents component = 2;
   */
  component = SessionComponents.SES_COMP_BUY_BUTTON;

  constructor(data?: PartialMessage<CustomerSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.CustomerSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "component", kind: "enum", T: proto3.getEnumType(SessionComponents) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomerSessionRequest {
    return new CustomerSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomerSessionRequest {
    return new CustomerSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomerSessionRequest {
    return new CustomerSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CustomerSessionRequest | PlainMessage<CustomerSessionRequest> | undefined, b: CustomerSessionRequest | PlainMessage<CustomerSessionRequest> | undefined): boolean {
    return proto3.util.equals(CustomerSessionRequest, a, b);
  }
}

/**
 * The response with the customer session.
 *
 * @generated from message customers.v1.CustomerSessionResponse
 */
export class CustomerSessionResponse extends Message<CustomerSessionResponse> {
  /**
   * The session secret that the user will use to interact with the embedded
   * components. This secret should be used only once and is valid for a short
   * period of time. After the session expires, the user will need to create a
   * new session to interact with the embedded components.
   *
   * @generated from field: string secret = 1;
   */
  secret = "";

  /**
   * When the session will expire. After this time, the secret will no longer
   * be valid and the user will need to start a new account session.
   *
   * @generated from field: google.protobuf.Timestamp session_expiration = 2;
   */
  sessionExpiration?: Timestamp;

  /**
   * If the account session is for production or not. If false, the
   * session is for testing purposes and will not affect real payments.
   *
   * @generated from field: bool is_production = 3;
   */
  isProduction = false;

  constructor(data?: PartialMessage<CustomerSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.CustomerSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "secret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "session_expiration", kind: "message", T: Timestamp },
    { no: 3, name: "is_production", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomerSessionResponse {
    return new CustomerSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomerSessionResponse {
    return new CustomerSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomerSessionResponse {
    return new CustomerSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CustomerSessionResponse | PlainMessage<CustomerSessionResponse> | undefined, b: CustomerSessionResponse | PlainMessage<CustomerSessionResponse> | undefined): boolean {
    return proto3.util.equals(CustomerSessionResponse, a, b);
  }
}

/**
 * Description of the event occurred in the system.
 *
 * @generated from message customers.v1.Customer
 */
export class Customer extends Message<Customer> {
  /**
   * The unique identifyer of the customer
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * The public facing name of the customer
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * When the customer was actually created.
   *
   * @generated from field: google.protobuf.Timestamp created_time = 3;
   */
  createdTime?: Timestamp;

  constructor(data?: PartialMessage<Customer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.Customer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Customer {
    return new Customer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Customer {
    return new Customer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Customer {
    return new Customer().fromJsonString(jsonString, options);
  }

  static equals(a: Customer | PlainMessage<Customer> | undefined, b: Customer | PlainMessage<Customer> | undefined): boolean {
    return proto3.util.equals(Customer, a, b);
  }
}

/**
 * The request to create a checkout session for the customer. Currently only
 * donations are supported, so the price will be an open price to be set by the
 * customer at the checkout page. Only non recurrent payments are supported at
 * the moment.
 *
 * @generated from message customers.v1.CheckoutSessionRequest
 */
export class CheckoutSessionRequest extends Message<CheckoutSessionRequest> {
  /**
   * Required: The URL to redirect the user to after the user either goes back
   * or the payment succeds. The behaviour depends on the ui_mode. If the
   * ui_mode is UI_MODE_CUSTOM or UI_MODE_EMBEDDED, this will be the URL the
   * user will be redirected to if they go back from the checkout page. If the
   * ui_mode is UI_MODE_HOSTED, this will be the URL the user will be redirected
   * to after the payment is successful.
   *
   * @generated from oneof customers.v1.CheckoutSessionRequest.url
   */
  url: {
    /**
     * For custom and embedded checkout sessions, the URL to redirect the user
     * to after the user goes back from the checkout page. This URL is usually
     * the page where the user started the checkout process. It is used to
     * return the user to the page they were on before starting the checkout
     * process, so they can continue browsing the site or app.
     *
     * @generated from field: string return_url = 1;
     */
    value: string;
    case: "returnUrl";
  } | {
    /**
     * For hosted checkout sessions, the URL to redirect the user to
     * after the payment is successful.
     *
     * @generated from field: string success_url = 2;
     */
    value: string;
    case: "successUrl";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Required: The UI mode for the checkout session. This will modify how
   * we respond to the user. On Custom and EMbedded modes, the response will
   * contain a session secret that the user can use to interact with the
   * checkout page. On Hosted mode, the response will contain a URL that the
   * user can use to access the checkout page directly.
   *
   * @generated from field: customers.v1.UIMode ui_mode = 3;
   */
  uiMode = UIMode.UI_MODE_CUSTOM;

  /**
   * Optional. The price information that will be used to charge the customer.
   * If price.id is provided, the rest of the fields will be ignored and the
   * price will be populated as described in the price.id. If price.id is not
   * provided, the rest og the fields will be used to create the price
   * information. The first price.info will be used to get quantity and currency
   * information.
   *
   * @generated from field: accounts.v1.Price price = 4;
   */
  price?: Price;

  /**
   * Optional. The uid of the account to be paid. This account will receive a
   * payment from the payer_uid (The customer, if provided) and will be used to
   * create the session. If payee_uid is not provided, the session will be
   * created for the platform account, meaning the customer is paying for a
   * platform service or product.
   *
   * @generated from field: string payee_uid = 5;
   */
  payeeUid = "";

  /**
   * Optional. The uid of the customer to create a session for. If not provided,
   * the session will be created for a guest customer (usually a web user) but
   * payments will not be associated with a specific customer and will not keep
   * track of the customer's payment methods or history.
   *
   * @generated from field: string payer_uid = 6;
   */
  payerUid = "";

  constructor(data?: PartialMessage<CheckoutSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.CheckoutSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "return_url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "url" },
    { no: 2, name: "success_url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "url" },
    { no: 3, name: "ui_mode", kind: "enum", T: proto3.getEnumType(UIMode) },
    { no: 4, name: "price", kind: "message", T: Price },
    { no: 5, name: "payee_uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "payer_uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSessionRequest {
    return new CheckoutSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSessionRequest {
    return new CheckoutSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSessionRequest {
    return new CheckoutSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSessionRequest | PlainMessage<CheckoutSessionRequest> | undefined, b: CheckoutSessionRequest | PlainMessage<CheckoutSessionRequest> | undefined): boolean {
    return proto3.util.equals(CheckoutSessionRequest, a, b);
  }
}

/**
 * The response with the checkout session information.
 *
 * @generated from message customers.v1.CheckoutSessionResponse
 */
export class CheckoutSessionResponse extends Message<CheckoutSessionResponse> {
  /**
   * The session secret that the user will use to interact with the checkout
   * page. This secret should be used only once and is valid for a short period
   * of time. After the session expires, the user will need to create a new
   * session to interact with the checkout page.
   *
   * @generated from oneof customers.v1.CheckoutSessionResponse.link
   */
  link: {
    /**
     * For embedded and custom checkout sessions, the secret that the user will
     * use to interact with the checkout page.
     *
     * @generated from field: string secret = 1;
     */
    value: string;
    case: "secret";
  } | {
    /**
     * For hosted checkout sessions, the URL to redirect the user to.
     *
     * @generated from field: string url = 2;
     */
    value: string;
    case: "url";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * When the session will expire. After this time, the secret will no longer
   * be valid and the user will need to start a new checkout session.
   *
   * @generated from field: google.protobuf.Timestamp session_expiration = 3;
   */
  sessionExpiration?: Timestamp;

  /**
   * If the account session is for production or not. If false, the
   * session is for testing purposes and will not affect real payments.
   *
   * @generated from field: bool is_production = 4;
   */
  isProduction = false;

  constructor(data?: PartialMessage<CheckoutSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.CheckoutSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "secret", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "link" },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "link" },
    { no: 3, name: "session_expiration", kind: "message", T: Timestamp },
    { no: 4, name: "is_production", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckoutSessionResponse {
    return new CheckoutSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckoutSessionResponse {
    return new CheckoutSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckoutSessionResponse {
    return new CheckoutSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckoutSessionResponse | PlainMessage<CheckoutSessionResponse> | undefined, b: CheckoutSessionResponse | PlainMessage<CheckoutSessionResponse> | undefined): boolean {
    return proto3.util.equals(CheckoutSessionResponse, a, b);
  }
}

/**
 * @generated from message customers.v1.ListTransactionsRequest
 */
export class ListTransactionsRequest extends Message<ListTransactionsRequest> {
  /**
   * Required. The id of the customer to list transactions for.
   *
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * Optional. The maximum number of transactions to return. Default is 100.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Optional. The page token to use for pagination.
   * If not provided, all transactions will be returned.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListTransactionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "customers.v1.ListTransactionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTransactionsRequest {
    return new ListTransactionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListTransactionsRequest | PlainMessage<ListTransactionsRequest> | undefined, b: ListTransactionsRequest | PlainMessage<ListTransactionsRequest> | undefined): boolean {
    return proto3.util.equals(ListTransactionsRequest, a, b);
  }
}

