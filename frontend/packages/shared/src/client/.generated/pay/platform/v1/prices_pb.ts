// @generated by protoc-gen-es v1.4.1 with parameter "target=ts,import_extension=none"
// @generated from file pay/platform/v1/prices.proto (package platform.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum platform.v1.PriceType
 */
export enum PriceType {
  /**
   * The price type is unknown.
   *
   * @generated from enum value: PRICE_TYPE_UNKNOWN = 0;
   */
  PRICE_TYPE_UNKNOWN = 0,

  /**
   * The price is a fixed price. This means that the customer will be charged a
   * fixed amount.
   *
   * @generated from enum value: FIXED_PRICE = 1;
   */
  FIXED_PRICE = 1,

  /**
   * The total price is a metered price. This means that the customer will be
   * charged based on their usage.
   *
   * @generated from enum value: METERED_PRICE = 2;
   */
  METERED_PRICE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PriceType)
proto3.util.setEnumType(PriceType, "platform.v1.PriceType", [
  { no: 0, name: "PRICE_TYPE_UNKNOWN" },
  { no: 1, name: "FIXED_PRICE" },
  { no: 2, name: "METERED_PRICE" },
]);

/**
 * The Create price Request used to create a new price for an account
 * to be monetized. The caller must provide proof of ownership of the platform
 * uid by signing a message with the private key associated with the platform
 * uid and attaching the signature to the request as a `signature` field in the
 * request header.
 *
 * @generated from message platform.v1.CreatePriceRequest
 */
export class CreatePriceRequest extends Message<CreatePriceRequest> {
  /**
   * Required. The price description.
   *
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * The type of the price. The type of the price will determine how the price
   * is charged to the customers.
   *
   * @generated from field: platform.v1.PriceType type = 2;
   */
  type = PriceType.PRICE_TYPE_UNKNOWN;

  /**
   * The price information that will be used to charge the customers. A price
   * can have multiple price information localized for different currencies or
   * different amounts. For example, a price can have a fixed price in USD and a
   * fixed price in EUR. The price information will be used to charge the
   * customers based on their location or the currency they choose to pay with.
   * If the price is an open price, the amount will be 0 but the currency will
   * still be set. If there is only one price information, and the customer
   * wants to pay in a different currency, the platform will convert the amount
   * to the customer's currency using the current exchange rate. If the price
   * has multiple pricing information, the platform will use the first one that
   * matches the customer's currency.
   *
   * @generated from field: repeated platform.v1.price_info info = 3;
   */
  info: price_info[] = [];

  constructor(data?: PartialMessage<CreatePriceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.CreatePriceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(PriceType) },
    { no: 3, name: "info", kind: "message", T: price_info, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreatePriceRequest {
    return new CreatePriceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreatePriceRequest {
    return new CreatePriceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreatePriceRequest {
    return new CreatePriceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreatePriceRequest | PlainMessage<CreatePriceRequest> | undefined, b: CreatePriceRequest | PlainMessage<CreatePriceRequest> | undefined): boolean {
    return proto3.util.equals(CreatePriceRequest, a, b);
  }
}

/**
 * The Update price Request used to update a price for an account
 * to be monetized. The caller must provide proof of ownership of the platform
 * uid by signing a message with the private key associated with the platform
 * uid and attaching the signature to the request as a `signature` field in the
 * request header.
 *
 * @generated from message platform.v1.UpdatePriceRequest
 */
export class UpdatePriceRequest extends Message<UpdatePriceRequest> {
  /**
   * Required. The id of the price to be updated.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Required. The price description.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The type of the price. The type of the price will determine how the price
   * is charged to the customers.
   *
   * @generated from field: platform.v1.PriceType type = 3;
   */
  type = PriceType.PRICE_TYPE_UNKNOWN;

  /**
   * The price information that will be used to charge the customers. It the
   * user wants to update the price information, they can do so by providing a
   * new list of price information, even if only one item inside the list has
   * changed from previous updates, the user must provide the entire list to be
   * used.
   *
   * @generated from field: repeated platform.v1.price_info info = 4;
   */
  info: price_info[] = [];

  constructor(data?: PartialMessage<UpdatePriceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.UpdatePriceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(PriceType) },
    { no: 4, name: "info", kind: "message", T: price_info, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdatePriceRequest {
    return new UpdatePriceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdatePriceRequest {
    return new UpdatePriceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdatePriceRequest {
    return new UpdatePriceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdatePriceRequest | PlainMessage<UpdatePriceRequest> | undefined, b: UpdatePriceRequest | PlainMessage<UpdatePriceRequest> | undefined): boolean {
    return proto3.util.equals(UpdatePriceRequest, a, b);
  }
}

/**
 * The Delete price Request used to delete a price for an account.
 * The caller must provide proof of ownership of the platform
 * uid by signing a message with the private key associated with the platform
 * uid and attaching the signature to the request as a `signature` field in the
 * request header.
 *
 * @generated from message platform.v1.DeletePriceRequest
 */
export class DeletePriceRequest extends Message<DeletePriceRequest> {
  /**
   * Required. The id of the price to be deleted.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeletePriceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.DeletePriceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePriceRequest {
    return new DeletePriceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePriceRequest {
    return new DeletePriceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePriceRequest {
    return new DeletePriceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeletePriceRequest | PlainMessage<DeletePriceRequest> | undefined, b: DeletePriceRequest | PlainMessage<DeletePriceRequest> | undefined): boolean {
    return proto3.util.equals(DeletePriceRequest, a, b);
  }
}

/**
 * The List prices Request used to list all prices for an account
 * The caller must provide proof of ownership of the platform
 * uid by signing a message with the private key associated with the platform
 * uid and attaching the signature to the request as a `signature` field in the
 * request header.
 *
 * @generated from message platform.v1.ListPricesRequest
 */
export class ListPricesRequest extends Message<ListPricesRequest> {
  /**
   * Optional. The size of the page. The default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. The page token for requesting next pages.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListPricesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.ListPricesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPricesRequest {
    return new ListPricesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPricesRequest {
    return new ListPricesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPricesRequest {
    return new ListPricesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListPricesRequest | PlainMessage<ListPricesRequest> | undefined, b: ListPricesRequest | PlainMessage<ListPricesRequest> | undefined): boolean {
    return proto3.util.equals(ListPricesRequest, a, b);
  }
}

/**
 * The List prices Response used to list all prices for the platform.
 *
 * @generated from message platform.v1.ListPricessResponse
 */
export class ListPricessResponse extends Message<ListPricessResponse> {
  /**
   * The list of prices for the platform.
   *
   * @generated from field: repeated platform.v1.Price prices = 1;
   */
  prices: Price[] = [];

  /**
   * The token to be used for requesting the next page of prices.
   * If this field is empty, there are no more pages to be requested.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListPricessResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.ListPricessResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "prices", kind: "message", T: Price, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPricessResponse {
    return new ListPricessResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPricessResponse {
    return new ListPricessResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPricessResponse {
    return new ListPricessResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListPricessResponse | PlainMessage<ListPricessResponse> | undefined, b: ListPricessResponse | PlainMessage<ListPricessResponse> | undefined): boolean {
    return proto3.util.equals(ListPricessResponse, a, b);
  }
}

/**
 * Price represents a price that can be attached to a product.
 * A price can be an open price, a fixed price, or a subscription price.
 * It can be used to charge customers for a product or service.
 *
 * @generated from message platform.v1.Price
 */
export class Price extends Message<Price> {
  /**
   * The unique identifyer of the price
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * A brief description of the price's purpose or what it represents.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The type of the price. The type of the price will determine how the price
   * is charged to the customers.
   *
   * @generated from field: platform.v1.PriceType type = 3;
   */
  type = PriceType.PRICE_TYPE_UNKNOWN;

  /**
   * The price information that will be used to charge the customers. A price
   * can have multiple price information localized for different currencies or
   * different amounts. For example, a price can have a fixed price in USD and a
   * fixed price in EUR. The price information will be used to charge the
   * customers based on their location or the currency they choose to pay with.
   * If the price is an open price, the amount will be 0 but the currency will
   * still be set. If there is only one price information, and the customer
   * wants to pay in a different currency, the platform will convert the amount
   * to the customer's currency using the current exchange rate. If the price
   * has multiple pricing information, the platform will use the first one that
   * matches the customer's currency.
   *
   * @generated from field: repeated platform.v1.price_info info = 4;
   */
  info: price_info[] = [];

  constructor(data?: PartialMessage<Price>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.Price";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(PriceType) },
    { no: 4, name: "info", kind: "message", T: price_info, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Price {
    return new Price().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Price {
    return new Price().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Price {
    return new Price().fromJsonString(jsonString, options);
  }

  static equals(a: Price | PlainMessage<Price> | undefined, b: Price | PlainMessage<Price> | undefined): boolean {
    return proto3.util.equals(Price, a, b);
  }
}

/**
 * price information that will be used to charge the customers.
 * The total amount charged to the customers will be amount, but the net amount
 * received by the account will be amount - platform_fee - payment processing
 * fees.
 *
 * @generated from message platform.v1.price_info
 */
export class price_info extends Message<price_info> {
  /**
   * The amount to charge to the customers in the smallest currency unit.
   * For example, if the price is $10.00, the amount will be
   * 1000 for USD (since USD has 2 decimal places). In the case of JPY, since
   * JPY has no decimal places, the amount will be 10 for ¥10.
   * Omitted for open prices, where the customer can choose how much to pay.
   *
   * @generated from field: uint64 amount = 1;
   */
  amount = protoInt64.zero;

  /**
   * The currency the price is denominated in. This currency field is a
   * three-letter ISO 4217 currency code, such as "USD" or "EUR". The currency
   * could be different from the accounts default currency (based on the country
   * of the account). Omitted for open prices, where the currency will be set
   * based on the customer's location.
   *
   * @generated from field: string currency = 2;
   */
  currency = "";

  constructor(data?: PartialMessage<price_info>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.price_info";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): price_info {
    return new price_info().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): price_info {
    return new price_info().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): price_info {
    return new price_info().fromJsonString(jsonString, options);
  }

  static equals(a: price_info | PlainMessage<price_info> | undefined, b: price_info | PlainMessage<price_info> | undefined): boolean {
    return proto3.util.equals(price_info, a, b);
  }
}

