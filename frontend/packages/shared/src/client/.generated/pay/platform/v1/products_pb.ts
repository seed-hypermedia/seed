// @generated by protoc-gen-es v1.4.1 with parameter "target=ts,import_extension=none"
// @generated from file pay/platform/v1/products.proto (package platform.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Price } from "./prices_pb";

/**
 * @generated from enum platform.v1.ProductType
 */
export enum ProductType {
  /**
   * The product type is unknown.
   *
   * @generated from enum value: PRODUCT_TYPE_UNKNOWN = 0;
   */
  PRODUCT_TYPE_UNKNOWN = 0,

  /**
   * The product is a subscription product. This product can be used to charge
   * customers on a recurring basis. Invoices will be generated for this
   * product.
   *
   * @generated from enum value: SUBSCRIPTION = 1;
   */
  SUBSCRIPTION = 1,

  /**
   * The product is a one-time purchase product. This product can be used to
   * charge customers for a one-time purchase. This can be used in paywalls, for
   * example. Invoices will be generated for this product.
   *
   * @generated from enum value: ONE_TIME_PURCHASE = 2;
   */
  ONE_TIME_PURCHASE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ProductType)
proto3.util.setEnumType(ProductType, "platform.v1.ProductType", [
  { no: 0, name: "PRODUCT_TYPE_UNKNOWN" },
  { no: 1, name: "SUBSCRIPTION" },
  { no: 2, name: "ONE_TIME_PURCHASE" },
]);

/**
 * The Create product Request used to create a new product for a platform
 * to be monetized. The caller must provide proof of ownership of the platform
 * uid by signing a message with the private key associated with the platform
 * uid and attaching the signature to the request as a `signature` field in the
 * request header.
 *
 * @generated from message platform.v1.CreateProductRequest
 */
export class CreateProductRequest extends Message<CreateProductRequest> {
  /**
   * Required. The name of the product.
   * This is the name that will be displayed to the customers. Must be 22
   * Characters long at most
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Required. A brief description of the product. This will help
   * customers understand what the product is about and what it offers.
   * This is the description that will be displayed to the customers.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Required. The URL that the user will try to monetize. We will check
   * <url>/hm/api/config and make sure the `registeredAccountUid` seen
   * matches the provided uid. If the URL is a free url, it should be in the
   * form of <domain>/hm/<uid> in which case we will only check that URL exists.
   * If the user upgrades and gets a custom domain later, they can update the
   * account with the new URL using CreateAccountSession or CreateAccountLink.
   *
   * @generated from field: string url = 3;
   */
  url = "";

  /**
   * Required. The price id to be associated with the product. The price must
   * exist Before creating the product. The user will later be able to update
   * the price using the prices service. A price can be attached to multiple
   * products. This is the price that will be charged to the customers when they
   * purchase the product. It can be an open price, a fixed price, or a
   * subscription price.
   *
   * @generated from field: string price_id = 4;
   */
  priceId = "";

  /**
   * Optional. The statement description of the product.
   * This is an arbitrary string to be displayed on your customer's credit card
   * or bank statement. While most banks display this information consistently,
   * some may display it incorrectly or not at all. This may be up to 22
   * characters. The statement description may not include `<`, `>`, `\`, `"`,
   * `'` characters, and will appear on your customer's statement in capital
   * letters. Non-ASCII characters are automatically stripped. If not set, the
   * name of the product will be used as the statement description.
   *
   * @generated from field: string statement_description = 5;
   */
  statementDescription = "";

  /**
   * Optional. The image URL of the product.
   * This is the image that will be displayed to the customers.
   *
   * @generated from field: string image_url = 6;
   */
  imageUrl = "";

  constructor(data?: PartialMessage<CreateProductRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.CreateProductRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "price_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "statement_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "image_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateProductRequest {
    return new CreateProductRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateProductRequest {
    return new CreateProductRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateProductRequest {
    return new CreateProductRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateProductRequest | PlainMessage<CreateProductRequest> | undefined, b: CreateProductRequest | PlainMessage<CreateProductRequest> | undefined): boolean {
    return proto3.util.equals(CreateProductRequest, a, b);
  }
}

/**
 * Product represents a product that can be monetized by the user.
 *
 * @generated from message platform.v1.Product
 */
export class Product extends Message<Product> {
  /**
   * The unique identifyer of the product
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The URL of the product. This is the URL that the user will try to monetize.
   * It must be a subdomain, a custom domain. or a free hyper.media url
   *
   * @generated from field: string url = 2;
   */
  url = "";

  /**
   * The type of the product.
   *
   * @generated from field: platform.v1.ProductType type = 3;
   */
  type = ProductType.PRODUCT_TYPE_UNKNOWN;

  /**
   * The price of the product.
   *
   * @generated from field: platform.v1.Price price = 4;
   */
  price?: Price;

  constructor(data?: PartialMessage<Product>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.Product";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(ProductType) },
    { no: 4, name: "price", kind: "message", T: Price },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Product {
    return new Product().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Product {
    return new Product().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Product {
    return new Product().fromJsonString(jsonString, options);
  }

  static equals(a: Product | PlainMessage<Product> | undefined, b: Product | PlainMessage<Product> | undefined): boolean {
    return proto3.util.equals(Product, a, b);
  }
}

/**
 * The request to update an existing product for the connected account.
 * Only the fields that are set will be updated. If a field is not set, it will
 * not be updated. The product must exist before updating it.
 * The caller must provide proof of ownership of the platform
 * uid by signing a message with the private key associated with the platform
 * uid and attaching the signature to the request as a `signature` field in the
 * request header.
 *
 * @generated from message platform.v1.UpdateProductRequest
 */
export class UpdateProductRequest extends Message<UpdateProductRequest> {
  /**
   * Required. The id of the product to update.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. The new name of the product.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Optional. The new URL that the user will try to monetize. Checks will be
   * made the same as in CreateProductRequest.
   *
   * @generated from field: string url = 3;
   */
  url = "";

  /**
   * Required. The price id to be associated with the product. The price must
   * exist Before creating the product. The user will later be able to update
   * the price using the prices service. A price can be attached to multiple
   * products.
   *
   * @generated from field: string price_id = 4;
   */
  priceId = "";

  /**
   * Optional. The description of the product.
   * This is the description that will be displayed to the customers.
   *
   * @generated from field: string description = 5;
   */
  description = "";

  /**
   * Optional. The image URL of the product.
   * This is the image that will be displayed to the customers.
   *
   * @generated from field: string image_url = 6;
   */
  imageUrl = "";

  constructor(data?: PartialMessage<UpdateProductRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.UpdateProductRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "price_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "image_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateProductRequest {
    return new UpdateProductRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateProductRequest {
    return new UpdateProductRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateProductRequest {
    return new UpdateProductRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateProductRequest | PlainMessage<UpdateProductRequest> | undefined, b: UpdateProductRequest | PlainMessage<UpdateProductRequest> | undefined): boolean {
    return proto3.util.equals(UpdateProductRequest, a, b);
  }
}

/**
 * The request to delete a product for the connected account.
 * The caller must provide proof of ownership of the platform
 * uid by signing a message with the private key associated with the platform
 * uid and attaching the signature to the request as a `signature` field in the
 * request header.
 *
 * @generated from message platform.v1.DeleteProductRequest
 */
export class DeleteProductRequest extends Message<DeleteProductRequest> {
  /**
   * Required. The id of the product to delete.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteProductRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.DeleteProductRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteProductRequest {
    return new DeleteProductRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteProductRequest {
    return new DeleteProductRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteProductRequest {
    return new DeleteProductRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteProductRequest | PlainMessage<DeleteProductRequest> | undefined, b: DeleteProductRequest | PlainMessage<DeleteProductRequest> | undefined): boolean {
    return proto3.util.equals(DeleteProductRequest, a, b);
  }
}

/**
 * The request to list all products for the connected account.
 * The caller must provide proof of ownership of the platform
 * uid by signing a message with the private key associated with the platform
 * uid and attaching the signature to the request as a `signature` field in the
 * request header.
 *
 * @generated from message platform.v1.ListProductRequest
 */
export class ListProductRequest extends Message<ListProductRequest> {
  /**
   * Optional. The size of the page. The default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. The page token for requesting next pages.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListProductRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.ListProductRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListProductRequest {
    return new ListProductRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListProductRequest {
    return new ListProductRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListProductRequest {
    return new ListProductRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListProductRequest | PlainMessage<ListProductRequest> | undefined, b: ListProductRequest | PlainMessage<ListProductRequest> | undefined): boolean {
    return proto3.util.equals(ListProductRequest, a, b);
  }
}

/**
 * The response with the list of products for the connected account.
 *
 * @generated from message platform.v1.ListProductsResponse
 */
export class ListProductsResponse extends Message<ListProductsResponse> {
  /**
   * The list of the products.
   *
   * @generated from field: repeated platform.v1.Product products = 1;
   */
  products: Product[] = [];

  /**
   * The token to request the next page.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListProductsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "platform.v1.ListProductsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "products", kind: "message", T: Product, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListProductsResponse {
    return new ListProductsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListProductsResponse {
    return new ListProductsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListProductsResponse {
    return new ListProductsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListProductsResponse | PlainMessage<ListProductsResponse> | undefined, b: ListProductsResponse | PlainMessage<ListProductsResponse> | undefined): boolean {
    return proto3.util.equals(ListProductsResponse, a, b);
  }
}

