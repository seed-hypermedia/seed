// @generated by protoc-gen-es v1.4.1 with parameter "target=ts,import_extension=none"
// @generated from file payments/v1alpha/invoices.proto (package com.seed.payments.v1alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Response of the Create invoice.
 *
 * @generated from message com.seed.payments.v1alpha.InvoiceResponse
 */
export class InvoiceResponse extends Message<InvoiceResponse> {
  /**
   * String representation of a bolt11 invoice payment request. 
   *
   * @generated from field: string payreq = 1;
   */
  payreq = "";

  /**
   * Payment Hash of the invoice.
   *
   * @generated from field: string payment_hash = 2;
   */
  paymentHash = "";

  constructor(data?: PartialMessage<InvoiceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.InvoiceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payreq", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payment_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InvoiceResponse {
    return new InvoiceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InvoiceResponse {
    return new InvoiceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InvoiceResponse {
    return new InvoiceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InvoiceResponse | PlainMessage<InvoiceResponse> | undefined, b: InvoiceResponse | PlainMessage<InvoiceResponse> | undefined): boolean {
    return proto3.util.equals(InvoiceResponse, a, b);
  }
}

/**
 * @generated from message com.seed.payments.v1alpha.DecodeInvoiceRequest
 */
export class DecodeInvoiceRequest extends Message<DecodeInvoiceRequest> {
  /**
   * String representation of a bolt11 invoice payment request. 
   *
   * @generated from field: string payreq = 1;
   */
  payreq = "";

  constructor(data?: PartialMessage<DecodeInvoiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.DecodeInvoiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payreq", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DecodeInvoiceRequest {
    return new DecodeInvoiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DecodeInvoiceRequest {
    return new DecodeInvoiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DecodeInvoiceRequest {
    return new DecodeInvoiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DecodeInvoiceRequest | PlainMessage<DecodeInvoiceRequest> | undefined, b: DecodeInvoiceRequest | PlainMessage<DecodeInvoiceRequest> | undefined): boolean {
    return proto3.util.equals(DecodeInvoiceRequest, a, b);
  }
}

/**
 * The request to create a local invoice. Used to be paid.
 *
 * @generated from message com.seed.payments.v1alpha.CreateInvoiceRequest
 */
export class CreateInvoiceRequest extends Message<CreateInvoiceRequest> {
  /**
   * Optional. The account we are creating the invoice from. The default wallet
   * from that account will be used to issue the invoice. If the user wants to 
   * select an espedific wallet, then account must be blank and the user must 
   * provide a wallet id.
   *
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * Optional. In case account is not provided, the especific walletID
   * to issue an invoice from. 
   *
   * @generated from field: string id = 2;
   */
  id = "";

  /**
   * Required. The amount in satoshis we want the invoice.
   *
   * @generated from field: int64 amount = 3;
   */
  amount = protoInt64.zero;

  /**
   * Optional. Description we want to include in the invoice. 
   *
   * @generated from field: string memo = 4;
   */
  memo = "";

  constructor(data?: PartialMessage<CreateInvoiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.CreateInvoiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "memo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInvoiceRequest {
    return new CreateInvoiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInvoiceRequest {
    return new CreateInvoiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInvoiceRequest {
    return new CreateInvoiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInvoiceRequest | PlainMessage<CreateInvoiceRequest> | undefined, b: CreateInvoiceRequest | PlainMessage<CreateInvoiceRequest> | undefined): boolean {
    return proto3.util.equals(CreateInvoiceRequest, a, b);
  }
}

/**
 * To pay an invoice
 *
 * @generated from message com.seed.payments.v1alpha.PayInvoiceRequest
 */
export class PayInvoiceRequest extends Message<PayInvoiceRequest> {
  /**
   * Required. The payment request in plaintext representing the bolt-11 invoice to be paid
   *
   * @generated from field: string payreq = 1;
   */
  payreq = "";

  /**
   * Optional. The account used to pay this invoice. The default wallet of this account will
   * be used. If not provided, then an specific wallet ID must be provided
   *
   * @generated from field: string account = 2;
   */
  account = "";

  /**
   * Optional. Wallet id to pay the invoice with
   *
   * @generated from field: string id = 3;
   */
  id = "";

  /**
   * Optional. Amount in satoshis to pay. This should match the amount in the invoice. 
   * For zero-amount invoices, the user can put whatever amount it wants.  
   *
   * @generated from field: int64 amount = 4;
   */
  amount = protoInt64.zero;

  constructor(data?: PartialMessage<PayInvoiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.PayInvoiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payreq", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "amount", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayInvoiceRequest {
    return new PayInvoiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayInvoiceRequest {
    return new PayInvoiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayInvoiceRequest {
    return new PayInvoiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PayInvoiceRequest | PlainMessage<PayInvoiceRequest> | undefined, b: PayInvoiceRequest | PlainMessage<PayInvoiceRequest> | undefined): boolean {
    return proto3.util.equals(PayInvoiceRequest, a, b);
  }
}

/**
 * Request to pay.
 *
 * @generated from message com.seed.payments.v1alpha.RequestLud6InvoiceRequest
 */
export class RequestLud6InvoiceRequest extends Message<RequestLud6InvoiceRequest> {
  /**
   * Required. URL associated with the ln server.
   *
   * @generated from field: string URL = 1;
   */
  URL = "";

  /**
   * Required. User to pay.
   *
   * @generated from field: string user = 2;
   */
  user = "";

  /**
   * Required. Amount in satohis.
   *
   * @generated from field: int64 amount = 3;
   */
  amount = protoInt64.zero;

  /**
   * Optional. String to be attached in the invoice.
   *
   * @generated from field: string memo = 4;
   */
  memo = "";

  constructor(data?: PartialMessage<RequestLud6InvoiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.RequestLud6InvoiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "URL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "memo", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestLud6InvoiceRequest {
    return new RequestLud6InvoiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestLud6InvoiceRequest {
    return new RequestLud6InvoiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestLud6InvoiceRequest {
    return new RequestLud6InvoiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RequestLud6InvoiceRequest | PlainMessage<RequestLud6InvoiceRequest> | undefined, b: RequestLud6InvoiceRequest | PlainMessage<RequestLud6InvoiceRequest> | undefined): boolean {
    return proto3.util.equals(RequestLud6InvoiceRequest, a, b);
  }
}

/**
 * Get the LNAddress of a wallet.
 *
 * @generated from message com.seed.payments.v1alpha.GetLnAddressRequest
 */
export class GetLnAddressRequest extends Message<GetLnAddressRequest> {
  /**
   * Required. The wallet ID we want to know the lnaddress from.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetLnAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.GetLnAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLnAddressRequest {
    return new GetLnAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLnAddressRequest {
    return new GetLnAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLnAddressRequest {
    return new GetLnAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLnAddressRequest | PlainMessage<GetLnAddressRequest> | undefined, b: GetLnAddressRequest | PlainMessage<GetLnAddressRequest> | undefined): boolean {
    return proto3.util.equals(GetLnAddressRequest, a, b);
  }
}

/**
 * The LNAddress of a wallet.
 *
 * @generated from message com.seed.payments.v1alpha.LNAddress
 */
export class LNAddress extends Message<LNAddress> {
  /**
   * Required. The account we want to know the lnaddress from.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<LNAddress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.LNAddress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LNAddress {
    return new LNAddress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LNAddress {
    return new LNAddress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LNAddress {
    return new LNAddress().fromJsonString(jsonString, options);
  }

  static equals(a: LNAddress | PlainMessage<LNAddress> | undefined, b: LNAddress | PlainMessage<LNAddress> | undefined): boolean {
    return proto3.util.equals(LNAddress, a, b);
  }
}

/**
 * Changes the lnaddress associated with a wallet. 
 *
 * @generated from message com.seed.payments.v1alpha.UpdateLNAddressRequest
 */
export class UpdateLNAddressRequest extends Message<UpdateLNAddressRequest> {
  /**
   * Required. The wallet we want to change its lnaddress. Not all wallets
   * support lnaddresses
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Required. The nickname of the new lnadress. The resultin lnaddress would be
   * <new_nickname>@<lnurl>
   *
   * @generated from field: string nickname = 2;
   */
  nickname = "";

  constructor(data?: PartialMessage<UpdateLNAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.UpdateLNAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nickname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateLNAddressRequest {
    return new UpdateLNAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateLNAddressRequest {
    return new UpdateLNAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateLNAddressRequest {
    return new UpdateLNAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateLNAddressRequest | PlainMessage<UpdateLNAddressRequest> | undefined, b: UpdateLNAddressRequest | PlainMessage<UpdateLNAddressRequest> | undefined): boolean {
    return proto3.util.equals(UpdateLNAddressRequest, a, b);
  }
}

/**
 * List all invoices that has been paid with a wallet 
 *
 * @generated from message com.seed.payments.v1alpha.ListInvoicesRequest
 */
export class ListInvoicesRequest extends Message<ListInvoicesRequest> {
  /**
   * Required. The wallet id from where we want the list of paid invoices
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<ListInvoicesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.ListInvoicesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInvoicesRequest {
    return new ListInvoicesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInvoicesRequest {
    return new ListInvoicesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInvoicesRequest {
    return new ListInvoicesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListInvoicesRequest | PlainMessage<ListInvoicesRequest> | undefined, b: ListInvoicesRequest | PlainMessage<ListInvoicesRequest> | undefined): boolean {
    return proto3.util.equals(ListInvoicesRequest, a, b);
  }
}

/**
 * Bolt11 Invoice
 *
 * @generated from message com.seed.payments.v1alpha.Invoice
 */
export class Invoice extends Message<Invoice> {
  /**
   * The hash of the invoice. Unique identifier of the invoice
   *
   * @generated from field: string payment_hash = 1;
   */
  paymentHash = "";

  /**
   * The string representation of the invoice
   *
   * @generated from field: string payment_request = 2;
   */
  paymentRequest = "";

  /**
   * The description/memo/purpose of the invoice
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * The description hash
   *
   * @generated from field: string description_hash = 4;
   */
  descriptionHash = "";

  /**
   * The preimage revealed upon settlement. Proof of payment.
   *
   * @generated from field: string payment_preimage = 5;
   */
  paymentPreimage = "";

  /**
   * The destination node of the payment.
   *
   * @generated from field: string destination = 6;
   */
  destination = "";

  /**
   * The amount in satoshis of the payment.
   *
   * @generated from field: int64 amount = 7;
   */
  amount = protoInt64.zero;

  /**
   * The fees paid in satoshis.
   *
   * @generated from field: int64 fee = 8;
   */
  fee = protoInt64.zero;

  /**
   * The satus of the invoice.
   *
   * @generated from field: string status = 9;
   */
  status = "";

  /**
   * The type of invoice.
   *
   * @generated from field: string type = 10;
   */
  type = "";

  /**
   * Error message (if any) of the transaction.
   *
   * @generated from field: string error_message = 11;
   */
  errorMessage = "";

  /**
   * When the invoice was settled
   *
   * @generated from field: string settled_at = 12;
   */
  settledAt = "";

  /**
   * When the invoice expires (if unpaid).
   *
   * @generated from field: string expires_at = 13;
   */
  expiresAt = "";

  /**
   * Whether or not the invoice has been paid.
   *
   * @generated from field: bool is_paid = 14;
   */
  isPaid = false;

  /**
   * Whether or not this is a keysed payment.
   *
   * @generated from field: bool keysend = 15;
   */
  keysend = false;

  constructor(data?: PartialMessage<Invoice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.Invoice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payment_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payment_request", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "description_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "payment_preimage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "amount", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "fee", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "settled_at", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "expires_at", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "is_paid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "keysend", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Invoice {
    return new Invoice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Invoice {
    return new Invoice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Invoice {
    return new Invoice().fromJsonString(jsonString, options);
  }

  static equals(a: Invoice | PlainMessage<Invoice> | undefined, b: Invoice | PlainMessage<Invoice> | undefined): boolean {
    return proto3.util.equals(Invoice, a, b);
  }
}

/**
 * List all invoices that has been paid with a wallet 
 *
 * @generated from message com.seed.payments.v1alpha.ListInvoicesResponse
 */
export class ListInvoicesResponse extends Message<ListInvoicesResponse> {
  /**
   * Required. The wallet id from where we want the list of paid invoices
   *
   * @generated from field: repeated com.seed.payments.v1alpha.Invoice invoices = 1;
   */
  invoices: Invoice[] = [];

  constructor(data?: PartialMessage<ListInvoicesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.payments.v1alpha.ListInvoicesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "invoices", kind: "message", T: Invoice, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInvoicesResponse {
    return new ListInvoicesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInvoicesResponse {
    return new ListInvoicesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInvoicesResponse {
    return new ListInvoicesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListInvoicesResponse | PlainMessage<ListInvoicesResponse> | undefined, b: ListInvoicesResponse | PlainMessage<ListInvoicesResponse> | undefined): boolean {
    return proto3.util.equals(ListInvoicesResponse, a, b);
  }
}

