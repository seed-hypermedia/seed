// @generated by protoc-gen-es v1.4.1 with parameter "target=ts,import_extension=none"
// @generated from file p2p/v1alpha/syncing.proto (package com.seed.p2p.v1alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message com.seed.p2p.v1alpha.AnnounceBlobsRequest
 */
export class AnnounceBlobsRequest extends Message<AnnounceBlobsRequest> {
  /**
   * Required. Cids to announce.
   *
   * @generated from field: repeated string cids = 1;
   */
  cids: string[] = [];

  constructor(data?: PartialMessage<AnnounceBlobsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.p2p.v1alpha.AnnounceBlobsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnounceBlobsRequest {
    return new AnnounceBlobsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnounceBlobsRequest {
    return new AnnounceBlobsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnounceBlobsRequest {
    return new AnnounceBlobsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnnounceBlobsRequest | PlainMessage<AnnounceBlobsRequest> | undefined, b: AnnounceBlobsRequest | PlainMessage<AnnounceBlobsRequest> | undefined): boolean {
    return proto3.util.equals(AnnounceBlobsRequest, a, b);
  }
}

/**
 * @generated from message com.seed.p2p.v1alpha.AnnounceBlobsProgress
 */
export class AnnounceBlobsProgress extends Message<AnnounceBlobsProgress> {
  /**
   * Total number of blobs announced by the requester.
   *
   * @generated from field: int32 blobs_announced = 1;
   */
  blobsAnnounced = 0;

  /**
   * Total number of blobs already known by the server.
   *
   * @generated from field: int32 blobs_known = 2;
   */
  blobsKnown = 0;

  /**
   * Total number of blobs wanted by the server.
   * I.e. announced - known.
   *
   * @generated from field: int32 blobs_wanted = 3;
   */
  blobsWanted = 0;

  /**
   * Total number of wanted blobs already processed.
   * This number grows as progress advances,
   * and when it becomes equal to blobs_wanted â€” we're done syncing.
   *
   * @generated from field: int32 blobs_processed = 4;
   */
  blobsProcessed = 0;

  /**
   * Total number of wanted blobs that we failed to process.
   * They're also counted as blobs_processed.
   *
   * @generated from field: int32 blobs_failed = 5;
   */
  blobsFailed = 0;

  constructor(data?: PartialMessage<AnnounceBlobsProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.p2p.v1alpha.AnnounceBlobsProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blobs_announced", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "blobs_known", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "blobs_wanted", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "blobs_processed", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "blobs_failed", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnounceBlobsProgress {
    return new AnnounceBlobsProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnounceBlobsProgress {
    return new AnnounceBlobsProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnounceBlobsProgress {
    return new AnnounceBlobsProgress().fromJsonString(jsonString, options);
  }

  static equals(a: AnnounceBlobsProgress | PlainMessage<AnnounceBlobsProgress> | undefined, b: AnnounceBlobsProgress | PlainMessage<AnnounceBlobsProgress> | undefined): boolean {
    return proto3.util.equals(AnnounceBlobsProgress, a, b);
  }
}

/**
 * @generated from message com.seed.p2p.v1alpha.ReconcileBlobsRequest
 */
export class ReconcileBlobsRequest extends Message<ReconcileBlobsRequest> {
  /**
   * Optional. Filters to narrow down the blobs to reconcile.
   * If not set, all public blobs are reconciled.
   *
   * @generated from field: repeated com.seed.p2p.v1alpha.Filter filters = 1;
   */
  filters: Filter[] = [];

  /**
   * Optional. The ranges for the sender's part of the set.
   *
   * @generated from field: repeated com.seed.p2p.v1alpha.SetReconciliationRange ranges = 2;
   */
  ranges: SetReconciliationRange[] = [];

  constructor(data?: PartialMessage<ReconcileBlobsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.p2p.v1alpha.ReconcileBlobsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filters", kind: "message", T: Filter, repeated: true },
    { no: 2, name: "ranges", kind: "message", T: SetReconciliationRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReconcileBlobsRequest {
    return new ReconcileBlobsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReconcileBlobsRequest {
    return new ReconcileBlobsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReconcileBlobsRequest {
    return new ReconcileBlobsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReconcileBlobsRequest | PlainMessage<ReconcileBlobsRequest> | undefined, b: ReconcileBlobsRequest | PlainMessage<ReconcileBlobsRequest> | undefined): boolean {
    return proto3.util.equals(ReconcileBlobsRequest, a, b);
  }
}

/**
 * @generated from message com.seed.p2p.v1alpha.ReconcileBlobsResponse
 */
export class ReconcileBlobsResponse extends Message<ReconcileBlobsResponse> {
  /**
   * @generated from field: repeated com.seed.p2p.v1alpha.SetReconciliationRange ranges = 1;
   */
  ranges: SetReconciliationRange[] = [];

  constructor(data?: PartialMessage<ReconcileBlobsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.p2p.v1alpha.ReconcileBlobsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ranges", kind: "message", T: SetReconciliationRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReconcileBlobsResponse {
    return new ReconcileBlobsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReconcileBlobsResponse {
    return new ReconcileBlobsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReconcileBlobsResponse {
    return new ReconcileBlobsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReconcileBlobsResponse | PlainMessage<ReconcileBlobsResponse> | undefined, b: ReconcileBlobsResponse | PlainMessage<ReconcileBlobsResponse> | undefined): boolean {
    return proto3.util.equals(ReconcileBlobsResponse, a, b);
  }
}

/**
 * Filter describes which blobs to select for reconciliation.
 *
 * @generated from message com.seed.p2p.v1alpha.Filter
 */
export class Filter extends Message<Filter> {
  /**
   * Selects only blobs related to the given resource.
   *
   * @generated from field: string resource = 1;
   */
  resource = "";

  /**
   * If its recursive, then all the documents below the path are
   * will also pass the filter.
   *
   * @generated from field: bool recursive = 2;
   */
  recursive = false;

  constructor(data?: PartialMessage<Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.p2p.v1alpha.Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "recursive", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
    return new Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean {
    return proto3.util.equals(Filter, a, b);
  }
}

/**
 * @generated from message com.seed.p2p.v1alpha.SetReconciliationRange
 */
export class SetReconciliationRange extends Message<SetReconciliationRange> {
  /**
   * Mode for the range.
   *
   * @generated from field: com.seed.p2p.v1alpha.SetReconciliationRange.Mode mode = 1;
   */
  mode = SetReconciliationRange_Mode.SKIP;

  /**
   * Timestamp of the upper bound of the range.
   *
   * @generated from field: int64 bound_timestamp = 2;
   */
  boundTimestamp = protoInt64.zero;

  /**
   * Value of the upper bound of the range.
   *
   * @generated from field: bytes bound_value = 3;
   */
  boundValue = new Uint8Array(0);

  /**
   * Only for LIST mode. List of values in the range.
   *
   * @generated from field: repeated bytes values = 4;
   */
  values: Uint8Array[] = [];

  /**
   * Only for the FINGERPRINT mode. Fingerprint of the range.
   *
   * @generated from field: bytes fingerprint = 5;
   */
  fingerprint = new Uint8Array(0);

  constructor(data?: PartialMessage<SetReconciliationRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.seed.p2p.v1alpha.SetReconciliationRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mode", kind: "enum", T: proto3.getEnumType(SetReconciliationRange_Mode) },
    { no: 2, name: "bound_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "bound_value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "values", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 5, name: "fingerprint", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetReconciliationRange {
    return new SetReconciliationRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetReconciliationRange {
    return new SetReconciliationRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetReconciliationRange {
    return new SetReconciliationRange().fromJsonString(jsonString, options);
  }

  static equals(a: SetReconciliationRange | PlainMessage<SetReconciliationRange> | undefined, b: SetReconciliationRange | PlainMessage<SetReconciliationRange> | undefined): boolean {
    return proto3.util.equals(SetReconciliationRange, a, b);
  }
}

/**
 * @generated from enum com.seed.p2p.v1alpha.SetReconciliationRange.Mode
 */
export enum SetReconciliationRange_Mode {
  /**
   * @generated from enum value: SKIP = 0;
   */
  SKIP = 0,

  /**
   * @generated from enum value: FINGERPRINT = 1;
   */
  FINGERPRINT = 1,

  /**
   * @generated from enum value: LIST = 2;
   */
  LIST = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SetReconciliationRange_Mode)
proto3.util.setEnumType(SetReconciliationRange_Mode, "com.seed.p2p.v1alpha.SetReconciliationRange.Mode", [
  { no: 0, name: "SKIP" },
  { no: 1, name: "FINGERPRINT" },
  { no: 2, name: "LIST" },
]);

