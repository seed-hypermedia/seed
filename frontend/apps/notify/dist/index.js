import Database from 'better-sqlite3'
import 'crypto'
import {join} from 'path'
import {
  Message,
  proto3,
  Timestamp,
  protoInt64,
  Struct,
  Empty,
  MethodKind,
  toPlainMessage,
} from '@bufbuild/protobuf'
import {decode} from '@ipld/dag-cbor'
import mjml2html from 'mjml'
import * as z from 'zod'
import {z as z$1} from 'zod'
import {createPromiseClient} from '@connectrpc/connect'
import {createGrpcWebTransport} from '@connectrpc/connect-node'
import dotenv from 'dotenv'
import nodemailer from 'nodemailer'
let db
async function initDatabase() {
  const dbFilePath = join(
    process.env.DATA_DIR || process.cwd(),
    'web-db.sqlite',
  )
  db = new Database(dbFilePath)
  let version = db.pragma('user_version', {simple: true})
  console.log('init db', dbFilePath, version)
  if (version === 0) {
    db.exec(`
      BEGIN;
      CREATE TABLE emails (
        email TEXT UNIQUE NOT NULL,
        adminToken TEXT NOT NULL,
        createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        isUnsubscribed BOOLEAN NOT NULL DEFAULT FALSE
      );
      CREATE TABLE accounts (
        id TEXT UNIQUE NOT NULL,
        email TEXT REFERENCES emails(email),
        createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        notifyAllMentions BOOLEAN NOT NULL DEFAULT FALSE,
        notifyAllReplies BOOLEAN NOT NULL DEFAULT FALSE
      );
      CREATE TABLE notifier_status (
        field TEXT UNIQUE NOT NULL,
        value TEXT NOT NULL
      );
      PRAGMA user_version = 1;
      COMMIT;
    `)
    version = 1
  }
  if (version === 1) {
    db.exec(`
      BEGIN;
      ALTER TABLE accounts ADD COLUMN notifyOwnedDocChange BOOLEAN NOT NULL DEFAULT FALSE;
      PRAGMA user_version = 2;
      COMMIT;
    `)
    version = 2
  }
  if (version === 2) {
    db.exec(`
      BEGIN;
      ALTER TABLE accounts ADD COLUMN notifySiteDiscussions BOOLEAN NOT NULL DEFAULT FALSE;
      PRAGMA user_version = 3;
      COMMIT;
    `)
    version = 3
  }
  if (version === 3) {
    db.exec(`
    BEGIN;
    ALTER TABLE accounts RENAME TO accounts_old;

    CREATE TABLE email_subscriptions (
      id TEXT NOT NULL,
      email TEXT NOT NULL REFERENCES emails(email),
      createdAt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
      notifyAllMentions BOOLEAN NOT NULL DEFAULT FALSE,
      notifyAllReplies BOOLEAN NOT NULL DEFAULT FALSE,
      notifyOwnedDocChange BOOLEAN NOT NULL DEFAULT FALSE,
      notifySiteDiscussions BOOLEAN NOT NULL DEFAULT FALSE,
      notifyAllComments BOOLEAN NOT NULL DEFAULT FALSE,
      PRIMARY KEY (id, email)
    ) WITHOUT ROWID;

    INSERT INTO email_subscriptions (
      id,
      email,
      createdAt,
      notifyAllMentions,
      notifyAllReplies,
      notifyOwnedDocChange,
      notifySiteDiscussions,
      notifyAllComments
    )
    SELECT
      id,
      email,
      createdAt,
      notifyAllMentions,
      notifyAllReplies,
      notifyOwnedDocChange,
      notifySiteDiscussions,
      FALSE
    FROM accounts_old;

    DROP TABLE accounts_old;

    PRAGMA user_version = 4;
    COMMIT;
  `)
    version = 4
  }
}
function getNotifierLastProcessedBlobCid() {
  const stmt = db.prepare(`
    SELECT value FROM notifier_status WHERE field = 'last_processed_blob_cid'
  `)
  const result = stmt.get()
  return result?.value
}
function setNotifierLastProcessedBlobCid(cid) {
  const stmt = db.prepare(`
    INSERT OR REPLACE INTO notifier_status (field, value) VALUES (?, ?)
  `)
  stmt.run('last_processed_blob_cid', cid)
}
function getAllEmails() {
  const stmt = db.prepare(`
    SELECT emails.*
    FROM emails 
  `)
  const emails = stmt.all()
  return emails.map((email) => {
    const subsStmt = db.prepare(`
    SELECT es.*
    FROM email_subscriptions es
    WHERE es.email = ?
  `)
    const subs = subsStmt.all(email.email)
    return {
      ...email,
      isUnsubscribed: Boolean(email.isUnsubscribed),
      subscriptions: subs.map((sub) => ({
        ...sub,
        notifyAllMentions: Boolean(sub.notifyAllMentions),
        notifyAllReplies: Boolean(sub.notifyAllReplies),
        notifyOwnedDocChange: Boolean(sub.notifyOwnedDocChange),
        notifySiteDiscussions: Boolean(sub.notifySiteDiscussions),
        notifyAllComments: Boolean(sub.notifyAllComments),
      })),
    }
  })
}
var commonjsGlobal =
  typeof globalThis !== 'undefined'
    ? globalThis
    : typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
    ? global
    : typeof self !== 'undefined'
    ? self
    : {}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default')
    ? x['default']
    : x
}
var jsxRuntime = {exports: {}}
var reactJsxRuntime_production_min = {}
var react = {exports: {}}
var react_production_min = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min
  hasRequiredReact_production_min = 1
  var l = Symbol.for('react.element'),
    n = Symbol.for('react.portal'),
    p = Symbol.for('react.fragment'),
    q = Symbol.for('react.strict_mode'),
    r = Symbol.for('react.profiler'),
    t = Symbol.for('react.provider'),
    u = Symbol.for('react.context'),
    v = Symbol.for('react.forward_ref'),
    w = Symbol.for('react.suspense'),
    x = Symbol.for('react.memo'),
    y = Symbol.for('react.lazy'),
    z2 = Symbol.iterator
  function A(a) {
    if (null === a || 'object' !== typeof a) return null
    a = (z2 && a[z2]) || a['@@iterator']
    return 'function' === typeof a ? a : null
  }
  var B = {
      isMounted: function () {
        return false
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    C = Object.assign,
    D = {}
  function E(a, b, e) {
    this.props = a
    this.context = b
    this.refs = D
    this.updater = e || B
  }
  E.prototype.isReactComponent = {}
  E.prototype.setState = function (a, b) {
    if ('object' !== typeof a && 'function' !== typeof a && null != a)
      throw Error(
        'setState(...): takes an object of state variables to update or a function which returns an object of state variables.',
      )
    this.updater.enqueueSetState(this, a, b, 'setState')
  }
  E.prototype.forceUpdate = function (a) {
    this.updater.enqueueForceUpdate(this, a, 'forceUpdate')
  }
  function F() {}
  F.prototype = E.prototype
  function G(a, b, e) {
    this.props = a
    this.context = b
    this.refs = D
    this.updater = e || B
  }
  var H = (G.prototype = new F())
  H.constructor = G
  C(H, E.prototype)
  H.isPureReactComponent = true
  var I = Array.isArray,
    J = Object.prototype.hasOwnProperty,
    K = {current: null},
    L = {key: true, ref: true, __self: true, __source: true}
  function M(a, b, e) {
    var d,
      c = {},
      k = null,
      h = null
    if (null != b)
      for (d in (void 0 !== b.ref && (h = b.ref),
      void 0 !== b.key && (k = '' + b.key),
      b))
        J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d])
    var g = arguments.length - 2
    if (1 === g) c.children = e
    else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2]
      c.children = f
    }
    if (a && a.defaultProps)
      for (d in ((g = a.defaultProps), g)) void 0 === c[d] && (c[d] = g[d])
    return {$$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current}
  }
  function N(a, b) {
    return {
      $$typeof: l,
      type: a.type,
      key: b,
      ref: a.ref,
      props: a.props,
      _owner: a._owner,
    }
  }
  function O(a) {
    return 'object' === typeof a && null !== a && a.$$typeof === l
  }
  function escape(a) {
    var b = {'=': '=0', ':': '=2'}
    return (
      '$' +
      a.replace(/[=:]/g, function (a2) {
        return b[a2]
      })
    )
  }
  var P = /\/+/g
  function Q(a, b) {
    return 'object' === typeof a && null !== a && null != a.key
      ? escape('' + a.key)
      : b.toString(36)
  }
  function R(a, b, e, d, c) {
    var k = typeof a
    if ('undefined' === k || 'boolean' === k) a = null
    var h = false
    if (null === a) h = true
    else
      switch (k) {
        case 'string':
        case 'number':
          h = true
          break
        case 'object':
          switch (a.$$typeof) {
            case l:
            case n:
              h = true
          }
      }
    if (h)
      return (
        (h = a),
        (c = c(h)),
        (a = '' === d ? '.' + Q(h, 0) : d),
        I(c)
          ? ((e = ''),
            null != a && (e = a.replace(P, '$&/') + '/'),
            R(c, b, e, '', function (a2) {
              return a2
            }))
          : null != c &&
            (O(c) &&
              (c = N(
                c,
                e +
                  (!c.key || (h && h.key === c.key)
                    ? ''
                    : ('' + c.key).replace(P, '$&/') + '/') +
                  a,
              )),
            b.push(c)),
        1
      )
    h = 0
    d = '' === d ? '.' : d + ':'
    if (I(a))
      for (var g = 0; g < a.length; g++) {
        k = a[g]
        var f = d + Q(k, g)
        h += R(k, b, e, f, c)
      }
    else if (((f = A(a)), 'function' === typeof f))
      for (a = f.call(a), g = 0; !(k = a.next()).done; )
        (k = k.value), (f = d + Q(k, g++)), (h += R(k, b, e, f, c))
    else if ('object' === k)
      throw (
        ((b = String(a)),
        Error(
          'Objects are not valid as a React child (found: ' +
            ('[object Object]' === b
              ? 'object with keys {' + Object.keys(a).join(', ') + '}'
              : b) +
            '). If you meant to render a collection of children, use an array instead.',
        ))
      )
    return h
  }
  function S(a, b, e) {
    if (null == a) return a
    var d = [],
      c = 0
    R(a, d, '', '', function (a2) {
      return b.call(e, a2, c++)
    })
    return d
  }
  function T(a) {
    if (-1 === a._status) {
      var b = a._result
      b = b()
      b.then(
        function (b2) {
          if (0 === a._status || -1 === a._status)
            (a._status = 1), (a._result = b2)
        },
        function (b2) {
          if (0 === a._status || -1 === a._status)
            (a._status = 2), (a._result = b2)
        },
      )
      ;-1 === a._status && ((a._status = 0), (a._result = b))
    }
    if (1 === a._status) return a._result.default
    throw a._result
  }
  var U = {current: null},
    V = {transition: null},
    W = {
      ReactCurrentDispatcher: U,
      ReactCurrentBatchConfig: V,
      ReactCurrentOwner: K,
    }
  react_production_min.Children = {
    map: S,
    forEach: function (a, b, e) {
      S(
        a,
        function () {
          b.apply(this, arguments)
        },
        e,
      )
    },
    count: function (a) {
      var b = 0
      S(a, function () {
        b++
      })
      return b
    },
    toArray: function (a) {
      return (
        S(a, function (a2) {
          return a2
        }) || []
      )
    },
    only: function (a) {
      if (!O(a))
        throw Error(
          'React.Children.only expected to receive a single React element child.',
        )
      return a
    },
  }
  react_production_min.Component = E
  react_production_min.Fragment = p
  react_production_min.Profiler = r
  react_production_min.PureComponent = G
  react_production_min.StrictMode = q
  react_production_min.Suspense = w
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W
  react_production_min.cloneElement = function (a, b, e) {
    if (null === a || void 0 === a)
      throw Error(
        'React.cloneElement(...): The argument must be a React element, but you passed ' +
          a +
          '.',
      )
    var d = C({}, a.props),
      c = a.key,
      k = a.ref,
      h = a._owner
    if (null != b) {
      void 0 !== b.ref && ((k = b.ref), (h = K.current))
      void 0 !== b.key && (c = '' + b.key)
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps
      for (f in b)
        J.call(b, f) &&
          !L.hasOwnProperty(f) &&
          (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f])
    }
    var f = arguments.length - 2
    if (1 === f) d.children = e
    else if (1 < f) {
      g = Array(f)
      for (var m = 0; m < f; m++) g[m] = arguments[m + 2]
      d.children = g
    }
    return {$$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h}
  }
  react_production_min.createContext = function (a) {
    a = {
      $$typeof: u,
      _currentValue: a,
      _currentValue2: a,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }
    a.Provider = {$$typeof: t, _context: a}
    return (a.Consumer = a)
  }
  react_production_min.createElement = M
  react_production_min.createFactory = function (a) {
    var b = M.bind(null, a)
    b.type = a
    return b
  }
  react_production_min.createRef = function () {
    return {current: null}
  }
  react_production_min.forwardRef = function (a) {
    return {$$typeof: v, render: a}
  }
  react_production_min.isValidElement = O
  react_production_min.lazy = function (a) {
    return {$$typeof: y, _payload: {_status: -1, _result: a}, _init: T}
  }
  react_production_min.memo = function (a, b) {
    return {$$typeof: x, type: a, compare: void 0 === b ? null : b}
  }
  react_production_min.startTransition = function (a) {
    var b = V.transition
    V.transition = {}
    try {
      a()
    } finally {
      V.transition = b
    }
  }
  react_production_min.unstable_act = function () {
    throw Error('act(...) is not supported in production builds of React.')
  }
  react_production_min.useCallback = function (a, b) {
    return U.current.useCallback(a, b)
  }
  react_production_min.useContext = function (a) {
    return U.current.useContext(a)
  }
  react_production_min.useDebugValue = function () {}
  react_production_min.useDeferredValue = function (a) {
    return U.current.useDeferredValue(a)
  }
  react_production_min.useEffect = function (a, b) {
    return U.current.useEffect(a, b)
  }
  react_production_min.useId = function () {
    return U.current.useId()
  }
  react_production_min.useImperativeHandle = function (a, b, e) {
    return U.current.useImperativeHandle(a, b, e)
  }
  react_production_min.useInsertionEffect = function (a, b) {
    return U.current.useInsertionEffect(a, b)
  }
  react_production_min.useLayoutEffect = function (a, b) {
    return U.current.useLayoutEffect(a, b)
  }
  react_production_min.useMemo = function (a, b) {
    return U.current.useMemo(a, b)
  }
  react_production_min.useReducer = function (a, b, e) {
    return U.current.useReducer(a, b, e)
  }
  react_production_min.useRef = function (a) {
    return U.current.useRef(a)
  }
  react_production_min.useState = function (a) {
    return U.current.useState(a)
  }
  react_production_min.useSyncExternalStore = function (a, b, e) {
    return U.current.useSyncExternalStore(a, b, e)
  }
  react_production_min.useTransition = function () {
    return U.current.useTransition()
  }
  react_production_min.version = '18.2.0'
  return react_production_min
}
var react_development = {exports: {}}
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
react_development.exports
var hasRequiredReact_development
function requireReact_development() {
  if (hasRequiredReact_development) return react_development.exports
  hasRequiredReact_development = 1
  ;(function (module, exports) {
    if (process.env.NODE_ENV !== 'production') {
      ;(function () {
        if (
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
            'function'
        ) {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(
            new Error(),
          )
        }
        var ReactVersion = '18.2.0'
        var REACT_ELEMENT_TYPE = Symbol.for('react.element')
        var REACT_PORTAL_TYPE = Symbol.for('react.portal')
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler')
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider')
        var REACT_CONTEXT_TYPE = Symbol.for('react.context')
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')
        var REACT_MEMO_TYPE = Symbol.for('react.memo')
        var REACT_LAZY_TYPE = Symbol.for('react.lazy')
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen')
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator
        var FAUX_ITERATOR_SYMBOL = '@@iterator'
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== 'object') {
            return null
          }
          var maybeIterator =
            (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
            maybeIterable[FAUX_ITERATOR_SYMBOL]
          if (typeof maybeIterator === 'function') {
            return maybeIterator
          }
          return null
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null,
        }
        var ReactCurrentBatchConfig = {
          transition: null,
        }
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
        }
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null,
        }
        var ReactDebugCurrentFrame = {}
        var currentExtraStackFrame = null
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
            {
              currentExtraStackFrame = stack
            }
          }
          ReactDebugCurrentFrame.getCurrentStack = null
          ReactDebugCurrentFrame.getStackAddendum = function () {
            var stack = ''
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack
            if (impl) {
              stack += impl() || ''
            }
            return stack
          }
        }
        var enableScopeAPI = false
        var enableCacheElement = false
        var enableTransitionTracing = false
        var enableLegacyHidden = false
        var enableDebugTracing = false
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
        }
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue
        }
        function warn(format2) {
          {
            {
              for (
                var _len = arguments.length,
                  args = new Array(_len > 1 ? _len - 1 : 0),
                  _key = 1;
                _key < _len;
                _key++
              ) {
                args[_key - 1] = arguments[_key]
              }
              printWarning('warn', format2, args)
            }
          }
        }
        function error(format2) {
          {
            {
              for (
                var _len2 = arguments.length,
                  args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                  _key2 = 1;
                _key2 < _len2;
                _key2++
              ) {
                args[_key2 - 1] = arguments[_key2]
              }
              printWarning('error', format2, args)
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 =
              ReactSharedInternals.ReactDebugCurrentFrame
            var stack = ReactDebugCurrentFrame2.getStackAddendum()
            if (stack !== '') {
              format2 += '%s'
              args = args.concat([stack])
            }
            var argsWithFormat = args.map(function (item) {
              return String(item)
            })
            argsWithFormat.unshift('Warning: ' + format2)
            Function.prototype.apply.call(
              console[level],
              console,
              argsWithFormat,
            )
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {}
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor
            var componentName =
              (_constructor &&
                (_constructor.displayName || _constructor.name)) ||
              'ReactClass'
            var warningKey = componentName + '.' + callerName
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return
            }
            error(
              "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
              callerName,
              componentName,
            )
            didWarnStateUpdateForUnmountedComponent[warningKey] = true
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function (publicInstance) {
            return false
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function (publicInstance, callback, callerName) {
            warnNoop(publicInstance, 'forceUpdate')
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function (
            publicInstance,
            completeState,
            callback,
            callerName,
          ) {
            warnNoop(publicInstance, 'replaceState')
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function (
            publicInstance,
            partialState,
            callback,
            callerName,
          ) {
            warnNoop(publicInstance, 'setState')
          },
        }
        var assign2 = Object.assign
        var emptyObject = {}
        {
          Object.freeze(emptyObject)
        }
        function Component(props, context, updater) {
          this.props = props
          this.context = context
          this.refs = emptyObject
          this.updater = updater || ReactNoopUpdateQueue
        }
        Component.prototype.isReactComponent = {}
        Component.prototype.setState = function (partialState, callback) {
          if (
            typeof partialState !== 'object' &&
            typeof partialState !== 'function' &&
            partialState != null
          ) {
            throw new Error(
              'setState(...): takes an object of state variables to update or a function which returns an object of state variables.',
            )
          }
          this.updater.enqueueSetState(this, partialState, callback, 'setState')
        }
        Component.prototype.forceUpdate = function (callback) {
          this.updater.enqueueForceUpdate(this, callback, 'forceUpdate')
        }
        {
          var deprecatedAPIs = {
            isMounted: [
              'isMounted',
              'Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.',
            ],
            replaceState: [
              'replaceState',
              'Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).',
            ],
          }
          var defineDeprecationWarning = function (methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function () {
                warn(
                  '%s(...) is deprecated in plain JavaScript React classes. %s',
                  info[0],
                  info[1],
                )
                return void 0
              },
            })
          }
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName])
            }
          }
        }
        function ComponentDummy() {}
        ComponentDummy.prototype = Component.prototype
        function PureComponent(props, context, updater) {
          this.props = props
          this.context = context
          this.refs = emptyObject
          this.updater = updater || ReactNoopUpdateQueue
        }
        var pureComponentPrototype = (PureComponent.prototype =
          new ComponentDummy())
        pureComponentPrototype.constructor = PureComponent
        assign2(pureComponentPrototype, Component.prototype)
        pureComponentPrototype.isPureReactComponent = true
        function createRef() {
          var refObject = {
            current: null,
          }
          {
            Object.seal(refObject)
          }
          return refObject
        }
        var isArrayImpl = Array.isArray
        function isArray2(a) {
          return isArrayImpl(a)
        }
        function typeName(value) {
          {
            var hasToStringTag =
              typeof Symbol === 'function' && Symbol.toStringTag
            var type =
              (hasToStringTag && value[Symbol.toStringTag]) ||
              value.constructor.name ||
              'Object'
            return type
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value)
              return false
            } catch (e) {
              return true
            }
          }
        }
        function testStringCoercion(value) {
          return '' + value
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error(
                'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
                typeName(value),
              )
              return testStringCoercion(value)
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName
          if (displayName) {
            return displayName
          }
          var functionName = innerType.displayName || innerType.name || ''
          return functionName !== ''
            ? wrapperName + '(' + functionName + ')'
            : wrapperName
        }
        function getContextName(type) {
          return type.displayName || 'Context'
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null
          }
          {
            if (typeof type.tag === 'number') {
              error(
                'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.',
              )
            }
          }
          if (typeof type === 'function') {
            return type.displayName || type.name || null
          }
          if (typeof type === 'string') {
            return type
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return 'Fragment'
            case REACT_PORTAL_TYPE:
              return 'Portal'
            case REACT_PROFILER_TYPE:
              return 'Profiler'
            case REACT_STRICT_MODE_TYPE:
              return 'StrictMode'
            case REACT_SUSPENSE_TYPE:
              return 'Suspense'
            case REACT_SUSPENSE_LIST_TYPE:
              return 'SuspenseList'
          }
          if (typeof type === 'object') {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type
                return getContextName(context) + '.Consumer'
              case REACT_PROVIDER_TYPE:
                var provider = type
                return getContextName(provider._context) + '.Provider'
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef')
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null
                if (outerName !== null) {
                  return outerName
                }
                return getComponentNameFromType(type.type) || 'Memo'
              case REACT_LAZY_TYPE: {
                var lazyComponent = type
                var payload = lazyComponent._payload
                var init = lazyComponent._init
                try {
                  return getComponentNameFromType(init(payload))
                } catch (x) {
                  return null
                }
              }
            }
          }
          return null
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true,
        }
        var specialPropKeyWarningShown,
          specialPropRefWarningShown,
          didWarnAboutStringRefs
        {
          didWarnAboutStringRefs = {}
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, 'ref')) {
              var getter = Object.getOwnPropertyDescriptor(config, 'ref').get
              if (getter && getter.isReactWarning) {
                return false
              }
            }
          }
          return config.ref !== void 0
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, 'key')) {
              var getter = Object.getOwnPropertyDescriptor(config, 'key').get
              if (getter && getter.isReactWarning) {
                return false
              }
            }
          }
          return config.key !== void 0
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function () {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true
                error(
                  '%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
                  displayName,
                )
              }
            }
          }
          warnAboutAccessingKey.isReactWarning = true
          Object.defineProperty(props, 'key', {
            get: warnAboutAccessingKey,
            configurable: true,
          })
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function () {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true
                error(
                  '%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
                  displayName,
                )
              }
            }
          }
          warnAboutAccessingRef.isReactWarning = true
          Object.defineProperty(props, 'ref', {
            get: warnAboutAccessingRef,
            configurable: true,
          })
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (
              typeof config.ref === 'string' &&
              ReactCurrentOwner.current &&
              config.__self &&
              ReactCurrentOwner.current.stateNode !== config.__self
            ) {
              var componentName = getComponentNameFromType(
                ReactCurrentOwner.current.type,
              )
              if (!didWarnAboutStringRefs[componentName]) {
                error(
                  'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
                  componentName,
                  config.ref,
                )
                didWarnAboutStringRefs[componentName] = true
              }
            }
          }
        }
        var ReactElement = function (
          type,
          key,
          ref,
          self2,
          source,
          owner,
          props,
        ) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner,
          }
          {
            element._store = {}
            Object.defineProperty(element._store, 'validated', {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false,
            })
            Object.defineProperty(element, '_self', {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2,
            })
            Object.defineProperty(element, '_source', {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source,
            })
            if (Object.freeze) {
              Object.freeze(element.props)
              Object.freeze(element)
            }
          }
          return element
        }
        function createElement(type, config, children) {
          var propName
          var props = {}
          var key = null
          var ref = null
          var self2 = null
          var source = null
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref
              {
                warnIfStringRefCannotBeAutoConverted(config)
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key)
              }
              key = '' + config.key
            }
            self2 = config.__self === void 0 ? null : config.__self
            source = config.__source === void 0 ? null : config.__source
            for (propName in config) {
              if (
                hasOwnProperty.call(config, propName) &&
                !RESERVED_PROPS.hasOwnProperty(propName)
              ) {
                props[propName] = config[propName]
              }
            }
          }
          var childrenLength = arguments.length - 2
          if (childrenLength === 1) {
            props.children = children
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength)
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2]
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray)
              }
            }
            props.children = childArray
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName]
              }
            }
          }
          {
            if (key || ref) {
              var displayName =
                typeof type === 'function'
                  ? type.displayName || type.name || 'Unknown'
                  : type
              if (key) {
                defineKeyPropWarningGetter(props, displayName)
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName)
              }
            }
          }
          return ReactElement(
            type,
            key,
            ref,
            self2,
            source,
            ReactCurrentOwner.current,
            props,
          )
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(
            oldElement.type,
            newKey,
            oldElement.ref,
            oldElement._self,
            oldElement._source,
            oldElement._owner,
            oldElement.props,
          )
          return newElement
        }
        function cloneElement(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error(
              'React.cloneElement(...): The argument must be a React element, but you passed ' +
                element +
                '.',
            )
          }
          var propName
          var props = assign2({}, element.props)
          var key = element.key
          var ref = element.ref
          var self2 = element._self
          var source = element._source
          var owner = element._owner
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref
              owner = ReactCurrentOwner.current
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key)
              }
              key = '' + config.key
            }
            var defaultProps
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps
            }
            for (propName in config) {
              if (
                hasOwnProperty.call(config, propName) &&
                !RESERVED_PROPS.hasOwnProperty(propName)
              ) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName]
                } else {
                  props[propName] = config[propName]
                }
              }
            }
          }
          var childrenLength = arguments.length - 2
          if (childrenLength === 1) {
            props.children = children
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength)
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2]
            }
            props.children = childArray
          }
          return ReactElement(
            element.type,
            key,
            ref,
            self2,
            source,
            owner,
            props,
          )
        }
        function isValidElement(object) {
          return (
            typeof object === 'object' &&
            object !== null &&
            object.$$typeof === REACT_ELEMENT_TYPE
          )
        }
        var SEPARATOR = '.'
        var SUBSEPARATOR = ':'
        function escape(key) {
          var escapeRegex = /[=:]/g
          var escaperLookup = {
            '=': '=0',
            ':': '=2',
          }
          var escapedString = key.replace(escapeRegex, function (match2) {
            return escaperLookup[match2]
          })
          return '$' + escapedString
        }
        var didWarnAboutMaps = false
        var userProvidedKeyEscapeRegex = /\/+/g
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, '$&/')
        }
        function getElementKey(element, index) {
          if (
            typeof element === 'object' &&
            element !== null &&
            element.key != null
          ) {
            {
              checkKeyStringCoercion(element.key)
            }
            return escape('' + element.key)
          }
          return index.toString(36)
        }
        function mapIntoArray(
          children,
          array,
          escapedPrefix,
          nameSoFar,
          callback,
        ) {
          var type = typeof children
          if (type === 'undefined' || type === 'boolean') {
            children = null
          }
          var invokeCallback = false
          if (children === null) {
            invokeCallback = true
          } else {
            switch (type) {
              case 'string':
              case 'number':
                invokeCallback = true
                break
              case 'object':
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true
                }
            }
          }
          if (invokeCallback) {
            var _child = children
            var mappedChild = callback(_child)
            var childKey =
              nameSoFar === ''
                ? SEPARATOR + getElementKey(_child, 0)
                : nameSoFar
            if (isArray2(mappedChild)) {
              var escapedChildKey = ''
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + '/'
              }
              mapIntoArray(
                mappedChild,
                array,
                escapedChildKey,
                '',
                function (c) {
                  return c
                },
              )
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (
                    mappedChild.key &&
                    (!_child || _child.key !== mappedChild.key)
                  ) {
                    checkKeyStringCoercion(mappedChild.key)
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key &&
                    (!_child || _child.key !== mappedChild.key)
                      ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                        // eslint-disable-next-line react-internal/safe-string-coercion
                        escapeUserProvidedKey('' + mappedChild.key) + '/'
                      : '') +
                    childKey,
                )
              }
              array.push(mappedChild)
            }
            return 1
          }
          var child
          var nextName
          var subtreeCount = 0
          var nextNamePrefix =
            nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR
          if (isArray2(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i]
              nextName = nextNamePrefix + getElementKey(child, i)
              subtreeCount += mapIntoArray(
                child,
                array,
                escapedPrefix,
                nextName,
                callback,
              )
            }
          } else {
            var iteratorFn = getIteratorFn(children)
            if (typeof iteratorFn === 'function') {
              var iterableChildren = children
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn(
                      'Using Maps as children is not supported. Use an array of keyed ReactElements instead.',
                    )
                  }
                  didWarnAboutMaps = true
                }
              }
              var iterator = iteratorFn.call(iterableChildren)
              var step
              var ii = 0
              while (!(step = iterator.next()).done) {
                child = step.value
                nextName = nextNamePrefix + getElementKey(child, ii++)
                subtreeCount += mapIntoArray(
                  child,
                  array,
                  escapedPrefix,
                  nextName,
                  callback,
                )
              }
            } else if (type === 'object') {
              var childrenString = String(children)
              throw new Error(
                'Objects are not valid as a React child (found: ' +
                  (childrenString === '[object Object]'
                    ? 'object with keys {' +
                      Object.keys(children).join(', ') +
                      '}'
                    : childrenString) +
                  '). If you meant to render a collection of children, use an array instead.',
              )
            }
          }
          return subtreeCount
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children
          }
          var result = []
          var count = 0
          mapIntoArray(children, result, '', '', function (child) {
            return func.call(context, child, count++)
          })
          return result
        }
        function countChildren(children) {
          var n = 0
          mapChildren(children, function () {
            n++
          })
          return n
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function () {
              forEachFunc.apply(this, arguments)
            },
            forEachContext,
          )
        }
        function toArray2(children) {
          return (
            mapChildren(children, function (child) {
              return child
            }) || []
          )
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error(
              'React.Children.only expected to receive a single React element child.',
            )
          }
          return children
        }
        function createContext(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null,
          }
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context,
          }
          var hasWarnedAboutUsingNestedContextConsumers = false
          var hasWarnedAboutUsingConsumerProvider = false
          var hasWarnedAboutDisplayNameOnConsumer = false
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
            }
            Object.defineProperties(Consumer, {
              Provider: {
                get: function () {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true
                    error(
                      'Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?',
                    )
                  }
                  return context.Provider
                },
                set: function (_Provider) {
                  context.Provider = _Provider
                },
              },
              _currentValue: {
                get: function () {
                  return context._currentValue
                },
                set: function (_currentValue) {
                  context._currentValue = _currentValue
                },
              },
              _currentValue2: {
                get: function () {
                  return context._currentValue2
                },
                set: function (_currentValue2) {
                  context._currentValue2 = _currentValue2
                },
              },
              _threadCount: {
                get: function () {
                  return context._threadCount
                },
                set: function (_threadCount) {
                  context._threadCount = _threadCount
                },
              },
              Consumer: {
                get: function () {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true
                    error(
                      'Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?',
                    )
                  }
                  return context.Consumer
                },
              },
              displayName: {
                get: function () {
                  return context.displayName
                },
                set: function (displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn(
                      "Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.",
                      displayName,
                    )
                    hasWarnedAboutDisplayNameOnConsumer = true
                  }
                },
              },
            })
            context.Consumer = Consumer
          }
          {
            context._currentRenderer = null
            context._currentRenderer2 = null
          }
          return context
        }
        var Uninitialized = -1
        var Pending = 0
        var Resolved = 1
        var Rejected = 2
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result
            var thenable = ctor()
            thenable.then(
              function (moduleObject2) {
                if (
                  payload._status === Pending ||
                  payload._status === Uninitialized
                ) {
                  var resolved = payload
                  resolved._status = Resolved
                  resolved._result = moduleObject2
                }
              },
              function (error2) {
                if (
                  payload._status === Pending ||
                  payload._status === Uninitialized
                ) {
                  var rejected = payload
                  rejected._status = Rejected
                  rejected._result = error2
                }
              },
            )
            if (payload._status === Uninitialized) {
              var pending = payload
              pending._status = Pending
              pending._result = thenable
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result
            {
              if (moduleObject === void 0) {
                error(
                  "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
                  moduleObject,
                )
              }
            }
            {
              if (!('default' in moduleObject)) {
                error(
                  "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
                  moduleObject,
                )
              }
            }
            return moduleObject.default
          } else {
            throw payload._result
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor,
          }
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer,
          }
          {
            var defaultProps
            var propTypes
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function () {
                  return defaultProps
                },
                set: function (newDefaultProps) {
                  error(
                    'React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.',
                  )
                  defaultProps = newDefaultProps
                  Object.defineProperty(lazyType, 'defaultProps', {
                    enumerable: true,
                  })
                },
              },
              propTypes: {
                configurable: true,
                get: function () {
                  return propTypes
                },
                set: function (newPropTypes) {
                  error(
                    'React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.',
                  )
                  propTypes = newPropTypes
                  Object.defineProperty(lazyType, 'propTypes', {
                    enumerable: true,
                  })
                },
              },
            })
          }
          return lazyType
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error(
                'forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).',
              )
            } else if (typeof render !== 'function') {
              error(
                'forwardRef requires a render function but was given %s.',
                render === null ? 'null' : typeof render,
              )
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error(
                  'forwardRef render functions accept exactly two parameters: props and ref. %s',
                  render.length === 1
                    ? 'Did you forget to use the ref parameter?'
                    : 'Any additional parameter will be undefined.',
                )
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error(
                  'forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?',
                )
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render,
          }
          {
            var ownName
            Object.defineProperty(elementType, 'displayName', {
              enumerable: false,
              configurable: true,
              get: function () {
                return ownName
              },
              set: function (name) {
                ownName = name
                if (!render.name && !render.displayName) {
                  render.displayName = name
                }
              },
            })
          }
          return elementType
        }
        var REACT_MODULE_REFERENCE
        {
          REACT_MODULE_REFERENCE = Symbol.for('react.module.reference')
        }
        function isValidElementType(type) {
          if (typeof type === 'string' || typeof type === 'function') {
            return true
          }
          if (
            type === REACT_FRAGMENT_TYPE ||
            type === REACT_PROFILER_TYPE ||
            enableDebugTracing ||
            type === REACT_STRICT_MODE_TYPE ||
            type === REACT_SUSPENSE_TYPE ||
            type === REACT_SUSPENSE_LIST_TYPE ||
            enableLegacyHidden ||
            type === REACT_OFFSCREEN_TYPE ||
            enableScopeAPI ||
            enableCacheElement ||
            enableTransitionTracing
          ) {
            return true
          }
          if (typeof type === 'object' && type !== null) {
            if (
              type.$$typeof === REACT_LAZY_TYPE ||
              type.$$typeof === REACT_MEMO_TYPE ||
              type.$$typeof === REACT_PROVIDER_TYPE ||
              type.$$typeof === REACT_CONTEXT_TYPE ||
              type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE ||
              type.getModuleId !== void 0
            ) {
              return true
            }
          }
          return false
        }
        function memo2(type, compare) {
          {
            if (!isValidElementType(type)) {
              error(
                'memo: The first argument must be a component. Instead received: %s',
                type === null ? 'null' : typeof type,
              )
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare,
          }
          {
            var ownName
            Object.defineProperty(elementType, 'displayName', {
              enumerable: false,
              configurable: true,
              get: function () {
                return ownName
              },
              set: function (name) {
                ownName = name
                if (!type.name && !type.displayName) {
                  type.displayName = name
                }
              },
            })
          }
          return elementType
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current
          {
            if (dispatcher === null) {
              error(
                'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
              )
            }
          }
          return dispatcher
        }
        function useContext(Context) {
          var dispatcher = resolveDispatcher()
          {
            if (Context._context !== void 0) {
              var realContext = Context._context
              if (realContext.Consumer === Context) {
                error(
                  'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?',
                )
              } else if (realContext.Provider === Context) {
                error(
                  'Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?',
                )
              }
            }
          }
          return dispatcher.useContext(Context)
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useState(initialState)
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useReducer(reducer, initialArg, init)
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useRef(initialValue)
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useEffect(create, deps)
        }
        function useInsertionEffect(create, deps) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useInsertionEffect(create, deps)
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useLayoutEffect(create, deps)
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useCallback(callback, deps)
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useMemo(create, deps)
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useImperativeHandle(ref, create, deps)
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher()
            return dispatcher.useDebugValue(value, formatterFn)
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher()
          return dispatcher.useTransition()
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useDeferredValue(value)
        }
        function useId() {
          var dispatcher = resolveDispatcher()
          return dispatcher.useId()
        }
        function useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot,
        ) {
          var dispatcher = resolveDispatcher()
          return dispatcher.useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot,
          )
        }
        var disabledDepth = 0
        var prevLog
        var prevInfo
        var prevWarn
        var prevError
        var prevGroup
        var prevGroupCollapsed
        var prevGroupEnd
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log
              prevInfo = console.info
              prevWarn = console.warn
              prevError = console.error
              prevGroup = console.group
              prevGroupCollapsed = console.groupCollapsed
              prevGroupEnd = console.groupEnd
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true,
              }
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props,
              })
            }
            disabledDepth++
          }
        }
        function reenableLogs() {
          {
            disabledDepth--
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true,
              }
              Object.defineProperties(console, {
                log: assign2({}, props, {
                  value: prevLog,
                }),
                info: assign2({}, props, {
                  value: prevInfo,
                }),
                warn: assign2({}, props, {
                  value: prevWarn,
                }),
                error: assign2({}, props, {
                  value: prevError,
                }),
                group: assign2({}, props, {
                  value: prevGroup,
                }),
                groupCollapsed: assign2({}, props, {
                  value: prevGroupCollapsed,
                }),
                groupEnd: assign2({}, props, {
                  value: prevGroupEnd,
                }),
              })
            }
            if (disabledDepth < 0) {
              error(
                'disabledDepth fell below zero. This is a bug in React. Please file an issue.',
              )
            }
          }
        }
        var ReactCurrentDispatcher$1 =
          ReactSharedInternals.ReactCurrentDispatcher
        var prefix
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error()
              } catch (x) {
                var match2 = x.stack.trim().match(/\n( *(at )?)/)
                prefix = (match2 && match2[1]) || ''
              }
            }
            return '\n' + prefix + name
          }
        }
        var reentry = false
        var componentFrameCache
        {
          var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map
          componentFrameCache = new PossiblyWeakMap()
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return ''
          }
          {
            var frame = componentFrameCache.get(fn)
            if (frame !== void 0) {
              return frame
            }
          }
          var control
          reentry = true
          var previousPrepareStackTrace = Error.prepareStackTrace
          Error.prepareStackTrace = void 0
          var previousDispatcher
          {
            previousDispatcher = ReactCurrentDispatcher$1.current
            ReactCurrentDispatcher$1.current = null
            disableLogs()
          }
          try {
            if (construct) {
              var Fake = function () {
                throw Error()
              }
              Object.defineProperty(Fake.prototype, 'props', {
                set: function () {
                  throw Error()
                },
              })
              if (typeof Reflect === 'object' && Reflect.construct) {
                try {
                  Reflect.construct(Fake, [])
                } catch (x) {
                  control = x
                }
                Reflect.construct(fn, [], Fake)
              } else {
                try {
                  Fake.call()
                } catch (x) {
                  control = x
                }
                fn.call(Fake.prototype)
              }
            } else {
              try {
                throw Error()
              } catch (x) {
                control = x
              }
              fn()
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === 'string') {
              var sampleLines = sample.stack.split('\n')
              var controlLines = control.stack.split('\n')
              var s = sampleLines.length - 1
              var c = controlLines.length - 1
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--
                      c--
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame =
                          '\n' + sampleLines[s].replace(' at new ', ' at ')
                        if (fn.displayName && _frame.includes('<anonymous>')) {
                          _frame = _frame.replace('<anonymous>', fn.displayName)
                        }
                        {
                          if (typeof fn === 'function') {
                            componentFrameCache.set(fn, _frame)
                          }
                        }
                        return _frame
                      }
                    } while (s >= 1 && c >= 0)
                  }
                  break
                }
              }
            }
          } finally {
            reentry = false
            {
              ReactCurrentDispatcher$1.current = previousDispatcher
              reenableLogs()
            }
            Error.prepareStackTrace = previousPrepareStackTrace
          }
          var name = fn ? fn.displayName || fn.name : ''
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : ''
          {
            if (typeof fn === 'function') {
              componentFrameCache.set(fn, syntheticFrame)
            }
          }
          return syntheticFrame
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false)
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype
          return !!(prototype && prototype.isReactComponent)
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return ''
          }
          if (typeof type === 'function') {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type))
            }
          }
          if (typeof type === 'string') {
            return describeBuiltInComponentFrame(type)
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame('Suspense')
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame('SuspenseList')
          }
          if (typeof type === 'object') {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render)
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(
                  type.type,
                  source,
                  ownerFn,
                )
              case REACT_LAZY_TYPE: {
                var lazyComponent = type
                var payload = lazyComponent._payload
                var init = lazyComponent._init
                try {
                  return describeUnknownElementTypeFrameInDEV(
                    init(payload),
                    source,
                    ownerFn,
                  )
                } catch (x) {}
              }
            }
          }
          return ''
        }
        var loggedTypeFailures = {}
        var ReactDebugCurrentFrame$1 =
          ReactSharedInternals.ReactDebugCurrentFrame
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner
              var stack = describeUnknownElementTypeFrameInDEV(
                element.type,
                element._source,
                owner ? owner.type : null,
              )
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack)
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null)
            }
          }
        }
        function checkPropTypes(
          typeSpecs,
          values,
          location,
          componentName,
          element,
        ) {
          {
            var has = Function.call.bind(hasOwnProperty)
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0
                try {
                  if (typeof typeSpecs[typeSpecName] !== 'function') {
                    var err = Error(
                      (componentName || 'React class') +
                        ': ' +
                        location +
                        ' type `' +
                        typeSpecName +
                        '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                        typeof typeSpecs[typeSpecName] +
                        '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.',
                    )
                    err.name = 'Invariant Violation'
                    throw err
                  }
                  error$1 = typeSpecs[typeSpecName](
                    values,
                    typeSpecName,
                    componentName,
                    location,
                    null,
                    'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED',
                  )
                } catch (ex) {
                  error$1 = ex
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element)
                  error(
                    '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
                    componentName || 'React class',
                    location,
                    typeSpecName,
                    typeof error$1,
                  )
                  setCurrentlyValidatingElement(null)
                }
                if (
                  error$1 instanceof Error &&
                  !(error$1.message in loggedTypeFailures)
                ) {
                  loggedTypeFailures[error$1.message] = true
                  setCurrentlyValidatingElement(element)
                  error('Failed %s type: %s', location, error$1.message)
                  setCurrentlyValidatingElement(null)
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner
              var stack = describeUnknownElementTypeFrameInDEV(
                element.type,
                element._source,
                owner ? owner.type : null,
              )
              setExtraStackFrame(stack)
            } else {
              setExtraStackFrame(null)
            }
          }
        }
        var propTypesMisspellWarningShown
        {
          propTypesMisspellWarningShown = false
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type)
            if (name) {
              return '\n\nCheck the render method of `' + name + '`.'
            }
          }
          return ''
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, '')
            var lineNumber = source.lineNumber
            return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.'
          }
          return ''
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source)
          }
          return ''
        }
        var ownerHasKeyUseWarning = {}
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum()
          if (!info) {
            var parentName =
              typeof parentType === 'string'
                ? parentType
                : parentType.displayName || parentType.name
            if (parentName) {
              info =
                '\n\nCheck the top-level render call using <' +
                parentName +
                '>.'
            }
          }
          return info
        }
        function validateExplicitKey(element, parentType) {
          if (
            !element._store ||
            element._store.validated ||
            element.key != null
          ) {
            return
          }
          element._store.validated = true
          var currentComponentErrorInfo =
            getCurrentComponentErrorInfo(parentType)
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true
          var childOwner = ''
          if (
            element &&
            element._owner &&
            element._owner !== ReactCurrentOwner.current
          ) {
            childOwner =
              ' It was passed a child from ' +
              getComponentNameFromType(element._owner.type) +
              '.'
          }
          {
            setCurrentlyValidatingElement$1(element)
            error(
              'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
              currentComponentErrorInfo,
              childOwner,
            )
            setCurrentlyValidatingElement$1(null)
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== 'object') {
            return
          }
          if (isArray2(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i]
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType)
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node)
            if (typeof iteratorFn === 'function') {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node)
                var step
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType)
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type
            if (type === null || type === void 0 || typeof type === 'string') {
              return
            }
            var propTypes
            if (typeof type === 'function') {
              propTypes = type.propTypes
            } else if (
              typeof type === 'object' &&
              (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
                // Inner props are checked in the reconciler.
                type.$$typeof === REACT_MEMO_TYPE)
            ) {
              propTypes = type.propTypes
            } else {
              return
            }
            if (propTypes) {
              var name = getComponentNameFromType(type)
              checkPropTypes(propTypes, element.props, 'prop', name, element)
            } else if (
              type.PropTypes !== void 0 &&
              !propTypesMisspellWarningShown
            ) {
              propTypesMisspellWarningShown = true
              var _name = getComponentNameFromType(type)
              error(
                'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
                _name || 'Unknown',
              )
            }
            if (
              typeof type.getDefaultProps === 'function' &&
              !type.getDefaultProps.isReactClassApproved
            ) {
              error(
                'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.',
              )
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props)
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i]
              if (key !== 'children' && key !== 'key') {
                setCurrentlyValidatingElement$1(fragment)
                error(
                  'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
                  key,
                )
                setCurrentlyValidatingElement$1(null)
                break
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment)
              error('Invalid attribute `ref` supplied to `React.Fragment`.')
              setCurrentlyValidatingElement$1(null)
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type)
          if (!validType) {
            var info = ''
            if (
              type === void 0 ||
              (typeof type === 'object' &&
                type !== null &&
                Object.keys(type).length === 0)
            ) {
              info +=
                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props)
            if (sourceInfo) {
              info += sourceInfo
            } else {
              info += getDeclarationErrorAddendum()
            }
            var typeString
            if (type === null) {
              typeString = 'null'
            } else if (isArray2(type)) {
              typeString = 'array'
            } else if (
              type !== void 0 &&
              type.$$typeof === REACT_ELEMENT_TYPE
            ) {
              typeString =
                '<' + (getComponentNameFromType(type.type) || 'Unknown') + ' />'
              info =
                ' Did you accidentally export a JSX literal instead of a component?'
            } else {
              typeString = typeof type
            }
            {
              error(
                'React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
                typeString,
                info,
              )
            }
          }
          var element = createElement.apply(this, arguments)
          if (element == null) {
            return element
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type)
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element)
          } else {
            validatePropTypes(element)
          }
          return element
        }
        var didWarnAboutDeprecatedCreateFactory = false
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type)
          validatedFactory.type = type
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true
              warn(
                'React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.',
              )
            }
            Object.defineProperty(validatedFactory, 'type', {
              enumerable: false,
              get: function () {
                warn(
                  'Factory.type is deprecated. Access the class directly before passing it to createFactory.',
                )
                Object.defineProperty(this, 'type', {
                  value: type,
                })
                return type
              },
            })
          }
          return validatedFactory
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments)
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type)
          }
          validatePropTypes(newElement)
          return newElement
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition
          ReactCurrentBatchConfig.transition = {}
          var currentTransition = ReactCurrentBatchConfig.transition
          {
            ReactCurrentBatchConfig.transition._updatedFibers =
              /* @__PURE__ */ new Set()
          }
          try {
            scope()
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size
                if (updatedFibersCount > 10) {
                  warn(
                    'Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.',
                  )
                }
                currentTransition._updatedFibers.clear()
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false
        var enqueueTaskImpl = null
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ('require' + Math.random()).slice(0, 7)
              var nodeRequire = module && module[requireString]
              enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate
            } catch (_err) {
              enqueueTaskImpl = function (callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true
                    if (typeof MessageChannel === 'undefined') {
                      error(
                        'This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.',
                      )
                    }
                  }
                }
                var channel = new MessageChannel()
                channel.port1.onmessage = callback
                channel.port2.postMessage(void 0)
              }
            }
          }
          return enqueueTaskImpl(task)
        }
        var actScopeDepth = 0
        var didWarnNoAwaitAct = false
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth
            actScopeDepth++
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = []
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy
            var result
            try {
              ReactCurrentActQueue.isBatchingLegacy = true
              result = callback()
              if (
                !prevIsBatchingLegacy &&
                ReactCurrentActQueue.didScheduleLegacyUpdate
              ) {
                var queue = ReactCurrentActQueue.current
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false
                  flushActQueue(queue)
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth)
              throw error2
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy
            }
            if (
              result !== null &&
              typeof result === 'object' &&
              typeof result.then === 'function'
            ) {
              var thenableResult = result
              var wasAwaited = false
              var thenable = {
                then: function (resolve, reject) {
                  wasAwaited = true
                  thenableResult.then(
                    function (returnValue2) {
                      popActScope(prevActScopeDepth)
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(
                          returnValue2,
                          resolve,
                          reject,
                        )
                      } else {
                        resolve(returnValue2)
                      }
                    },
                    function (error2) {
                      popActScope(prevActScopeDepth)
                      reject(error2)
                    },
                  )
                },
              }
              {
                if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {
                  Promise.resolve()
                    .then(function () {})
                    .then(function () {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true
                        error(
                          'You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);',
                        )
                      }
                    })
                }
              }
              return thenable
            } else {
              var returnValue = result
              popActScope(prevActScopeDepth)
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current
                if (_queue !== null) {
                  flushActQueue(_queue)
                  ReactCurrentActQueue.current = null
                }
                var _thenable = {
                  then: function (resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = []
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject)
                    } else {
                      resolve(returnValue)
                    }
                  },
                }
                return _thenable
              } else {
                var _thenable2 = {
                  then: function (resolve, reject) {
                    resolve(returnValue)
                  },
                }
                return _thenable2
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error(
                'You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ',
              )
            }
            actScopeDepth = prevActScopeDepth
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current
            if (queue !== null) {
              try {
                flushActQueue(queue)
                enqueueTask(function () {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null
                    resolve(returnValue)
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject)
                  }
                })
              } catch (error2) {
                reject(error2)
              }
            } else {
              resolve(returnValue)
            }
          }
        }
        var isFlushing = false
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true
              var i = 0
              try {
                for (; i < queue.length; i++) {
                  var callback = queue[i]
                  do {
                    callback = callback(true)
                  } while (callback !== null)
                }
                queue.length = 0
              } catch (error2) {
                queue = queue.slice(i + 1)
                throw error2
              } finally {
                isFlushing = false
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation
        var cloneElement$1 = cloneElementWithValidation
        var createFactory = createFactoryWithValidation
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray: toArray2,
          only: onlyChild,
        }
        exports.Children = Children
        exports.Component = Component
        exports.Fragment = REACT_FRAGMENT_TYPE
        exports.Profiler = REACT_PROFILER_TYPE
        exports.PureComponent = PureComponent
        exports.StrictMode = REACT_STRICT_MODE_TYPE
        exports.Suspense = REACT_SUSPENSE_TYPE
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED =
          ReactSharedInternals
        exports.cloneElement = cloneElement$1
        exports.createContext = createContext
        exports.createElement = createElement$1
        exports.createFactory = createFactory
        exports.createRef = createRef
        exports.forwardRef = forwardRef
        exports.isValidElement = isValidElement
        exports.lazy = lazy
        exports.memo = memo2
        exports.startTransition = startTransition
        exports.unstable_act = act
        exports.useCallback = useCallback
        exports.useContext = useContext
        exports.useDebugValue = useDebugValue
        exports.useDeferredValue = useDeferredValue
        exports.useEffect = useEffect
        exports.useId = useId
        exports.useImperativeHandle = useImperativeHandle
        exports.useInsertionEffect = useInsertionEffect
        exports.useLayoutEffect = useLayoutEffect
        exports.useMemo = useMemo
        exports.useReducer = useReducer
        exports.useRef = useRef
        exports.useState = useState
        exports.useSyncExternalStore = useSyncExternalStore
        exports.useTransition = useTransition
        exports.version = ReactVersion
        if (
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
            'function'
        ) {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error())
        }
      })()
    }
  })(react_development, react_development.exports)
  return react_development.exports
}
var hasRequiredReact
function requireReact() {
  if (hasRequiredReact) return react.exports
  hasRequiredReact = 1
  if (process.env.NODE_ENV === 'production') {
    react.exports = requireReact_production_min()
  } else {
    react.exports = requireReact_development()
  }
  return react.exports
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min
  hasRequiredReactJsxRuntime_production_min = 1
  var f = requireReact(),
    k = Symbol.for('react.element'),
    l = Symbol.for('react.fragment'),
    m = Object.prototype.hasOwnProperty,
    n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    p = {key: true, ref: true, __self: true, __source: true}
  function q(c, a, g) {
    var b,
      d = {},
      e = null,
      h = null
    void 0 !== g && (e = '' + g)
    void 0 !== a.key && (e = '' + a.key)
    void 0 !== a.ref && (h = a.ref)
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b])
    if (c && c.defaultProps)
      for (b in ((a = c.defaultProps), a)) void 0 === d[b] && (d[b] = a[b])
    return {$$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current}
  }
  reactJsxRuntime_production_min.Fragment = l
  reactJsxRuntime_production_min.jsx = q
  reactJsxRuntime_production_min.jsxs = q
  return reactJsxRuntime_production_min
}
var reactJsxRuntime_development = {}
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development
  hasRequiredReactJsxRuntime_development = 1
  if (process.env.NODE_ENV !== 'production') {
    ;(function () {
      var React2 = requireReact()
      var REACT_ELEMENT_TYPE = Symbol.for('react.element')
      var REACT_PORTAL_TYPE = Symbol.for('react.portal')
      var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')
      var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')
      var REACT_PROFILER_TYPE = Symbol.for('react.profiler')
      var REACT_PROVIDER_TYPE = Symbol.for('react.provider')
      var REACT_CONTEXT_TYPE = Symbol.for('react.context')
      var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')
      var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')
      var REACT_MEMO_TYPE = Symbol.for('react.memo')
      var REACT_LAZY_TYPE = Symbol.for('react.lazy')
      var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen')
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator
      var FAUX_ITERATOR_SYMBOL = '@@iterator'
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') {
          return null
        }
        var maybeIterator =
          (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
          maybeIterable[FAUX_ITERATOR_SYMBOL]
        if (typeof maybeIterator === 'function') {
          return maybeIterator
        }
        return null
      }
      var ReactSharedInternals =
        React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      function error(format2) {
        {
          {
            for (
              var _len2 = arguments.length,
                args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                _key2 = 1;
              _key2 < _len2;
              _key2++
            ) {
              args[_key2 - 1] = arguments[_key2]
            }
            printWarning('error', format2, args)
          }
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 =
            ReactSharedInternals.ReactDebugCurrentFrame
          var stack = ReactDebugCurrentFrame2.getStackAddendum()
          if (stack !== '') {
            format2 += '%s'
            args = args.concat([stack])
          }
          var argsWithFormat = args.map(function (item) {
            return String(item)
          })
          argsWithFormat.unshift('Warning: ' + format2)
          Function.prototype.apply.call(console[level], console, argsWithFormat)
        }
      }
      var enableScopeAPI = false
      var enableCacheElement = false
      var enableTransitionTracing = false
      var enableLegacyHidden = false
      var enableDebugTracing = false
      var REACT_MODULE_REFERENCE
      {
        REACT_MODULE_REFERENCE = Symbol.for('react.module.reference')
      }
      function isValidElementType(type) {
        if (typeof type === 'string' || typeof type === 'function') {
          return true
        }
        if (
          type === REACT_FRAGMENT_TYPE ||
          type === REACT_PROFILER_TYPE ||
          enableDebugTracing ||
          type === REACT_STRICT_MODE_TYPE ||
          type === REACT_SUSPENSE_TYPE ||
          type === REACT_SUSPENSE_LIST_TYPE ||
          enableLegacyHidden ||
          type === REACT_OFFSCREEN_TYPE ||
          enableScopeAPI ||
          enableCacheElement ||
          enableTransitionTracing
        ) {
          return true
        }
        if (typeof type === 'object' && type !== null) {
          if (
            type.$$typeof === REACT_LAZY_TYPE ||
            type.$$typeof === REACT_MEMO_TYPE ||
            type.$$typeof === REACT_PROVIDER_TYPE ||
            type.$$typeof === REACT_CONTEXT_TYPE ||
            type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE ||
            type.getModuleId !== void 0
          ) {
            return true
          }
        }
        return false
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName
        if (displayName) {
          return displayName
        }
        var functionName = innerType.displayName || innerType.name || ''
        return functionName !== ''
          ? wrapperName + '(' + functionName + ')'
          : wrapperName
      }
      function getContextName(type) {
        return type.displayName || 'Context'
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null
        }
        {
          if (typeof type.tag === 'number') {
            error(
              'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.',
            )
          }
        }
        if (typeof type === 'function') {
          return type.displayName || type.name || null
        }
        if (typeof type === 'string') {
          return type
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return 'Fragment'
          case REACT_PORTAL_TYPE:
            return 'Portal'
          case REACT_PROFILER_TYPE:
            return 'Profiler'
          case REACT_STRICT_MODE_TYPE:
            return 'StrictMode'
          case REACT_SUSPENSE_TYPE:
            return 'Suspense'
          case REACT_SUSPENSE_LIST_TYPE:
            return 'SuspenseList'
        }
        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type
              return getContextName(context) + '.Consumer'
            case REACT_PROVIDER_TYPE:
              var provider = type
              return getContextName(provider._context) + '.Provider'
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, 'ForwardRef')
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null
              if (outerName !== null) {
                return outerName
              }
              return getComponentNameFromType(type.type) || 'Memo'
            case REACT_LAZY_TYPE: {
              var lazyComponent = type
              var payload = lazyComponent._payload
              var init = lazyComponent._init
              try {
                return getComponentNameFromType(init(payload))
              } catch (x) {
                return null
              }
            }
          }
        }
        return null
      }
      var assign2 = Object.assign
      var disabledDepth = 0
      var prevLog
      var prevInfo
      var prevWarn
      var prevError
      var prevGroup
      var prevGroupCollapsed
      var prevGroupEnd
      function disabledLog() {}
      disabledLog.__reactDisabledLog = true
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log
            prevInfo = console.info
            prevWarn = console.warn
            prevError = console.error
            prevGroup = console.group
            prevGroupCollapsed = console.groupCollapsed
            prevGroupEnd = console.groupEnd
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true,
            }
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props,
            })
          }
          disabledDepth++
        }
      }
      function reenableLogs() {
        {
          disabledDepth--
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true,
            }
            Object.defineProperties(console, {
              log: assign2({}, props, {
                value: prevLog,
              }),
              info: assign2({}, props, {
                value: prevInfo,
              }),
              warn: assign2({}, props, {
                value: prevWarn,
              }),
              error: assign2({}, props, {
                value: prevError,
              }),
              group: assign2({}, props, {
                value: prevGroup,
              }),
              groupCollapsed: assign2({}, props, {
                value: prevGroupCollapsed,
              }),
              groupEnd: assign2({}, props, {
                value: prevGroupEnd,
              }),
            })
          }
          if (disabledDepth < 0) {
            error(
              'disabledDepth fell below zero. This is a bug in React. Please file an issue.',
            )
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
      var prefix
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error()
            } catch (x) {
              var match2 = x.stack.trim().match(/\n( *(at )?)/)
              prefix = (match2 && match2[1]) || ''
            }
          }
          return '\n' + prefix + name
        }
      }
      var reentry = false
      var componentFrameCache
      {
        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map
        componentFrameCache = new PossiblyWeakMap()
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return ''
        }
        {
          var frame = componentFrameCache.get(fn)
          if (frame !== void 0) {
            return frame
          }
        }
        var control
        reentry = true
        var previousPrepareStackTrace = Error.prepareStackTrace
        Error.prepareStackTrace = void 0
        var previousDispatcher
        {
          previousDispatcher = ReactCurrentDispatcher.current
          ReactCurrentDispatcher.current = null
          disableLogs()
        }
        try {
          if (construct) {
            var Fake = function () {
              throw Error()
            }
            Object.defineProperty(Fake.prototype, 'props', {
              set: function () {
                throw Error()
              },
            })
            if (typeof Reflect === 'object' && Reflect.construct) {
              try {
                Reflect.construct(Fake, [])
              } catch (x) {
                control = x
              }
              Reflect.construct(fn, [], Fake)
            } else {
              try {
                Fake.call()
              } catch (x) {
                control = x
              }
              fn.call(Fake.prototype)
            }
          } else {
            try {
              throw Error()
            } catch (x) {
              control = x
            }
            fn()
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === 'string') {
            var sampleLines = sample.stack.split('\n')
            var controlLines = control.stack.split('\n')
            var s = sampleLines.length - 1
            var c = controlLines.length - 1
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--
                    c--
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame =
                        '\n' + sampleLines[s].replace(' at new ', ' at ')
                      if (fn.displayName && _frame.includes('<anonymous>')) {
                        _frame = _frame.replace('<anonymous>', fn.displayName)
                      }
                      {
                        if (typeof fn === 'function') {
                          componentFrameCache.set(fn, _frame)
                        }
                      }
                      return _frame
                    }
                  } while (s >= 1 && c >= 0)
                }
                break
              }
            }
          }
        } finally {
          reentry = false
          {
            ReactCurrentDispatcher.current = previousDispatcher
            reenableLogs()
          }
          Error.prepareStackTrace = previousPrepareStackTrace
        }
        var name = fn ? fn.displayName || fn.name : ''
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : ''
        {
          if (typeof fn === 'function') {
            componentFrameCache.set(fn, syntheticFrame)
          }
        }
        return syntheticFrame
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false)
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype
        return !!(prototype && prototype.isReactComponent)
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return ''
        }
        if (typeof type === 'function') {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type))
          }
        }
        if (typeof type === 'string') {
          return describeBuiltInComponentFrame(type)
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame('Suspense')
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame('SuspenseList')
        }
        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render)
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(
                type.type,
                source,
                ownerFn,
              )
            case REACT_LAZY_TYPE: {
              var lazyComponent = type
              var payload = lazyComponent._payload
              var init = lazyComponent._init
              try {
                return describeUnknownElementTypeFrameInDEV(
                  init(payload),
                  source,
                  ownerFn,
                )
              } catch (x) {}
            }
          }
        }
        return ''
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty
      var loggedTypeFailures = {}
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner
            var stack = describeUnknownElementTypeFrameInDEV(
              element.type,
              element._source,
              owner ? owner.type : null,
            )
            ReactDebugCurrentFrame.setExtraStackFrame(stack)
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null)
          }
        }
      }
      function checkPropTypes(
        typeSpecs,
        values,
        location,
        componentName,
        element,
      ) {
        {
          var has = Function.call.bind(hasOwnProperty)
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0
              try {
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                  var err = Error(
                    (componentName || 'React class') +
                      ': ' +
                      location +
                      ' type `' +
                      typeSpecName +
                      '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                      typeof typeSpecs[typeSpecName] +
                      '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.',
                  )
                  err.name = 'Invariant Violation'
                  throw err
                }
                error$1 = typeSpecs[typeSpecName](
                  values,
                  typeSpecName,
                  componentName,
                  location,
                  null,
                  'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED',
                )
              } catch (ex) {
                error$1 = ex
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element)
                error(
                  '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
                  componentName || 'React class',
                  location,
                  typeSpecName,
                  typeof error$1,
                )
                setCurrentlyValidatingElement(null)
              }
              if (
                error$1 instanceof Error &&
                !(error$1.message in loggedTypeFailures)
              ) {
                loggedTypeFailures[error$1.message] = true
                setCurrentlyValidatingElement(element)
                error('Failed %s type: %s', location, error$1.message)
                setCurrentlyValidatingElement(null)
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray
      function isArray2(a) {
        return isArrayImpl(a)
      }
      function typeName(value) {
        {
          var hasToStringTag =
            typeof Symbol === 'function' && Symbol.toStringTag
          var type =
            (hasToStringTag && value[Symbol.toStringTag]) ||
            value.constructor.name ||
            'Object'
          return type
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value)
            return false
          } catch (e) {
            return true
          }
        }
      }
      function testStringCoercion(value) {
        return '' + value
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error(
              'The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.',
              typeName(value),
            )
            return testStringCoercion(value)
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true,
      }
      var specialPropKeyWarningShown
      var specialPropRefWarningShown
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get
            if (getter && getter.isReactWarning) {
              return false
            }
          }
        }
        return config.ref !== void 0
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get
            if (getter && getter.isReactWarning) {
              return false
            }
          }
        }
        return config.key !== void 0
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (
            typeof config.ref === 'string' &&
            ReactCurrentOwner.current &&
            self2
          );
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function () {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true
              error(
                '%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
                displayName,
              )
            }
          }
          warnAboutAccessingKey.isReactWarning = true
          Object.defineProperty(props, 'key', {
            get: warnAboutAccessingKey,
            configurable: true,
          })
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function () {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true
              error(
                '%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)',
                displayName,
              )
            }
          }
          warnAboutAccessingRef.isReactWarning = true
          Object.defineProperty(props, 'ref', {
            get: warnAboutAccessingRef,
            configurable: true,
          })
        }
      }
      var ReactElement = function (
        type,
        key,
        ref,
        self2,
        source,
        owner,
        props,
      ) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner,
        }
        {
          element._store = {}
          Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false,
          })
          Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2,
          })
          Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source,
          })
          if (Object.freeze) {
            Object.freeze(element.props)
            Object.freeze(element)
          }
        }
        return element
      }
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName
          var props = {}
          var key = null
          var ref = null
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey)
            }
            key = '' + maybeKey
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key)
            }
            key = '' + config.key
          }
          if (hasValidRef(config)) {
            ref = config.ref
            warnIfStringRefCannotBeAutoConverted(config, self2)
          }
          for (propName in config) {
            if (
              hasOwnProperty.call(config, propName) &&
              !RESERVED_PROPS.hasOwnProperty(propName)
            ) {
              props[propName] = config[propName]
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName]
              }
            }
          }
          if (key || ref) {
            var displayName =
              typeof type === 'function'
                ? type.displayName || type.name || 'Unknown'
                : type
            if (key) {
              defineKeyPropWarningGetter(props, displayName)
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName)
            }
          }
          return ReactElement(
            type,
            key,
            ref,
            self2,
            source,
            ReactCurrentOwner.current,
            props,
          )
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner
            var stack = describeUnknownElementTypeFrameInDEV(
              element.type,
              element._source,
              owner ? owner.type : null,
            )
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack)
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null)
          }
        }
      }
      var propTypesMisspellWarningShown
      {
        propTypesMisspellWarningShown = false
      }
      function isValidElement(object) {
        {
          return (
            typeof object === 'object' &&
            object !== null &&
            object.$$typeof === REACT_ELEMENT_TYPE
          )
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(
              ReactCurrentOwner$1.current.type,
            )
            if (name) {
              return '\n\nCheck the render method of `' + name + '`.'
            }
          }
          return ''
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          return ''
        }
      }
      var ownerHasKeyUseWarning = {}
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum()
          if (!info) {
            var parentName =
              typeof parentType === 'string'
                ? parentType
                : parentType.displayName || parentType.name
            if (parentName) {
              info =
                '\n\nCheck the top-level render call using <' +
                parentName +
                '>.'
            }
          }
          return info
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (
            !element._store ||
            element._store.validated ||
            element.key != null
          ) {
            return
          }
          element._store.validated = true
          var currentComponentErrorInfo =
            getCurrentComponentErrorInfo(parentType)
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true
          var childOwner = ''
          if (
            element &&
            element._owner &&
            element._owner !== ReactCurrentOwner$1.current
          ) {
            childOwner =
              ' It was passed a child from ' +
              getComponentNameFromType(element._owner.type) +
              '.'
          }
          setCurrentlyValidatingElement$1(element)
          error(
            'Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',
            currentComponentErrorInfo,
            childOwner,
          )
          setCurrentlyValidatingElement$1(null)
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== 'object') {
            return
          }
          if (isArray2(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i]
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType)
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node)
            if (typeof iteratorFn === 'function') {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node)
                var step
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType)
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type
          if (type === null || type === void 0 || typeof type === 'string') {
            return
          }
          var propTypes
          if (typeof type === 'function') {
            propTypes = type.propTypes
          } else if (
            typeof type === 'object' &&
            (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)
          ) {
            propTypes = type.propTypes
          } else {
            return
          }
          if (propTypes) {
            var name = getComponentNameFromType(type)
            checkPropTypes(propTypes, element.props, 'prop', name, element)
          } else if (
            type.PropTypes !== void 0 &&
            !propTypesMisspellWarningShown
          ) {
            propTypesMisspellWarningShown = true
            var _name = getComponentNameFromType(type)
            error(
              'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
              _name || 'Unknown',
            )
          }
          if (
            typeof type.getDefaultProps === 'function' &&
            !type.getDefaultProps.isReactClassApproved
          ) {
            error(
              'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.',
            )
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props)
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i]
            if (key !== 'children' && key !== 'key') {
              setCurrentlyValidatingElement$1(fragment)
              error(
                'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
                key,
              )
              setCurrentlyValidatingElement$1(null)
              break
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment)
            error('Invalid attribute `ref` supplied to `React.Fragment`.')
            setCurrentlyValidatingElement$1(null)
          }
        }
      }
      function jsxWithValidation(
        type,
        props,
        key,
        isStaticChildren,
        source,
        self2,
      ) {
        {
          var validType = isValidElementType(type)
          if (!validType) {
            var info = ''
            if (
              type === void 0 ||
              (typeof type === 'object' &&
                type !== null &&
                Object.keys(type).length === 0)
            ) {
              info +=
                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."
            }
            var sourceInfo = getSourceInfoErrorAddendum()
            if (sourceInfo) {
              info += sourceInfo
            } else {
              info += getDeclarationErrorAddendum()
            }
            var typeString
            if (type === null) {
              typeString = 'null'
            } else if (isArray2(type)) {
              typeString = 'array'
            } else if (
              type !== void 0 &&
              type.$$typeof === REACT_ELEMENT_TYPE
            ) {
              typeString =
                '<' + (getComponentNameFromType(type.type) || 'Unknown') + ' />'
              info =
                ' Did you accidentally export a JSX literal instead of a component?'
            } else {
              typeString = typeof type
            }
            error(
              'React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
              typeString,
              info,
            )
          }
          var element = jsxDEV(type, props, key, source, self2)
          if (element == null) {
            return element
          }
          if (validType) {
            var children = props.children
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray2(children)) {
                  for (var i = 0; i < children.length; i++) {
                    validateChildKeys(children[i], type)
                  }
                  if (Object.freeze) {
                    Object.freeze(children)
                  }
                } else {
                  error(
                    'React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.',
                  )
                }
              } else {
                validateChildKeys(children, type)
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element)
          } else {
            validatePropTypes(element)
          }
          return element
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true)
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false)
        }
      }
      var jsx = jsxWithValidationDynamic
      var jsxs = jsxWithValidationStatic
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE
      reactJsxRuntime_development.jsx = jsx
      reactJsxRuntime_development.jsxs = jsxs
    })()
  }
  return reactJsxRuntime_development
}
var hasRequiredJsxRuntime
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports
  hasRequiredJsxRuntime = 1
  if (process.env.NODE_ENV === 'production') {
    jsxRuntime.exports = requireReactJsxRuntime_production_min()
  } else {
    jsxRuntime.exports = requireReactJsxRuntime_development()
  }
  return jsxRuntime.exports
}
var jsxRuntimeExports = requireJsxRuntime()
var lodash_kebabcase
var hasRequiredLodash_kebabcase
function requireLodash_kebabcase() {
  if (hasRequiredLodash_kebabcase) return lodash_kebabcase
  hasRequiredLodash_kebabcase = 1
  var symbolTag = '[object Symbol]'
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g
  var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange =
      ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange =
      rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange
  var rsApos = "[']",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc =
      '[^' +
      rsAstralRange +
      rsBreakRange +
      rsDigits +
      rsDingbatRange +
      rsLowerRange +
      rsUpperRange +
      ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d'
  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin =
      '(?:' +
      rsZWJ +
      '(?:' +
      [rsNonAstral, rsRegional, rsSurrPair].join('|') +
      ')' +
      rsOptVar +
      reOptMod +
      ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji =
      '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq
  var reApos = RegExp(rsApos, 'g')
  var reComboMark = RegExp(rsCombo, 'g')
  var reUnicodeWord = RegExp(
    [
      rsUpper +
        '?' +
        rsLower +
        '+' +
        rsOptLowerContr +
        '(?=' +
        [rsBreak, rsUpper, '$'].join('|') +
        ')',
      rsUpperMisc +
        '+' +
        rsOptUpperContr +
        '(?=' +
        [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') +
        ')',
      rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
      rsUpper + '+' + rsOptUpperContr,
      rsDigits,
      rsEmoji,
    ].join('|'),
    'g',
  )
  var reHasUnicodeWord =
    /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/
  var deburredLetters = {
    // Latin-1 Supplement block.
    : 'A',
    : 'A',
    : 'A',
    : 'A',
    : 'A',
    : 'A',
    : 'a',
    : 'a',
    : 'a',
    : 'a',
    : 'a',
    : 'a',
    : 'C',
    : 'c',
    : 'D',
    : 'd',
    : 'E',
    : 'E',
    : 'E',
    : 'E',
    : 'e',
    : 'e',
    : 'e',
    : 'e',
    : 'I',
    : 'I',
    : 'I',
    : 'I',
    : 'i',
    : 'i',
    : 'i',
    : 'i',
    : 'N',
    : 'n',
    : 'O',
    : 'O',
    : 'O',
    : 'O',
    : 'O',
    : 'O',
    : 'o',
    : 'o',
    : 'o',
    : 'o',
    : 'o',
    : 'o',
    : 'U',
    : 'U',
    : 'U',
    : 'U',
    : 'u',
    : 'u',
    : 'u',
    : 'u',
    : 'Y',
    : 'y',
    : 'y',
    : 'Ae',
    : 'ae',
    : 'Th',
    : 'th',
    : 'ss',
    // Latin Extended-A block.
    : 'A',
    : 'A',
    : 'A',
    : 'a',
    : 'a',
    : 'a',
    : 'C',
    : 'C',
    : 'C',
    : 'C',
    : 'c',
    : 'c',
    : 'c',
    : 'c',
    : 'D',
    : 'D',
    : 'd',
    : 'd',
    : 'E',
    : 'E',
    : 'E',
    : 'E',
    : 'E',
    : 'e',
    : 'e',
    : 'e',
    : 'e',
    : 'e',
    : 'G',
    : 'G',
    : 'G',
    : 'G',
    : 'g',
    : 'g',
    : 'g',
    : 'g',
    : 'H',
    : 'H',
    : 'h',
    : 'h',
    : 'I',
    : 'I',
    : 'I',
    : 'I',
    : 'I',
    : 'i',
    : 'i',
    : 'i',
    : 'i',
    : 'i',
    : 'J',
    : 'j',
    : 'K',
    : 'k',
    : 'k',
    : 'L',
    : 'L',
    : 'L',
    : 'L',
    : 'L',
    : 'l',
    : 'l',
    : 'l',
    : 'l',
    : 'l',
    : 'N',
    : 'N',
    : 'N',
    : 'N',
    : 'n',
    : 'n',
    : 'n',
    : 'n',
    : 'O',
    : 'O',
    : 'O',
    : 'o',
    : 'o',
    : 'o',
    : 'R',
    : 'R',
    : 'R',
    : 'r',
    : 'r',
    : 'r',
    : 'S',
    : 'S',
    : 'S',
    : 'S',
    : 's',
    : 's',
    : 's',
    : 's',
    : 'T',
    : 'T',
    : 'T',
    : 't',
    : 't',
    : 't',
    : 'U',
    : 'U',
    : 'U',
    : 'U',
    : 'U',
    : 'U',
    : 'u',
    : 'u',
    : 'u',
    : 'u',
    : 'u',
    : 'u',
    : 'W',
    : 'w',
    : 'Y',
    : 'y',
    : 'Y',
    : 'Z',
    : 'Z',
    : 'Z',
    : 'z',
    : 'z',
    : 'z',
    : 'IJ',
    : 'ij',
    : 'Oe',
    : 'oe',
    : "'n",
    : 'ss',
  }
  var freeGlobal =
    typeof commonjsGlobal == 'object' &&
    commonjsGlobal &&
    commonjsGlobal.Object === Object &&
    commonjsGlobal
  var freeSelf =
    typeof self == 'object' && self && self.Object === Object && self
  var root = freeGlobal || freeSelf || Function('return this')()
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
      length = array ? array.length : 0
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array)
    }
    return accumulator
  }
  function asciiWords(string) {
    return string.match(reAsciiWord) || []
  }
  function basePropertyOf(object) {
    return function (key) {
      return object == null ? void 0 : object[key]
    }
  }
  var deburrLetter = basePropertyOf(deburredLetters)
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string)
  }
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || []
  }
  var objectProto = Object.prototype
  var objectToString = objectProto.toString
  var Symbol2 = root.Symbol
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0,
    symbolToString = symbolProto ? symbolProto.toString : void 0
  function baseToString(value) {
    if (typeof value == 'string') {
      return value
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : ''
    }
    var result = value + ''
    return result == '0' && 1 / value == -Infinity ? '-0' : result
  }
  function createCompounder(callback) {
    return function (string) {
      return arrayReduce(
        words(deburr(string).replace(reApos, '')),
        callback,
        '',
      )
    }
  }
  function isObjectLike(value) {
    return !!value && typeof value == 'object'
  }
  function isSymbol(value) {
    return (
      typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag)
    )
  }
  function toString(value) {
    return value == null ? '' : baseToString(value)
  }
  function deburr(string) {
    string = toString(string)
    return (
      string && string.replace(reLatin, deburrLetter).replace(reComboMark, '')
    )
  }
  var kebabCase2 = createCompounder(function (result, word, index) {
    return result + (index ? '-' : '') + word.toLowerCase()
  })
  function words(string, pattern, guard) {
    string = toString(string)
    pattern = pattern
    if (pattern === void 0) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string)
    }
    return string.match(pattern) || []
  }
  lodash_kebabcase = kebabCase2
  return lodash_kebabcase
}
var lodash_kebabcaseExports = requireLodash_kebabcase()
const kebabCase = /* @__PURE__ */ getDefaultExportFromCjs(
  lodash_kebabcaseExports,
)
const DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML'
function convertPropsToMjmlAttributes(props) {
  const mjmlProps = Object.entries(props).reduce(
    (mjmlProps2, [prop, value]) => {
      const mjmlProp =
        prop === DANGEROUSLY_SET_INNER_HTML ? prop : kebabCase(prop)
      const mjmlValue = convertPropValueToMjml(mjmlProp, value)
      if (mjmlValue === void 0 || prop === 'className') {
        return mjmlProps2
      }
      if (prop === 'mjmlClass') {
        mjmlProps2['mj-class'] = mjmlValue
      } else {
        mjmlProps2[mjmlProp] = mjmlValue
      }
      return mjmlProps2
    },
    {},
  )
  const className = props.className
  if (typeof className === 'string') {
    mjmlProps['css-class'] =
      typeof mjmlProps['css-class'] === 'string'
        ? joinClassNames(mjmlProps['css-class'], className)
        : className
  }
  return mjmlProps
}
const booleanToString = ['inline', 'full-width']
const numberToPixel = [
  'width',
  'height',
  'border-radius',
  'border-width',
  'background-size',
  'padding',
  'padding-top',
  'padding-right',
  'padding-bottom',
  'padding-left',
  'font-size',
  'letter-spacing',
  'line-height',
  'icon-padding',
  'text-padding',
]
function convertPropValueToMjml(name, value) {
  if (typeof value === 'number' && numberToPixel.includes(name)) {
    return `${value}px`
  }
  if (typeof value === 'boolean' && booleanToString.includes(name)) {
    return name
  }
  if (typeof value === 'object' && value !== null) {
    return value
  }
  if (typeof value === 'string') {
    return value
  }
  return
}
function joinClassNames(...classNames) {
  return classNames.join(' ').trim()
}
var reactExports = requireReact()
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports)
function Mjml({children, ...props}) {
  return React.createElement(
    'mjml',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlBody({children, ...props}) {
  return React.createElement(
    'mj-body',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlHead({children, ...props}) {
  return React.createElement(
    'mj-head',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlPreview({children, ...props}) {
  return React.createElement(
    'mj-preview',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlTitle({children, ...props}) {
  return React.createElement(
    'mj-title',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlButton({children, ...props}) {
  return React.createElement(
    'mj-button',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlColumn({children, ...props}) {
  return React.createElement(
    'mj-column',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlGroup({children, ...props}) {
  return React.createElement(
    'mj-group',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlImage(props) {
  return React.createElement('mj-image', convertPropsToMjmlAttributes(props))
}
function MjmlRaw({children, ...props}) {
  return React.createElement(
    'mj-raw',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlSection({children, ...props}) {
  return React.createElement(
    'mj-section',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
function MjmlText({children, ...props}) {
  return React.createElement(
    'mj-text',
    convertPropsToMjmlAttributes(props),
    children,
  )
}
var renderToMjml = {}
var server_browser = {}
var reactDomServerLegacy_browser_production_min = {}
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServerLegacy_browser_production_min
function requireReactDomServerLegacy_browser_production_min() {
  if (hasRequiredReactDomServerLegacy_browser_production_min)
    return reactDomServerLegacy_browser_production_min
  hasRequiredReactDomServerLegacy_browser_production_min = 1
  var aa = requireReact()
  function l(a) {
    for (
      var b = 'https://reactjs.org/docs/error-decoder.html?invariant=' + a,
        c = 1;
      c < arguments.length;
      c++
    )
      b += '&args[]=' + encodeURIComponent(arguments[c])
    return (
      'Minified React error #' +
      a +
      '; visit ' +
      b +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  var p = Object.prototype.hasOwnProperty,
    fa =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    ha = {},
    ia = {}
  function ja(a) {
    if (p.call(ia, a)) return true
    if (p.call(ha, a)) return false
    if (fa.test(a)) return (ia[a] = true)
    ha[a] = true
    return false
  }
  function r(a, b, c, d, f, e, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b
    this.attributeName = d
    this.attributeNamespace = f
    this.mustUseProperty = c
    this.propertyName = a
    this.type = b
    this.sanitizeURL = e
    this.removeEmptyString = g
  }
  var t = {}
  'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
    .split(' ')
    .forEach(function (a) {
      t[a] = new r(a, 0, false, a, null, false, false)
    })
  ;[
    ['acceptCharset', 'accept-charset'],
    ['className', 'class'],
    ['htmlFor', 'for'],
    ['httpEquiv', 'http-equiv'],
  ].forEach(function (a) {
    var b = a[0]
    t[b] = new r(b, 1, false, a[1], null, false, false)
  })
  ;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(
    function (a) {
      t[a] = new r(a, 2, false, a.toLowerCase(), null, false, false)
    },
  )
  ;[
    'autoReverse',
    'externalResourcesRequired',
    'focusable',
    'preserveAlpha',
  ].forEach(function (a) {
    t[a] = new r(a, 2, false, a, null, false, false)
  })
  'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
    .split(' ')
    .forEach(function (a) {
      t[a] = new r(a, 3, false, a.toLowerCase(), null, false, false)
    })
  ;['checked', 'multiple', 'muted', 'selected'].forEach(function (a) {
    t[a] = new r(a, 3, true, a, null, false, false)
  })
  ;['capture', 'download'].forEach(function (a) {
    t[a] = new r(a, 4, false, a, null, false, false)
  })
  ;['cols', 'rows', 'size', 'span'].forEach(function (a) {
    t[a] = new r(a, 6, false, a, null, false, false)
  })
  ;['rowSpan', 'start'].forEach(function (a) {
    t[a] = new r(a, 5, false, a.toLowerCase(), null, false, false)
  })
  var ka = /[\-:]([a-z])/g
  function la(a) {
    return a[1].toUpperCase()
  }
  'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
    .split(' ')
    .forEach(function (a) {
      var b = a.replace(ka, la)
      t[b] = new r(b, 1, false, a, null, false, false)
    })
  'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
    .split(' ')
    .forEach(function (a) {
      var b = a.replace(ka, la)
      t[b] = new r(b, 1, false, a, 'http://www.w3.org/1999/xlink', false, false)
    })
  ;['xml:base', 'xml:lang', 'xml:space'].forEach(function (a) {
    var b = a.replace(ka, la)
    t[b] = new r(
      b,
      1,
      false,
      a,
      'http://www.w3.org/XML/1998/namespace',
      false,
      false,
    )
  })
  ;['tabIndex', 'crossOrigin'].forEach(function (a) {
    t[a] = new r(a, 1, false, a.toLowerCase(), null, false, false)
  })
  t.xlinkHref = new r(
    'xlinkHref',
    1,
    false,
    'xlink:href',
    'http://www.w3.org/1999/xlink',
    true,
    false,
  )
  ;['src', 'href', 'action', 'formAction'].forEach(function (a) {
    t[a] = new r(a, 1, false, a.toLowerCase(), null, true, true)
  })
  var u = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true,
    },
    ma = ['Webkit', 'ms', 'Moz', 'O']
  Object.keys(u).forEach(function (a) {
    ma.forEach(function (b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1)
      u[b] = u[a]
    })
  })
  var na = /["'&<>]/
  function v(a) {
    if ('boolean' === typeof a || 'number' === typeof a) return '' + a
    a = '' + a
    var b = na.exec(a)
    if (b) {
      var c = '',
        d,
        f = 0
      for (d = b.index; d < a.length; d++) {
        switch (a.charCodeAt(d)) {
          case 34:
            b = '&quot;'
            break
          case 38:
            b = '&amp;'
            break
          case 39:
            b = '&#x27;'
            break
          case 60:
            b = '&lt;'
            break
          case 62:
            b = '&gt;'
            break
          default:
            continue
        }
        f !== d && (c += a.substring(f, d))
        f = d + 1
        c += b
      }
      a = f !== d ? c + a.substring(f, d) : c
    }
    return a
  }
  var oa = /([A-Z])/g,
    pa = /^ms-/,
    qa = Array.isArray
  function w(a, b) {
    return {insertionMode: a, selectedValue: b}
  }
  function ra(a, b, c) {
    switch (b) {
      case 'select':
        return w(1, null != c.value ? c.value : c.defaultValue)
      case 'svg':
        return w(2, null)
      case 'math':
        return w(3, null)
      case 'foreignObject':
        return w(1, null)
      case 'table':
        return w(4, null)
      case 'thead':
      case 'tbody':
      case 'tfoot':
        return w(5, null)
      case 'colgroup':
        return w(7, null)
      case 'tr':
        return w(6, null)
    }
    return 4 <= a.insertionMode || 0 === a.insertionMode ? w(1, null) : a
  }
  var sa = /* @__PURE__ */ new Map()
  function ta(a, b, c) {
    if ('object' !== typeof c) throw Error(l(62))
    b = true
    for (var d in c)
      if (p.call(c, d)) {
        var f = c[d]
        if (null != f && 'boolean' !== typeof f && '' !== f) {
          if (0 === d.indexOf('--')) {
            var e = v(d)
            f = v(('' + f).trim())
          } else {
            e = d
            var g = sa.get(e)
            void 0 !== g
              ? (e = g)
              : ((g = v(
                  e.replace(oa, '-$1').toLowerCase().replace(pa, '-ms-'),
                )),
                sa.set(e, g),
                (e = g))
            f =
              'number' === typeof f
                ? 0 === f || p.call(u, d)
                  ? '' + f
                  : f + 'px'
                : v(('' + f).trim())
          }
          b
            ? ((b = false), a.push(' style="', e, ':', f))
            : a.push(';', e, ':', f)
        }
      }
    b || a.push('"')
  }
  function x(a, b, c, d) {
    switch (c) {
      case 'style':
        ta(a, b, d)
        return
      case 'defaultValue':
      case 'defaultChecked':
      case 'innerHTML':
      case 'suppressContentEditableWarning':
      case 'suppressHydrationWarning':
        return
    }
    if (
      !(2 < c.length) ||
      ('o' !== c[0] && 'O' !== c[0]) ||
      ('n' !== c[1] && 'N' !== c[1])
    ) {
      if (((b = t.hasOwnProperty(c) ? t[c] : null), null !== b)) {
        switch (typeof d) {
          case 'function':
          case 'symbol':
            return
          case 'boolean':
            if (!b.acceptsBooleans) return
        }
        c = b.attributeName
        switch (b.type) {
          case 3:
            d && a.push(' ', c, '=""')
            break
          case 4:
            true === d
              ? a.push(' ', c, '=""')
              : false !== d && a.push(' ', c, '="', v(d), '"')
            break
          case 5:
            isNaN(d) || a.push(' ', c, '="', v(d), '"')
            break
          case 6:
            !isNaN(d) && 1 <= d && a.push(' ', c, '="', v(d), '"')
            break
          default:
            b.sanitizeURL && (d = '' + d), a.push(' ', c, '="', v(d), '"')
        }
      } else if (ja(c)) {
        switch (typeof d) {
          case 'function':
          case 'symbol':
            return
          case 'boolean':
            if (
              ((b = c.toLowerCase().slice(0, 5)),
              'data-' !== b && 'aria-' !== b)
            )
              return
        }
        a.push(' ', c, '="', v(d), '"')
      }
    }
  }
  function y(a, b, c) {
    if (null != b) {
      if (null != c) throw Error(l(60))
      if ('object' !== typeof b || !('__html' in b)) throw Error(l(61))
      b = b.__html
      null !== b && void 0 !== b && a.push('' + b)
    }
  }
  function ua(a) {
    var b = ''
    aa.Children.forEach(a, function (a2) {
      null != a2 && (b += a2)
    })
    return b
  }
  function va(a, b, c, d) {
    a.push(A(c))
    var f = (c = null),
      e
    for (e in b)
      if (p.call(b, e)) {
        var g = b[e]
        if (null != g)
          switch (e) {
            case 'children':
              c = g
              break
            case 'dangerouslySetInnerHTML':
              f = g
              break
            default:
              x(a, d, e, g)
          }
      }
    a.push('>')
    y(a, f, c)
    return 'string' === typeof c ? (a.push(v(c)), null) : c
  }
  var wa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    xa = /* @__PURE__ */ new Map()
  function A(a) {
    var b = xa.get(a)
    if (void 0 === b) {
      if (!wa.test(a)) throw Error(l(65, a))
      b = '<' + a
      xa.set(a, b)
    }
    return b
  }
  function ya(a, b, c, d, f) {
    switch (b) {
      case 'select':
        a.push(A('select'))
        var e = null,
          g = null
        for (n in c)
          if (p.call(c, n)) {
            var h = c[n]
            if (null != h)
              switch (n) {
                case 'children':
                  e = h
                  break
                case 'dangerouslySetInnerHTML':
                  g = h
                  break
                case 'defaultValue':
                case 'value':
                  break
                default:
                  x(a, d, n, h)
              }
          }
        a.push('>')
        y(a, g, e)
        return e
      case 'option':
        g = f.selectedValue
        a.push(A('option'))
        var k = (h = null),
          m = null
        var n = null
        for (e in c)
          if (p.call(c, e)) {
            var q = c[e]
            if (null != q)
              switch (e) {
                case 'children':
                  h = q
                  break
                case 'selected':
                  m = q
                  break
                case 'dangerouslySetInnerHTML':
                  n = q
                  break
                case 'value':
                  k = q
                default:
                  x(a, d, e, q)
              }
          }
        if (null != g)
          if (((c = null !== k ? '' + k : ua(h)), qa(g)))
            for (d = 0; d < g.length; d++) {
              if ('' + g[d] === c) {
                a.push(' selected=""')
                break
              }
            }
          else '' + g === c && a.push(' selected=""')
        else m && a.push(' selected=""')
        a.push('>')
        y(a, n, h)
        return h
      case 'textarea':
        a.push(A('textarea'))
        n = g = e = null
        for (h in c)
          if (p.call(c, h) && ((k = c[h]), null != k))
            switch (h) {
              case 'children':
                n = k
                break
              case 'value':
                e = k
                break
              case 'defaultValue':
                g = k
                break
              case 'dangerouslySetInnerHTML':
                throw Error(l(91))
              default:
                x(a, d, h, k)
            }
        null === e && null !== g && (e = g)
        a.push('>')
        if (null != n) {
          if (null != e) throw Error(l(92))
          if (qa(n) && 1 < n.length) throw Error(l(93))
          e = '' + n
        }
        'string' === typeof e && '\n' === e[0] && a.push('\n')
        null !== e && a.push(v('' + e))
        return null
      case 'input':
        a.push(A('input'))
        k = n = h = e = null
        for (g in c)
          if (p.call(c, g) && ((m = c[g]), null != m))
            switch (g) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(l(399, 'input'))
              case 'defaultChecked':
                k = m
                break
              case 'defaultValue':
                h = m
                break
              case 'checked':
                n = m
                break
              case 'value':
                e = m
                break
              default:
                x(a, d, g, m)
            }
        null !== n ? x(a, d, 'checked', n) : null !== k && x(a, d, 'checked', k)
        null !== e ? x(a, d, 'value', e) : null !== h && x(a, d, 'value', h)
        a.push('/>')
        return null
      case 'menuitem':
        a.push(A('menuitem'))
        for (var C in c)
          if (p.call(c, C) && ((e = c[C]), null != e))
            switch (C) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(l(400))
              default:
                x(a, d, C, e)
            }
        a.push('>')
        return null
      case 'title':
        a.push(A('title'))
        e = null
        for (q in c)
          if (p.call(c, q) && ((g = c[q]), null != g))
            switch (q) {
              case 'children':
                e = g
                break
              case 'dangerouslySetInnerHTML':
                throw Error(l(434))
              default:
                x(a, d, q, g)
            }
        a.push('>')
        return e
      case 'listing':
      case 'pre':
        a.push(A(b))
        g = e = null
        for (k in c)
          if (p.call(c, k) && ((h = c[k]), null != h))
            switch (k) {
              case 'children':
                e = h
                break
              case 'dangerouslySetInnerHTML':
                g = h
                break
              default:
                x(a, d, k, h)
            }
        a.push('>')
        if (null != g) {
          if (null != e) throw Error(l(60))
          if ('object' !== typeof g || !('__html' in g)) throw Error(l(61))
          c = g.__html
          null !== c &&
            void 0 !== c &&
            ('string' === typeof c && 0 < c.length && '\n' === c[0]
              ? a.push('\n', c)
              : a.push('' + c))
        }
        'string' === typeof e && '\n' === e[0] && a.push('\n')
        return e
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'img':
      case 'keygen':
      case 'link':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
        a.push(A(b))
        for (var D in c)
          if (p.call(c, D) && ((e = c[D]), null != e))
            switch (D) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(l(399, b))
              default:
                x(a, d, D, e)
            }
        a.push('/>')
        return null
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return va(a, c, b, d)
      case 'html':
        return (
          0 === f.insertionMode && a.push('<!DOCTYPE html>'), va(a, c, b, d)
        )
      default:
        if (-1 === b.indexOf('-') && 'string' !== typeof c.is)
          return va(a, c, b, d)
        a.push(A(b))
        g = e = null
        for (m in c)
          if (p.call(c, m) && ((h = c[m]), null != h))
            switch (m) {
              case 'children':
                e = h
                break
              case 'dangerouslySetInnerHTML':
                g = h
                break
              case 'style':
                ta(a, d, h)
                break
              case 'suppressContentEditableWarning':
              case 'suppressHydrationWarning':
                break
              default:
                ja(m) &&
                  'function' !== typeof h &&
                  'symbol' !== typeof h &&
                  a.push(' ', m, '="', v(h), '"')
            }
        a.push('>')
        y(a, g, e)
        return e
    }
  }
  function za(a, b, c) {
    a.push('<!--$?--><template id="')
    if (null === c) throw Error(l(395))
    a.push(c)
    return a.push('"></template>')
  }
  function Aa(a, b, c, d) {
    switch (c.insertionMode) {
      case 0:
      case 1:
        return (
          a.push('<div hidden id="'),
          a.push(b.segmentPrefix),
          (b = d.toString(16)),
          a.push(b),
          a.push('">')
        )
      case 2:
        return (
          a.push('<svg aria-hidden="true" style="display:none" id="'),
          a.push(b.segmentPrefix),
          (b = d.toString(16)),
          a.push(b),
          a.push('">')
        )
      case 3:
        return (
          a.push('<math aria-hidden="true" style="display:none" id="'),
          a.push(b.segmentPrefix),
          (b = d.toString(16)),
          a.push(b),
          a.push('">')
        )
      case 4:
        return (
          a.push('<table hidden id="'),
          a.push(b.segmentPrefix),
          (b = d.toString(16)),
          a.push(b),
          a.push('">')
        )
      case 5:
        return (
          a.push('<table hidden><tbody id="'),
          a.push(b.segmentPrefix),
          (b = d.toString(16)),
          a.push(b),
          a.push('">')
        )
      case 6:
        return (
          a.push('<table hidden><tr id="'),
          a.push(b.segmentPrefix),
          (b = d.toString(16)),
          a.push(b),
          a.push('">')
        )
      case 7:
        return (
          a.push('<table hidden><colgroup id="'),
          a.push(b.segmentPrefix),
          (b = d.toString(16)),
          a.push(b),
          a.push('">')
        )
      default:
        throw Error(l(397))
    }
  }
  function Ba(a, b) {
    switch (b.insertionMode) {
      case 0:
      case 1:
        return a.push('</div>')
      case 2:
        return a.push('</svg>')
      case 3:
        return a.push('</math>')
      case 4:
        return a.push('</table>')
      case 5:
        return a.push('</tbody></table>')
      case 6:
        return a.push('</tr></table>')
      case 7:
        return a.push('</colgroup></table>')
      default:
        throw Error(l(397))
    }
  }
  var Ca = /[<\u2028\u2029]/g
  function Da(a) {
    return JSON.stringify(a).replace(Ca, function (a2) {
      switch (a2) {
        case '<':
          return '\\u003c'
        case '\u2028':
          return '\\u2028'
        case '\u2029':
          return '\\u2029'
        default:
          throw Error(
            'escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React',
          )
      }
    })
  }
  function Ea(a, b) {
    b = void 0 === b ? '' : b
    return {
      bootstrapChunks: [],
      startInlineScript: '<script>',
      placeholderPrefix: b + 'P:',
      segmentPrefix: b + 'S:',
      boundaryPrefix: b + 'B:',
      idPrefix: b,
      nextSuspenseID: 0,
      sentCompleteSegmentFunction: false,
      sentCompleteBoundaryFunction: false,
      sentClientRenderFunction: false,
      generateStaticMarkup: a,
    }
  }
  function Fa(a, b, c, d) {
    if (c.generateStaticMarkup) return a.push(v(b)), false
    '' === b ? (a = d) : (d && a.push('<!-- -->'), a.push(v(b)), (a = true))
    return a
  }
  var B = Object.assign,
    Ga = Symbol.for('react.element'),
    Ha = Symbol.for('react.portal'),
    Ia = Symbol.for('react.fragment'),
    Ja = Symbol.for('react.strict_mode'),
    Ka = Symbol.for('react.profiler'),
    La = Symbol.for('react.provider'),
    Ma = Symbol.for('react.context'),
    Na = Symbol.for('react.forward_ref'),
    Oa = Symbol.for('react.suspense'),
    Pa = Symbol.for('react.suspense_list'),
    Qa = Symbol.for('react.memo'),
    Ra = Symbol.for('react.lazy'),
    Sa = Symbol.for('react.scope'),
    Ta = Symbol.for('react.debug_trace_mode'),
    Ua = Symbol.for('react.legacy_hidden'),
    Va = Symbol.for('react.default_value'),
    Wa = Symbol.iterator
  function Xa(a) {
    if (null == a) return null
    if ('function' === typeof a) return a.displayName || a.name || null
    if ('string' === typeof a) return a
    switch (a) {
      case Ia:
        return 'Fragment'
      case Ha:
        return 'Portal'
      case Ka:
        return 'Profiler'
      case Ja:
        return 'StrictMode'
      case Oa:
        return 'Suspense'
      case Pa:
        return 'SuspenseList'
    }
    if ('object' === typeof a)
      switch (a.$$typeof) {
        case Ma:
          return (a.displayName || 'Context') + '.Consumer'
        case La:
          return (a._context.displayName || 'Context') + '.Provider'
        case Na:
          var b = a.render
          a = a.displayName
          a ||
            ((a = b.displayName || b.name || ''),
            (a = '' !== a ? 'ForwardRef(' + a + ')' : 'ForwardRef'))
          return a
        case Qa:
          return (
            (b = a.displayName || null), null !== b ? b : Xa(a.type) || 'Memo'
          )
        case Ra:
          b = a._payload
          a = a._init
          try {
            return Xa(a(b))
          } catch (c) {}
      }
    return null
  }
  var Ya = {}
  function Za(a, b) {
    a = a.contextTypes
    if (!a) return Ya
    var c = {},
      d
    for (d in a) c[d] = b[d]
    return c
  }
  var E = null
  function F(a, b) {
    if (a !== b) {
      a.context._currentValue2 = a.parentValue
      a = a.parent
      var c = b.parent
      if (null === a) {
        if (null !== c) throw Error(l(401))
      } else {
        if (null === c) throw Error(l(401))
        F(a, c)
      }
      b.context._currentValue2 = b.value
    }
  }
  function $a(a) {
    a.context._currentValue2 = a.parentValue
    a = a.parent
    null !== a && $a(a)
  }
  function ab(a) {
    var b = a.parent
    null !== b && ab(b)
    a.context._currentValue2 = a.value
  }
  function bb(a, b) {
    a.context._currentValue2 = a.parentValue
    a = a.parent
    if (null === a) throw Error(l(402))
    a.depth === b.depth ? F(a, b) : bb(a, b)
  }
  function cb(a, b) {
    var c = b.parent
    if (null === c) throw Error(l(402))
    a.depth === c.depth ? F(a, c) : cb(a, c)
    b.context._currentValue2 = b.value
  }
  function G(a) {
    var b = E
    b !== a &&
      (null === b
        ? ab(a)
        : null === a
        ? $a(b)
        : b.depth === a.depth
        ? F(b, a)
        : b.depth > a.depth
        ? bb(b, a)
        : cb(b, a),
      (E = a))
  }
  var db2 = {
    isMounted: function () {
      return false
    },
    enqueueSetState: function (a, b) {
      a = a._reactInternals
      null !== a.queue && a.queue.push(b)
    },
    enqueueReplaceState: function (a, b) {
      a = a._reactInternals
      a.replace = true
      a.queue = [b]
    },
    enqueueForceUpdate: function () {},
  }
  function eb(a, b, c, d) {
    var f = void 0 !== a.state ? a.state : null
    a.updater = db2
    a.props = c
    a.state = f
    var e = {queue: [], replace: false}
    a._reactInternals = e
    var g = b.contextType
    a.context = 'object' === typeof g && null !== g ? g._currentValue2 : d
    g = b.getDerivedStateFromProps
    'function' === typeof g &&
      ((g = g(c, f)),
      (f = null === g || void 0 === g ? f : B({}, f, g)),
      (a.state = f))
    if (
      'function' !== typeof b.getDerivedStateFromProps &&
      'function' !== typeof a.getSnapshotBeforeUpdate &&
      ('function' === typeof a.UNSAFE_componentWillMount ||
        'function' === typeof a.componentWillMount)
    )
      if (
        ((b = a.state),
        'function' === typeof a.componentWillMount && a.componentWillMount(),
        'function' === typeof a.UNSAFE_componentWillMount &&
          a.UNSAFE_componentWillMount(),
        b !== a.state && db2.enqueueReplaceState(a, a.state, null),
        null !== e.queue && 0 < e.queue.length)
      )
        if (
          ((b = e.queue),
          (g = e.replace),
          (e.queue = null),
          (e.replace = false),
          g && 1 === b.length)
        )
          a.state = b[0]
        else {
          e = g ? b[0] : a.state
          f = true
          for (g = g ? 1 : 0; g < b.length; g++) {
            var h = b[g]
            h = 'function' === typeof h ? h.call(a, e, c, d) : h
            null != h && (f ? ((f = false), (e = B({}, e, h))) : B(e, h))
          }
          a.state = e
        }
      else e.queue = null
  }
  var fb = {id: 1, overflow: ''}
  function gb(a, b, c) {
    var d = a.id
    a = a.overflow
    var f = 32 - H(d) - 1
    d &= ~(1 << f)
    c += 1
    var e = 32 - H(b) + f
    if (30 < e) {
      var g = f - (f % 5)
      e = (d & ((1 << g) - 1)).toString(32)
      d >>= g
      f -= g
      return {id: (1 << (32 - H(b) + f)) | (c << f) | d, overflow: e + a}
    }
    return {id: (1 << e) | (c << f) | d, overflow: a}
  }
  var H = Math.clz32 ? Math.clz32 : hb,
    ib = Math.log,
    jb = Math.LN2
  function hb(a) {
    a >>>= 0
    return 0 === a ? 32 : (31 - ((ib(a) / jb) | 0)) | 0
  }
  function kb(a, b) {
    return (a === b && (0 !== a || 1 / a === 1 / b)) || (a !== a && b !== b)
  }
  var lb = 'function' === typeof Object.is ? Object.is : kb,
    I = null,
    ob = null,
    J = null,
    K = null,
    L = false,
    M = false,
    N = 0,
    O = null,
    P = 0
  function Q() {
    if (null === I) throw Error(l(321))
    return I
  }
  function pb() {
    if (0 < P) throw Error(l(312))
    return {memoizedState: null, queue: null, next: null}
  }
  function qb() {
    null === K
      ? null === J
        ? ((L = false), (J = K = pb()))
        : ((L = true), (K = J))
      : null === K.next
      ? ((L = false), (K = K.next = pb()))
      : ((L = true), (K = K.next))
    return K
  }
  function rb() {
    ob = I = null
    M = false
    J = null
    P = 0
    K = O = null
  }
  function sb(a, b) {
    return 'function' === typeof b ? b(a) : b
  }
  function tb(a, b, c) {
    I = Q()
    K = qb()
    if (L) {
      var d = K.queue
      b = d.dispatch
      if (null !== O && ((c = O.get(d)), void 0 !== c)) {
        O.delete(d)
        d = K.memoizedState
        do (d = a(d, c.action)), (c = c.next)
        while (null !== c)
        K.memoizedState = d
        return [d, b]
      }
      return [K.memoizedState, b]
    }
    a = a === sb ? ('function' === typeof b ? b() : b) : void 0 !== c ? c(b) : b
    K.memoizedState = a
    a = K.queue = {last: null, dispatch: null}
    a = a.dispatch = ub.bind(null, I, a)
    return [K.memoizedState, a]
  }
  function vb(a, b) {
    I = Q()
    K = qb()
    b = void 0 === b ? null : b
    if (null !== K) {
      var c = K.memoizedState
      if (null !== c && null !== b) {
        var d = c[1]
        a: if (null === d) d = false
        else {
          for (var f = 0; f < d.length && f < b.length; f++)
            if (!lb(b[f], d[f])) {
              d = false
              break a
            }
          d = true
        }
        if (d) return c[0]
      }
    }
    a = a()
    K.memoizedState = [a, b]
    return a
  }
  function ub(a, b, c) {
    if (25 <= P) throw Error(l(301))
    if (a === I)
      if (
        ((M = true),
        (a = {action: c, next: null}),
        null === O && (O = /* @__PURE__ */ new Map()),
        (c = O.get(b)),
        void 0 === c)
      )
        O.set(b, a)
      else {
        for (b = c; null !== b.next; ) b = b.next
        b.next = a
      }
  }
  function wb() {
    throw Error(l(394))
  }
  function R() {}
  var xb = {
      readContext: function (a) {
        return a._currentValue2
      },
      useContext: function (a) {
        Q()
        return a._currentValue2
      },
      useMemo: vb,
      useReducer: tb,
      useRef: function (a) {
        I = Q()
        K = qb()
        var b = K.memoizedState
        return null === b ? ((a = {current: a}), (K.memoizedState = a)) : b
      },
      useState: function (a) {
        return tb(sb, a)
      },
      useInsertionEffect: R,
      useLayoutEffect: function () {},
      useCallback: function (a, b) {
        return vb(function () {
          return a
        }, b)
      },
      useImperativeHandle: R,
      useEffect: R,
      useDebugValue: R,
      useDeferredValue: function (a) {
        Q()
        return a
      },
      useTransition: function () {
        Q()
        return [false, wb]
      },
      useId: function () {
        var a = ob.treeContext
        var b = a.overflow
        a = a.id
        a = (a & ~(1 << (32 - H(a) - 1))).toString(32) + b
        var c = S
        if (null === c) throw Error(l(404))
        b = N++
        a = ':' + c.idPrefix + 'R' + a
        0 < b && (a += 'H' + b.toString(32))
        return a + ':'
      },
      useMutableSource: function (a, b) {
        Q()
        return b(a._source)
      },
      useSyncExternalStore: function (a, b, c) {
        if (void 0 === c) throw Error(l(407))
        return c()
      },
    },
    S = null,
    yb =
      aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
        .ReactCurrentDispatcher
  function zb(a) {
    console.error(a)
    return null
  }
  function T() {}
  function Ab(a, b, c, d, f, e, g, h, k) {
    var m = [],
      n = /* @__PURE__ */ new Set()
    b = {
      destination: null,
      responseState: b,
      progressiveChunkSize: void 0 === d ? 12800 : d,
      status: 0,
      fatalError: null,
      nextSegmentId: 0,
      allPendingTasks: 0,
      pendingRootTasks: 0,
      completedRootSegment: null,
      abortableTasks: n,
      pingedTasks: m,
      clientRenderedBoundaries: [],
      completedBoundaries: [],
      partialBoundaries: [],
      onError: void 0 === f ? zb : f,
      onAllReady: T,
      onShellReady: void 0 === g ? T : g,
      onShellError: T,
      onFatalError: T,
    }
    c = U(b, 0, null, c, false, false)
    c.parentFlushed = true
    a = Bb(b, a, null, c, n, Ya, null, fb)
    m.push(a)
    return b
  }
  function Bb(a, b, c, d, f, e, g, h) {
    a.allPendingTasks++
    null === c ? a.pendingRootTasks++ : c.pendingTasks++
    var k = {
      node: b,
      ping: function () {
        var b2 = a.pingedTasks
        b2.push(k)
        1 === b2.length && Cb(a)
      },
      blockedBoundary: c,
      blockedSegment: d,
      abortSet: f,
      legacyContext: e,
      context: g,
      treeContext: h,
    }
    f.add(k)
    return k
  }
  function U(a, b, c, d, f, e) {
    return {
      status: 0,
      id: -1,
      index: b,
      parentFlushed: false,
      chunks: [],
      children: [],
      formatContext: d,
      boundary: c,
      lastPushedText: f,
      textEmbedded: e,
    }
  }
  function V(a, b) {
    a = a.onError(b)
    if (null != a && 'string' !== typeof a)
      throw Error(
        'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
          typeof a +
          '" instead',
      )
    return a
  }
  function W(a, b) {
    var c = a.onShellError
    c(b)
    c = a.onFatalError
    c(b)
    null !== a.destination
      ? ((a.status = 2), a.destination.destroy(b))
      : ((a.status = 1), (a.fatalError = b))
  }
  function Db(a, b, c, d, f) {
    I = {}
    ob = b
    N = 0
    for (a = c(d, f); M; )
      (M = false), (N = 0), (P += 1), (K = null), (a = c(d, f))
    rb()
    return a
  }
  function Eb(a, b, c, d) {
    var f = c.render(),
      e = d.childContextTypes
    if (null !== e && void 0 !== e) {
      var g = b.legacyContext
      if ('function' !== typeof c.getChildContext) d = g
      else {
        c = c.getChildContext()
        for (var h in c)
          if (!(h in e)) throw Error(l(108, Xa(d) || 'Unknown', h))
        d = B({}, g, c)
      }
      b.legacyContext = d
      X(a, b, f)
      b.legacyContext = g
    } else X(a, b, f)
  }
  function Fb(a, b) {
    if (a && a.defaultProps) {
      b = B({}, b)
      a = a.defaultProps
      for (var c in a) void 0 === b[c] && (b[c] = a[c])
      return b
    }
    return b
  }
  function Gb(a, b, c, d, f) {
    if ('function' === typeof c)
      if (c.prototype && c.prototype.isReactComponent) {
        f = Za(c, b.legacyContext)
        var e = c.contextType
        e = new c(d, 'object' === typeof e && null !== e ? e._currentValue2 : f)
        eb(e, c, d, f)
        Eb(a, b, e, c)
      } else {
        e = Za(c, b.legacyContext)
        f = Db(a, b, c, d, e)
        var g = 0 !== N
        if (
          'object' === typeof f &&
          null !== f &&
          'function' === typeof f.render &&
          void 0 === f.$$typeof
        )
          eb(f, c, d, e), Eb(a, b, f, c)
        else if (g) {
          d = b.treeContext
          b.treeContext = gb(d, 1, 0)
          try {
            X(a, b, f)
          } finally {
            b.treeContext = d
          }
        } else X(a, b, f)
      }
    else if ('string' === typeof c) {
      f = b.blockedSegment
      e = ya(f.chunks, c, d, a.responseState, f.formatContext)
      f.lastPushedText = false
      g = f.formatContext
      f.formatContext = ra(g, c, d)
      Hb(a, b, e)
      f.formatContext = g
      switch (c) {
        case 'area':
        case 'base':
        case 'br':
        case 'col':
        case 'embed':
        case 'hr':
        case 'img':
        case 'input':
        case 'keygen':
        case 'link':
        case 'meta':
        case 'param':
        case 'source':
        case 'track':
        case 'wbr':
          break
        default:
          f.chunks.push('</', c, '>')
      }
      f.lastPushedText = false
    } else {
      switch (c) {
        case Ua:
        case Ta:
        case Ja:
        case Ka:
        case Ia:
          X(a, b, d.children)
          return
        case Pa:
          X(a, b, d.children)
          return
        case Sa:
          throw Error(l(343))
        case Oa:
          a: {
            c = b.blockedBoundary
            f = b.blockedSegment
            e = d.fallback
            d = d.children
            g = /* @__PURE__ */ new Set()
            var h = {
                id: null,
                rootSegmentID: -1,
                parentFlushed: false,
                pendingTasks: 0,
                forceClientRender: false,
                completedSegments: [],
                byteSize: 0,
                fallbackAbortableTasks: g,
                errorDigest: null,
              },
              k = U(a, f.chunks.length, h, f.formatContext, false, false)
            f.children.push(k)
            f.lastPushedText = false
            var m = U(a, 0, null, f.formatContext, false, false)
            m.parentFlushed = true
            b.blockedBoundary = h
            b.blockedSegment = m
            try {
              if (
                (Hb(a, b, d),
                a.responseState.generateStaticMarkup ||
                  (m.lastPushedText &&
                    m.textEmbedded &&
                    m.chunks.push('<!-- -->')),
                (m.status = 1),
                Y(h, m),
                0 === h.pendingTasks)
              )
                break a
            } catch (n) {
              ;(m.status = 4),
                (h.forceClientRender = true),
                (h.errorDigest = V(a, n))
            } finally {
              ;(b.blockedBoundary = c), (b.blockedSegment = f)
            }
            b = Bb(a, e, c, k, g, b.legacyContext, b.context, b.treeContext)
            a.pingedTasks.push(b)
          }
          return
      }
      if ('object' === typeof c && null !== c)
        switch (c.$$typeof) {
          case Na:
            d = Db(a, b, c.render, d, f)
            if (0 !== N) {
              c = b.treeContext
              b.treeContext = gb(c, 1, 0)
              try {
                X(a, b, d)
              } finally {
                b.treeContext = c
              }
            } else X(a, b, d)
            return
          case Qa:
            c = c.type
            d = Fb(c, d)
            Gb(a, b, c, d, f)
            return
          case La:
            f = d.children
            c = c._context
            d = d.value
            e = c._currentValue2
            c._currentValue2 = d
            g = E
            E = d = {
              parent: g,
              depth: null === g ? 0 : g.depth + 1,
              context: c,
              parentValue: e,
              value: d,
            }
            b.context = d
            X(a, b, f)
            a = E
            if (null === a) throw Error(l(403))
            d = a.parentValue
            a.context._currentValue2 = d === Va ? a.context._defaultValue : d
            a = E = a.parent
            b.context = a
            return
          case Ma:
            d = d.children
            d = d(c._currentValue2)
            X(a, b, d)
            return
          case Ra:
            f = c._init
            c = f(c._payload)
            d = Fb(c, d)
            Gb(a, b, c, d, void 0)
            return
        }
      throw Error(l(130, null == c ? c : typeof c, ''))
    }
  }
  function X(a, b, c) {
    b.node = c
    if ('object' === typeof c && null !== c) {
      switch (c.$$typeof) {
        case Ga:
          Gb(a, b, c.type, c.props, c.ref)
          return
        case Ha:
          throw Error(l(257))
        case Ra:
          var d = c._init
          c = d(c._payload)
          X(a, b, c)
          return
      }
      if (qa(c)) {
        Ib(a, b, c)
        return
      }
      null === c || 'object' !== typeof c
        ? (d = null)
        : ((d = (Wa && c[Wa]) || c['@@iterator']),
          (d = 'function' === typeof d ? d : null))
      if (d && (d = d.call(c))) {
        c = d.next()
        if (!c.done) {
          var f = []
          do f.push(c.value), (c = d.next())
          while (!c.done)
          Ib(a, b, f)
        }
        return
      }
      a = Object.prototype.toString.call(c)
      throw Error(
        l(
          31,
          '[object Object]' === a
            ? 'object with keys {' + Object.keys(c).join(', ') + '}'
            : a,
        ),
      )
    }
    'string' === typeof c
      ? ((d = b.blockedSegment),
        (d.lastPushedText = Fa(
          b.blockedSegment.chunks,
          c,
          a.responseState,
          d.lastPushedText,
        )))
      : 'number' === typeof c &&
        ((d = b.blockedSegment),
        (d.lastPushedText = Fa(
          b.blockedSegment.chunks,
          '' + c,
          a.responseState,
          d.lastPushedText,
        )))
  }
  function Ib(a, b, c) {
    for (var d = c.length, f = 0; f < d; f++) {
      var e = b.treeContext
      b.treeContext = gb(e, d, f)
      try {
        Hb(a, b, c[f])
      } finally {
        b.treeContext = e
      }
    }
  }
  function Hb(a, b, c) {
    var d = b.blockedSegment.formatContext,
      f = b.legacyContext,
      e = b.context
    try {
      return X(a, b, c)
    } catch (k) {
      if (
        (rb(),
        'object' === typeof k && null !== k && 'function' === typeof k.then)
      ) {
        c = k
        var g = b.blockedSegment,
          h = U(
            a,
            g.chunks.length,
            null,
            g.formatContext,
            g.lastPushedText,
            true,
          )
        g.children.push(h)
        g.lastPushedText = false
        a = Bb(
          a,
          b.node,
          b.blockedBoundary,
          h,
          b.abortSet,
          b.legacyContext,
          b.context,
          b.treeContext,
        ).ping
        c.then(a, a)
        b.blockedSegment.formatContext = d
        b.legacyContext = f
        b.context = e
        G(e)
      } else
        throw (
          ((b.blockedSegment.formatContext = d),
          (b.legacyContext = f),
          (b.context = e),
          G(e),
          k)
        )
    }
  }
  function Jb(a) {
    var b = a.blockedBoundary
    a = a.blockedSegment
    a.status = 3
    Kb(this, b, a)
  }
  function Lb(a, b, c) {
    var d = a.blockedBoundary
    a.blockedSegment.status = 3
    null === d
      ? (b.allPendingTasks--,
        2 !== b.status &&
          ((b.status = 2), null !== b.destination && b.destination.push(null)))
      : (d.pendingTasks--,
        d.forceClientRender ||
          ((d.forceClientRender = true),
          (a = void 0 === c ? Error(l(432)) : c),
          (d.errorDigest = b.onError(a)),
          d.parentFlushed && b.clientRenderedBoundaries.push(d)),
        d.fallbackAbortableTasks.forEach(function (a2) {
          return Lb(a2, b, c)
        }),
        d.fallbackAbortableTasks.clear(),
        b.allPendingTasks--,
        0 === b.allPendingTasks && ((d = b.onAllReady), d()))
  }
  function Y(a, b) {
    if (
      0 === b.chunks.length &&
      1 === b.children.length &&
      null === b.children[0].boundary
    ) {
      var c = b.children[0]
      c.id = b.id
      c.parentFlushed = true
      1 === c.status && Y(a, c)
    } else a.completedSegments.push(b)
  }
  function Kb(a, b, c) {
    if (null === b) {
      if (c.parentFlushed) {
        if (null !== a.completedRootSegment) throw Error(l(389))
        a.completedRootSegment = c
      }
      a.pendingRootTasks--
      0 === a.pendingRootTasks &&
        ((a.onShellError = T), (b = a.onShellReady), b())
    } else
      b.pendingTasks--,
        b.forceClientRender ||
          (0 === b.pendingTasks
            ? (c.parentFlushed && 1 === c.status && Y(b, c),
              b.parentFlushed && a.completedBoundaries.push(b),
              b.fallbackAbortableTasks.forEach(Jb, a),
              b.fallbackAbortableTasks.clear())
            : c.parentFlushed &&
              1 === c.status &&
              (Y(b, c),
              1 === b.completedSegments.length &&
                b.parentFlushed &&
                a.partialBoundaries.push(b)))
    a.allPendingTasks--
    0 === a.allPendingTasks && ((a = a.onAllReady), a())
  }
  function Cb(a) {
    if (2 !== a.status) {
      var b = E,
        c = yb.current
      yb.current = xb
      var d = S
      S = a.responseState
      try {
        var f = a.pingedTasks,
          e
        for (e = 0; e < f.length; e++) {
          var g = f[e]
          var h = a,
            k = g.blockedSegment
          if (0 === k.status) {
            G(g.context)
            try {
              X(h, g, g.node),
                h.responseState.generateStaticMarkup ||
                  (k.lastPushedText &&
                    k.textEmbedded &&
                    k.chunks.push('<!-- -->')),
                g.abortSet.delete(g),
                (k.status = 1),
                Kb(h, g.blockedBoundary, k)
            } catch (z2) {
              if (
                (rb(),
                'object' === typeof z2 &&
                  null !== z2 &&
                  'function' === typeof z2.then)
              ) {
                var m = g.ping
                z2.then(m, m)
              } else {
                g.abortSet.delete(g)
                k.status = 4
                var n = g.blockedBoundary,
                  q = z2,
                  C = V(h, q)
                null === n
                  ? W(h, q)
                  : (n.pendingTasks--,
                    n.forceClientRender ||
                      ((n.forceClientRender = true),
                      (n.errorDigest = C),
                      n.parentFlushed && h.clientRenderedBoundaries.push(n)))
                h.allPendingTasks--
                if (0 === h.allPendingTasks) {
                  var D = h.onAllReady
                  D()
                }
              }
            } finally {
            }
          }
        }
        f.splice(0, e)
        null !== a.destination && Mb(a, a.destination)
      } catch (z2) {
        V(a, z2), W(a, z2)
      } finally {
        ;(S = d), (yb.current = c), c === xb && G(b)
      }
    }
  }
  function Z(a, b, c) {
    c.parentFlushed = true
    switch (c.status) {
      case 0:
        var d = (c.id = a.nextSegmentId++)
        c.lastPushedText = false
        c.textEmbedded = false
        a = a.responseState
        b.push('<template id="')
        b.push(a.placeholderPrefix)
        a = d.toString(16)
        b.push(a)
        return b.push('"></template>')
      case 1:
        c.status = 2
        var f = true
        d = c.chunks
        var e = 0
        c = c.children
        for (var g = 0; g < c.length; g++) {
          for (f = c[g]; e < f.index; e++) b.push(d[e])
          f = Nb(a, b, f)
        }
        for (; e < d.length - 1; e++) b.push(d[e])
        e < d.length && (f = b.push(d[e]))
        return f
      default:
        throw Error(l(390))
    }
  }
  function Nb(a, b, c) {
    var d = c.boundary
    if (null === d) return Z(a, b, c)
    d.parentFlushed = true
    if (d.forceClientRender)
      return (
        a.responseState.generateStaticMarkup ||
          ((d = d.errorDigest),
          b.push('<!--$!-->'),
          b.push('<template'),
          d && (b.push(' data-dgst="'), (d = v(d)), b.push(d), b.push('"')),
          b.push('></template>')),
        Z(a, b, c),
        (a = a.responseState.generateStaticMarkup ? true : b.push('<!--/$-->')),
        a
      )
    if (0 < d.pendingTasks) {
      d.rootSegmentID = a.nextSegmentId++
      0 < d.completedSegments.length && a.partialBoundaries.push(d)
      var f = a.responseState
      var e = f.nextSuspenseID++
      f = f.boundaryPrefix + e.toString(16)
      d = d.id = f
      za(b, a.responseState, d)
      Z(a, b, c)
      return b.push('<!--/$-->')
    }
    if (d.byteSize > a.progressiveChunkSize)
      return (
        (d.rootSegmentID = a.nextSegmentId++),
        a.completedBoundaries.push(d),
        za(b, a.responseState, d.id),
        Z(a, b, c),
        b.push('<!--/$-->')
      )
    a.responseState.generateStaticMarkup || b.push('<!--$-->')
    c = d.completedSegments
    if (1 !== c.length) throw Error(l(391))
    Nb(a, b, c[0])
    a = a.responseState.generateStaticMarkup ? true : b.push('<!--/$-->')
    return a
  }
  function Ob(a, b, c) {
    Aa(b, a.responseState, c.formatContext, c.id)
    Nb(a, b, c)
    return Ba(b, c.formatContext)
  }
  function Pb(a, b, c) {
    for (var d = c.completedSegments, f = 0; f < d.length; f++)
      Qb(a, b, c, d[f])
    d.length = 0
    a = a.responseState
    d = c.id
    c = c.rootSegmentID
    b.push(a.startInlineScript)
    a.sentCompleteBoundaryFunction
      ? b.push('$RC("')
      : ((a.sentCompleteBoundaryFunction = true),
        b.push(
          'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("',
        ))
    if (null === d) throw Error(l(395))
    c = c.toString(16)
    b.push(d)
    b.push('","')
    b.push(a.segmentPrefix)
    b.push(c)
    return b.push('")</script>')
  }
  function Qb(a, b, c, d) {
    if (2 === d.status) return true
    var f = d.id
    if (-1 === f) {
      if (-1 === (d.id = c.rootSegmentID)) throw Error(l(392))
      return Ob(a, b, d)
    }
    Ob(a, b, d)
    a = a.responseState
    b.push(a.startInlineScript)
    a.sentCompleteSegmentFunction
      ? b.push('$RS("')
      : ((a.sentCompleteSegmentFunction = true),
        b.push(
          'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("',
        ))
    b.push(a.segmentPrefix)
    f = f.toString(16)
    b.push(f)
    b.push('","')
    b.push(a.placeholderPrefix)
    b.push(f)
    return b.push('")</script>')
  }
  function Mb(a, b) {
    try {
      var c = a.completedRootSegment
      if (null !== c && 0 === a.pendingRootTasks) {
        Nb(a, b, c)
        a.completedRootSegment = null
        var d = a.responseState.bootstrapChunks
        for (c = 0; c < d.length - 1; c++) b.push(d[c])
        c < d.length && b.push(d[c])
      }
      var f = a.clientRenderedBoundaries,
        e
      for (e = 0; e < f.length; e++) {
        var g = f[e]
        d = b
        var h = a.responseState,
          k = g.id,
          m = g.errorDigest,
          n = g.errorMessage,
          q = g.errorComponentStack
        d.push(h.startInlineScript)
        h.sentClientRenderFunction
          ? d.push('$RX("')
          : ((h.sentClientRenderFunction = true),
            d.push(
              'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("',
            ))
        if (null === k) throw Error(l(395))
        d.push(k)
        d.push('"')
        if (m || n || q) {
          d.push(',')
          var C = Da(m || '')
          d.push(C)
        }
        if (n || q) {
          d.push(',')
          var D = Da(n || '')
          d.push(D)
        }
        if (q) {
          d.push(',')
          var z2 = Da(q)
          d.push(z2)
        }
        if (!d.push(')</script>')) {
          a.destination = null
          e++
          f.splice(0, e)
          return
        }
      }
      f.splice(0, e)
      var ba = a.completedBoundaries
      for (e = 0; e < ba.length; e++)
        if (!Pb(a, b, ba[e])) {
          a.destination = null
          e++
          ba.splice(0, e)
          return
        }
      ba.splice(0, e)
      var ca = a.partialBoundaries
      for (e = 0; e < ca.length; e++) {
        var mb = ca[e]
        a: {
          f = a
          g = b
          var da = mb.completedSegments
          for (h = 0; h < da.length; h++)
            if (!Qb(f, g, mb, da[h])) {
              h++
              da.splice(0, h)
              var nb = false
              break a
            }
          da.splice(0, h)
          nb = true
        }
        if (!nb) {
          a.destination = null
          e++
          ca.splice(0, e)
          return
        }
      }
      ca.splice(0, e)
      var ea = a.completedBoundaries
      for (e = 0; e < ea.length; e++)
        if (!Pb(a, b, ea[e])) {
          a.destination = null
          e++
          ea.splice(0, e)
          return
        }
      ea.splice(0, e)
    } finally {
      0 === a.allPendingTasks &&
        0 === a.pingedTasks.length &&
        0 === a.clientRenderedBoundaries.length &&
        0 === a.completedBoundaries.length &&
        b.push(null)
    }
  }
  function Rb(a, b) {
    try {
      var c = a.abortableTasks
      c.forEach(function (c2) {
        return Lb(c2, a, b)
      })
      c.clear()
      null !== a.destination && Mb(a, a.destination)
    } catch (d) {
      V(a, d), W(a, d)
    }
  }
  function Sb() {}
  function Tb(a, b, c, d) {
    var f = false,
      e = null,
      g = '',
      h = {
        push: function (a2) {
          null !== a2 && (g += a2)
          return true
        },
        destroy: function (a2) {
          f = true
          e = a2
        },
      },
      k = false
    a = Ab(
      a,
      Ea(c, b ? b.identifierPrefix : void 0),
      {insertionMode: 1, selectedValue: null},
      Infinity,
      Sb,
      void 0,
      function () {
        k = true
      },
    )
    Cb(a)
    Rb(a, d)
    if (1 === a.status) (a.status = 2), h.destroy(a.fatalError)
    else if (2 !== a.status && null === a.destination) {
      a.destination = h
      try {
        Mb(a, h)
      } catch (m) {
        V(a, m), W(a, m)
      }
    }
    if (f) throw e
    if (!k) throw Error(l(426))
    return g
  }
  reactDomServerLegacy_browser_production_min.renderToNodeStream = function () {
    throw Error(l(207))
  }
  reactDomServerLegacy_browser_production_min.renderToStaticMarkup = function (
    a,
    b,
  ) {
    return Tb(
      a,
      b,
      true,
      'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server',
    )
  }
  reactDomServerLegacy_browser_production_min.renderToStaticNodeStream =
    function () {
      throw Error(l(208))
    }
  reactDomServerLegacy_browser_production_min.renderToString = function (a, b) {
    return Tb(
      a,
      b,
      false,
      'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server',
    )
  }
  reactDomServerLegacy_browser_production_min.version = '18.2.0'
  return reactDomServerLegacy_browser_production_min
}
var reactDomServer_browser_production_min = {}
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServer_browser_production_min
function requireReactDomServer_browser_production_min() {
  if (hasRequiredReactDomServer_browser_production_min)
    return reactDomServer_browser_production_min
  hasRequiredReactDomServer_browser_production_min = 1
  var aa = requireReact()
  function k(a) {
    for (
      var b = 'https://reactjs.org/docs/error-decoder.html?invariant=' + a,
        c = 1;
      c < arguments.length;
      c++
    )
      b += '&args[]=' + encodeURIComponent(arguments[c])
    return (
      'Minified React error #' +
      a +
      '; visit ' +
      b +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  var l = null,
    n = 0
  function p(a, b) {
    if (0 !== b.length)
      if (512 < b.length)
        0 < n &&
          (a.enqueue(new Uint8Array(l.buffer, 0, n)),
          (l = new Uint8Array(512)),
          (n = 0)),
          a.enqueue(b)
      else {
        var c = l.length - n
        c < b.length &&
          (0 === c
            ? a.enqueue(l)
            : (l.set(b.subarray(0, c), n), a.enqueue(l), (b = b.subarray(c))),
          (l = new Uint8Array(512)),
          (n = 0))
        l.set(b, n)
        n += b.length
      }
  }
  function t(a, b) {
    p(a, b)
    return true
  }
  function ba(a) {
    l &&
      0 < n &&
      (a.enqueue(new Uint8Array(l.buffer, 0, n)), (l = null), (n = 0))
  }
  var ca = new TextEncoder()
  function u(a) {
    return ca.encode(a)
  }
  function w(a) {
    return ca.encode(a)
  }
  function da(a, b) {
    'function' === typeof a.error ? a.error(b) : a.close()
  }
  var x = Object.prototype.hasOwnProperty,
    ea =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    fa = {},
    ha = {}
  function ia(a) {
    if (x.call(ha, a)) return true
    if (x.call(fa, a)) return false
    if (ea.test(a)) return (ha[a] = true)
    fa[a] = true
    return false
  }
  function y(a, b, c, d, f, e, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b
    this.attributeName = d
    this.attributeNamespace = f
    this.mustUseProperty = c
    this.propertyName = a
    this.type = b
    this.sanitizeURL = e
    this.removeEmptyString = g
  }
  var z2 = {}
  'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
    .split(' ')
    .forEach(function (a) {
      z2[a] = new y(a, 0, false, a, null, false, false)
    })
  ;[
    ['acceptCharset', 'accept-charset'],
    ['className', 'class'],
    ['htmlFor', 'for'],
    ['httpEquiv', 'http-equiv'],
  ].forEach(function (a) {
    var b = a[0]
    z2[b] = new y(b, 1, false, a[1], null, false, false)
  })
  ;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(
    function (a) {
      z2[a] = new y(a, 2, false, a.toLowerCase(), null, false, false)
    },
  )
  ;[
    'autoReverse',
    'externalResourcesRequired',
    'focusable',
    'preserveAlpha',
  ].forEach(function (a) {
    z2[a] = new y(a, 2, false, a, null, false, false)
  })
  'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
    .split(' ')
    .forEach(function (a) {
      z2[a] = new y(a, 3, false, a.toLowerCase(), null, false, false)
    })
  ;['checked', 'multiple', 'muted', 'selected'].forEach(function (a) {
    z2[a] = new y(a, 3, true, a, null, false, false)
  })
  ;['capture', 'download'].forEach(function (a) {
    z2[a] = new y(a, 4, false, a, null, false, false)
  })
  ;['cols', 'rows', 'size', 'span'].forEach(function (a) {
    z2[a] = new y(a, 6, false, a, null, false, false)
  })
  ;['rowSpan', 'start'].forEach(function (a) {
    z2[a] = new y(a, 5, false, a.toLowerCase(), null, false, false)
  })
  var ja = /[\-:]([a-z])/g
  function ka(a) {
    return a[1].toUpperCase()
  }
  'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
    .split(' ')
    .forEach(function (a) {
      var b = a.replace(ja, ka)
      z2[b] = new y(b, 1, false, a, null, false, false)
    })
  'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
    .split(' ')
    .forEach(function (a) {
      var b = a.replace(ja, ka)
      z2[b] = new y(
        b,
        1,
        false,
        a,
        'http://www.w3.org/1999/xlink',
        false,
        false,
      )
    })
  ;['xml:base', 'xml:lang', 'xml:space'].forEach(function (a) {
    var b = a.replace(ja, ka)
    z2[b] = new y(
      b,
      1,
      false,
      a,
      'http://www.w3.org/XML/1998/namespace',
      false,
      false,
    )
  })
  ;['tabIndex', 'crossOrigin'].forEach(function (a) {
    z2[a] = new y(a, 1, false, a.toLowerCase(), null, false, false)
  })
  z2.xlinkHref = new y(
    'xlinkHref',
    1,
    false,
    'xlink:href',
    'http://www.w3.org/1999/xlink',
    true,
    false,
  )
  ;['src', 'href', 'action', 'formAction'].forEach(function (a) {
    z2[a] = new y(a, 1, false, a.toLowerCase(), null, true, true)
  })
  var B = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true,
    },
    la = ['Webkit', 'ms', 'Moz', 'O']
  Object.keys(B).forEach(function (a) {
    la.forEach(function (b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1)
      B[b] = B[a]
    })
  })
  var oa = /["'&<>]/
  function C(a) {
    if ('boolean' === typeof a || 'number' === typeof a) return '' + a
    a = '' + a
    var b = oa.exec(a)
    if (b) {
      var c = '',
        d,
        f = 0
      for (d = b.index; d < a.length; d++) {
        switch (a.charCodeAt(d)) {
          case 34:
            b = '&quot;'
            break
          case 38:
            b = '&amp;'
            break
          case 39:
            b = '&#x27;'
            break
          case 60:
            b = '&lt;'
            break
          case 62:
            b = '&gt;'
            break
          default:
            continue
        }
        f !== d && (c += a.substring(f, d))
        f = d + 1
        c += b
      }
      a = f !== d ? c + a.substring(f, d) : c
    }
    return a
  }
  var pa = /([A-Z])/g,
    qa = /^ms-/,
    ra = Array.isArray,
    sa = w('<script>'),
    ta = w('</script>'),
    ua = w('<script src="'),
    va = w('<script type="module" src="'),
    wa = w('" async=""></script>'),
    xa = /(<\/|<)(s)(cript)/gi
  function ya(a, b, c, d) {
    return '' + b + ('s' === c ? '\\u0073' : '\\u0053') + d
  }
  function za(a, b, c, d, f) {
    a = void 0 === a ? '' : a
    b = void 0 === b ? sa : w('<script nonce="' + C(b) + '">')
    var e = []
    void 0 !== c && e.push(b, u(('' + c).replace(xa, ya)), ta)
    if (void 0 !== d) for (c = 0; c < d.length; c++) e.push(ua, u(C(d[c])), wa)
    if (void 0 !== f) for (d = 0; d < f.length; d++) e.push(va, u(C(f[d])), wa)
    return {
      bootstrapChunks: e,
      startInlineScript: b,
      placeholderPrefix: w(a + 'P:'),
      segmentPrefix: w(a + 'S:'),
      boundaryPrefix: a + 'B:',
      idPrefix: a,
      nextSuspenseID: 0,
      sentCompleteSegmentFunction: false,
      sentCompleteBoundaryFunction: false,
      sentClientRenderFunction: false,
    }
  }
  function D(a, b) {
    return {insertionMode: a, selectedValue: b}
  }
  function Aa(a) {
    return D(
      'http://www.w3.org/2000/svg' === a
        ? 2
        : 'http://www.w3.org/1998/Math/MathML' === a
        ? 3
        : 0,
      null,
    )
  }
  function Ba(a, b, c) {
    switch (b) {
      case 'select':
        return D(1, null != c.value ? c.value : c.defaultValue)
      case 'svg':
        return D(2, null)
      case 'math':
        return D(3, null)
      case 'foreignObject':
        return D(1, null)
      case 'table':
        return D(4, null)
      case 'thead':
      case 'tbody':
      case 'tfoot':
        return D(5, null)
      case 'colgroup':
        return D(7, null)
      case 'tr':
        return D(6, null)
    }
    return 4 <= a.insertionMode || 0 === a.insertionMode ? D(1, null) : a
  }
  var Ca = w('<!-- -->')
  function Da(a, b, c, d) {
    if ('' === b) return d
    d && a.push(Ca)
    a.push(u(C(b)))
    return true
  }
  var Ea = /* @__PURE__ */ new Map(),
    Fa = w(' style="'),
    Ga = w(':'),
    Ha = w(';')
  function Ia(a, b, c) {
    if ('object' !== typeof c) throw Error(k(62))
    b = true
    for (var d in c)
      if (x.call(c, d)) {
        var f = c[d]
        if (null != f && 'boolean' !== typeof f && '' !== f) {
          if (0 === d.indexOf('--')) {
            var e = u(C(d))
            f = u(C(('' + f).trim()))
          } else {
            e = d
            var g = Ea.get(e)
            void 0 !== g
              ? (e = g)
              : ((g = w(
                  C(e.replace(pa, '-$1').toLowerCase().replace(qa, '-ms-')),
                )),
                Ea.set(e, g),
                (e = g))
            f =
              'number' === typeof f
                ? 0 === f || x.call(B, d)
                  ? u('' + f)
                  : u(f + 'px')
                : u(C(('' + f).trim()))
          }
          b ? ((b = false), a.push(Fa, e, Ga, f)) : a.push(Ha, e, Ga, f)
        }
      }
    b || a.push(E)
  }
  var H = w(' '),
    I = w('="'),
    E = w('"'),
    Ja = w('=""')
  function J(a, b, c, d) {
    switch (c) {
      case 'style':
        Ia(a, b, d)
        return
      case 'defaultValue':
      case 'defaultChecked':
      case 'innerHTML':
      case 'suppressContentEditableWarning':
      case 'suppressHydrationWarning':
        return
    }
    if (
      !(2 < c.length) ||
      ('o' !== c[0] && 'O' !== c[0]) ||
      ('n' !== c[1] && 'N' !== c[1])
    ) {
      if (((b = z2.hasOwnProperty(c) ? z2[c] : null), null !== b)) {
        switch (typeof d) {
          case 'function':
          case 'symbol':
            return
          case 'boolean':
            if (!b.acceptsBooleans) return
        }
        c = u(b.attributeName)
        switch (b.type) {
          case 3:
            d && a.push(H, c, Ja)
            break
          case 4:
            true === d
              ? a.push(H, c, Ja)
              : false !== d && a.push(H, c, I, u(C(d)), E)
            break
          case 5:
            isNaN(d) || a.push(H, c, I, u(C(d)), E)
            break
          case 6:
            !isNaN(d) && 1 <= d && a.push(H, c, I, u(C(d)), E)
            break
          default:
            b.sanitizeURL && (d = '' + d), a.push(H, c, I, u(C(d)), E)
        }
      } else if (ia(c)) {
        switch (typeof d) {
          case 'function':
          case 'symbol':
            return
          case 'boolean':
            if (
              ((b = c.toLowerCase().slice(0, 5)),
              'data-' !== b && 'aria-' !== b)
            )
              return
        }
        a.push(H, u(c), I, u(C(d)), E)
      }
    }
  }
  var K = w('>'),
    Ka = w('/>')
  function L(a, b, c) {
    if (null != b) {
      if (null != c) throw Error(k(60))
      if ('object' !== typeof b || !('__html' in b)) throw Error(k(61))
      b = b.__html
      null !== b && void 0 !== b && a.push(u('' + b))
    }
  }
  function La(a) {
    var b = ''
    aa.Children.forEach(a, function (a2) {
      null != a2 && (b += a2)
    })
    return b
  }
  var Ma = w(' selected=""')
  function Na(a, b, c, d) {
    a.push(M(c))
    var f = (c = null),
      e
    for (e in b)
      if (x.call(b, e)) {
        var g = b[e]
        if (null != g)
          switch (e) {
            case 'children':
              c = g
              break
            case 'dangerouslySetInnerHTML':
              f = g
              break
            default:
              J(a, d, e, g)
          }
      }
    a.push(K)
    L(a, f, c)
    return 'string' === typeof c ? (a.push(u(C(c))), null) : c
  }
  var Oa = w('\n'),
    Pa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    Qa = /* @__PURE__ */ new Map()
  function M(a) {
    var b = Qa.get(a)
    if (void 0 === b) {
      if (!Pa.test(a)) throw Error(k(65, a))
      b = w('<' + a)
      Qa.set(a, b)
    }
    return b
  }
  var Ra = w('<!DOCTYPE html>')
  function Sa(a, b, c, d, f) {
    switch (b) {
      case 'select':
        a.push(M('select'))
        var e = null,
          g = null
        for (r in c)
          if (x.call(c, r)) {
            var h = c[r]
            if (null != h)
              switch (r) {
                case 'children':
                  e = h
                  break
                case 'dangerouslySetInnerHTML':
                  g = h
                  break
                case 'defaultValue':
                case 'value':
                  break
                default:
                  J(a, d, r, h)
              }
          }
        a.push(K)
        L(a, g, e)
        return e
      case 'option':
        g = f.selectedValue
        a.push(M('option'))
        var m = (h = null),
          q = null
        var r = null
        for (e in c)
          if (x.call(c, e)) {
            var v = c[e]
            if (null != v)
              switch (e) {
                case 'children':
                  h = v
                  break
                case 'selected':
                  q = v
                  break
                case 'dangerouslySetInnerHTML':
                  r = v
                  break
                case 'value':
                  m = v
                default:
                  J(a, d, e, v)
              }
          }
        if (null != g)
          if (((c = null !== m ? '' + m : La(h)), ra(g)))
            for (d = 0; d < g.length; d++) {
              if ('' + g[d] === c) {
                a.push(Ma)
                break
              }
            }
          else '' + g === c && a.push(Ma)
        else q && a.push(Ma)
        a.push(K)
        L(a, r, h)
        return h
      case 'textarea':
        a.push(M('textarea'))
        r = g = e = null
        for (h in c)
          if (x.call(c, h) && ((m = c[h]), null != m))
            switch (h) {
              case 'children':
                r = m
                break
              case 'value':
                e = m
                break
              case 'defaultValue':
                g = m
                break
              case 'dangerouslySetInnerHTML':
                throw Error(k(91))
              default:
                J(a, d, h, m)
            }
        null === e && null !== g && (e = g)
        a.push(K)
        if (null != r) {
          if (null != e) throw Error(k(92))
          if (ra(r) && 1 < r.length) throw Error(k(93))
          e = '' + r
        }
        'string' === typeof e && '\n' === e[0] && a.push(Oa)
        null !== e && a.push(u(C('' + e)))
        return null
      case 'input':
        a.push(M('input'))
        m = r = h = e = null
        for (g in c)
          if (x.call(c, g) && ((q = c[g]), null != q))
            switch (g) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(k(399, 'input'))
              case 'defaultChecked':
                m = q
                break
              case 'defaultValue':
                h = q
                break
              case 'checked':
                r = q
                break
              case 'value':
                e = q
                break
              default:
                J(a, d, g, q)
            }
        null !== r ? J(a, d, 'checked', r) : null !== m && J(a, d, 'checked', m)
        null !== e ? J(a, d, 'value', e) : null !== h && J(a, d, 'value', h)
        a.push(Ka)
        return null
      case 'menuitem':
        a.push(M('menuitem'))
        for (var A in c)
          if (x.call(c, A) && ((e = c[A]), null != e))
            switch (A) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(k(400))
              default:
                J(a, d, A, e)
            }
        a.push(K)
        return null
      case 'title':
        a.push(M('title'))
        e = null
        for (v in c)
          if (x.call(c, v) && ((g = c[v]), null != g))
            switch (v) {
              case 'children':
                e = g
                break
              case 'dangerouslySetInnerHTML':
                throw Error(k(434))
              default:
                J(a, d, v, g)
            }
        a.push(K)
        return e
      case 'listing':
      case 'pre':
        a.push(M(b))
        g = e = null
        for (m in c)
          if (x.call(c, m) && ((h = c[m]), null != h))
            switch (m) {
              case 'children':
                e = h
                break
              case 'dangerouslySetInnerHTML':
                g = h
                break
              default:
                J(a, d, m, h)
            }
        a.push(K)
        if (null != g) {
          if (null != e) throw Error(k(60))
          if ('object' !== typeof g || !('__html' in g)) throw Error(k(61))
          c = g.__html
          null !== c &&
            void 0 !== c &&
            ('string' === typeof c && 0 < c.length && '\n' === c[0]
              ? a.push(Oa, u(c))
              : a.push(u('' + c)))
        }
        'string' === typeof e && '\n' === e[0] && a.push(Oa)
        return e
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'img':
      case 'keygen':
      case 'link':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
        a.push(M(b))
        for (var F in c)
          if (x.call(c, F) && ((e = c[F]), null != e))
            switch (F) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw Error(k(399, b))
              default:
                J(a, d, F, e)
            }
        a.push(Ka)
        return null
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return Na(a, c, b, d)
      case 'html':
        return 0 === f.insertionMode && a.push(Ra), Na(a, c, b, d)
      default:
        if (-1 === b.indexOf('-') && 'string' !== typeof c.is)
          return Na(a, c, b, d)
        a.push(M(b))
        g = e = null
        for (q in c)
          if (x.call(c, q) && ((h = c[q]), null != h))
            switch (q) {
              case 'children':
                e = h
                break
              case 'dangerouslySetInnerHTML':
                g = h
                break
              case 'style':
                Ia(a, d, h)
                break
              case 'suppressContentEditableWarning':
              case 'suppressHydrationWarning':
                break
              default:
                ia(q) &&
                  'function' !== typeof h &&
                  'symbol' !== typeof h &&
                  a.push(H, u(q), I, u(C(h)), E)
            }
        a.push(K)
        L(a, g, e)
        return e
    }
  }
  var Ta = w('</'),
    Ua = w('>'),
    Va = w('<template id="'),
    Wa = w('"></template>'),
    Xa = w('<!--$-->'),
    Ya = w('<!--$?--><template id="'),
    Za = w('"></template>'),
    $a = w('<!--$!-->'),
    ab = w('<!--/$-->'),
    bb = w('<template'),
    cb = w('"'),
    db2 = w(' data-dgst="')
  w(' data-msg="')
  w(' data-stck="')
  var eb = w('></template>')
  function fb(a, b, c) {
    p(a, Ya)
    if (null === c) throw Error(k(395))
    p(a, c)
    return t(a, Za)
  }
  var gb = w('<div hidden id="'),
    hb = w('">'),
    ib = w('</div>'),
    jb = w('<svg aria-hidden="true" style="display:none" id="'),
    kb = w('">'),
    lb = w('</svg>'),
    mb = w('<math aria-hidden="true" style="display:none" id="'),
    nb = w('">'),
    ob = w('</math>'),
    pb = w('<table hidden id="'),
    qb = w('">'),
    rb = w('</table>'),
    sb = w('<table hidden><tbody id="'),
    tb = w('">'),
    ub = w('</tbody></table>'),
    vb = w('<table hidden><tr id="'),
    wb = w('">'),
    xb = w('</tr></table>'),
    yb = w('<table hidden><colgroup id="'),
    zb = w('">'),
    Ab = w('</colgroup></table>')
  function Bb(a, b, c, d) {
    switch (c.insertionMode) {
      case 0:
      case 1:
        return (
          p(a, gb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, hb)
        )
      case 2:
        return (
          p(a, jb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, kb)
        )
      case 3:
        return (
          p(a, mb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, nb)
        )
      case 4:
        return (
          p(a, pb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, qb)
        )
      case 5:
        return (
          p(a, sb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, tb)
        )
      case 6:
        return (
          p(a, vb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, wb)
        )
      case 7:
        return (
          p(a, yb), p(a, b.segmentPrefix), p(a, u(d.toString(16))), t(a, zb)
        )
      default:
        throw Error(k(397))
    }
  }
  function Cb(a, b) {
    switch (b.insertionMode) {
      case 0:
      case 1:
        return t(a, ib)
      case 2:
        return t(a, lb)
      case 3:
        return t(a, ob)
      case 4:
        return t(a, rb)
      case 5:
        return t(a, ub)
      case 6:
        return t(a, xb)
      case 7:
        return t(a, Ab)
      default:
        throw Error(k(397))
    }
  }
  var Db = w(
      'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("',
    ),
    Eb = w('$RS("'),
    Gb = w('","'),
    Hb = w('")</script>'),
    Ib = w(
      'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("',
    ),
    Jb = w('$RC("'),
    Kb = w('","'),
    Lb = w('")</script>'),
    Mb = w(
      'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("',
    ),
    Nb = w('$RX("'),
    Ob = w('"'),
    Pb = w(')</script>'),
    Qb = w(','),
    Rb = /[<\u2028\u2029]/g
  function Sb(a) {
    return JSON.stringify(a).replace(Rb, function (a2) {
      switch (a2) {
        case '<':
          return '\\u003c'
        case '\u2028':
          return '\\u2028'
        case '\u2029':
          return '\\u2029'
        default:
          throw Error(
            'escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React',
          )
      }
    })
  }
  var N = Object.assign,
    Tb = Symbol.for('react.element'),
    Ub = Symbol.for('react.portal'),
    Vb = Symbol.for('react.fragment'),
    Wb = Symbol.for('react.strict_mode'),
    Xb = Symbol.for('react.profiler'),
    Yb = Symbol.for('react.provider'),
    Zb = Symbol.for('react.context'),
    $b = Symbol.for('react.forward_ref'),
    ac = Symbol.for('react.suspense'),
    bc = Symbol.for('react.suspense_list'),
    cc = Symbol.for('react.memo'),
    dc = Symbol.for('react.lazy'),
    ec = Symbol.for('react.scope'),
    fc = Symbol.for('react.debug_trace_mode'),
    gc = Symbol.for('react.legacy_hidden'),
    hc = Symbol.for('react.default_value'),
    ic = Symbol.iterator
  function jc(a) {
    if (null == a) return null
    if ('function' === typeof a) return a.displayName || a.name || null
    if ('string' === typeof a) return a
    switch (a) {
      case Vb:
        return 'Fragment'
      case Ub:
        return 'Portal'
      case Xb:
        return 'Profiler'
      case Wb:
        return 'StrictMode'
      case ac:
        return 'Suspense'
      case bc:
        return 'SuspenseList'
    }
    if ('object' === typeof a)
      switch (a.$$typeof) {
        case Zb:
          return (a.displayName || 'Context') + '.Consumer'
        case Yb:
          return (a._context.displayName || 'Context') + '.Provider'
        case $b:
          var b = a.render
          a = a.displayName
          a ||
            ((a = b.displayName || b.name || ''),
            (a = '' !== a ? 'ForwardRef(' + a + ')' : 'ForwardRef'))
          return a
        case cc:
          return (
            (b = a.displayName || null), null !== b ? b : jc(a.type) || 'Memo'
          )
        case dc:
          b = a._payload
          a = a._init
          try {
            return jc(a(b))
          } catch (c) {}
      }
    return null
  }
  var kc = {}
  function lc(a, b) {
    a = a.contextTypes
    if (!a) return kc
    var c = {},
      d
    for (d in a) c[d] = b[d]
    return c
  }
  var O = null
  function P(a, b) {
    if (a !== b) {
      a.context._currentValue = a.parentValue
      a = a.parent
      var c = b.parent
      if (null === a) {
        if (null !== c) throw Error(k(401))
      } else {
        if (null === c) throw Error(k(401))
        P(a, c)
      }
      b.context._currentValue = b.value
    }
  }
  function mc(a) {
    a.context._currentValue = a.parentValue
    a = a.parent
    null !== a && mc(a)
  }
  function nc(a) {
    var b = a.parent
    null !== b && nc(b)
    a.context._currentValue = a.value
  }
  function oc(a, b) {
    a.context._currentValue = a.parentValue
    a = a.parent
    if (null === a) throw Error(k(402))
    a.depth === b.depth ? P(a, b) : oc(a, b)
  }
  function pc(a, b) {
    var c = b.parent
    if (null === c) throw Error(k(402))
    a.depth === c.depth ? P(a, c) : pc(a, c)
    b.context._currentValue = b.value
  }
  function Q(a) {
    var b = O
    b !== a &&
      (null === b
        ? nc(a)
        : null === a
        ? mc(b)
        : b.depth === a.depth
        ? P(b, a)
        : b.depth > a.depth
        ? oc(b, a)
        : pc(b, a),
      (O = a))
  }
  var qc = {
    isMounted: function () {
      return false
    },
    enqueueSetState: function (a, b) {
      a = a._reactInternals
      null !== a.queue && a.queue.push(b)
    },
    enqueueReplaceState: function (a, b) {
      a = a._reactInternals
      a.replace = true
      a.queue = [b]
    },
    enqueueForceUpdate: function () {},
  }
  function rc(a, b, c, d) {
    var f = void 0 !== a.state ? a.state : null
    a.updater = qc
    a.props = c
    a.state = f
    var e = {queue: [], replace: false}
    a._reactInternals = e
    var g = b.contextType
    a.context = 'object' === typeof g && null !== g ? g._currentValue : d
    g = b.getDerivedStateFromProps
    'function' === typeof g &&
      ((g = g(c, f)),
      (f = null === g || void 0 === g ? f : N({}, f, g)),
      (a.state = f))
    if (
      'function' !== typeof b.getDerivedStateFromProps &&
      'function' !== typeof a.getSnapshotBeforeUpdate &&
      ('function' === typeof a.UNSAFE_componentWillMount ||
        'function' === typeof a.componentWillMount)
    )
      if (
        ((b = a.state),
        'function' === typeof a.componentWillMount && a.componentWillMount(),
        'function' === typeof a.UNSAFE_componentWillMount &&
          a.UNSAFE_componentWillMount(),
        b !== a.state && qc.enqueueReplaceState(a, a.state, null),
        null !== e.queue && 0 < e.queue.length)
      )
        if (
          ((b = e.queue),
          (g = e.replace),
          (e.queue = null),
          (e.replace = false),
          g && 1 === b.length)
        )
          a.state = b[0]
        else {
          e = g ? b[0] : a.state
          f = true
          for (g = g ? 1 : 0; g < b.length; g++) {
            var h = b[g]
            h = 'function' === typeof h ? h.call(a, e, c, d) : h
            null != h && (f ? ((f = false), (e = N({}, e, h))) : N(e, h))
          }
          a.state = e
        }
      else e.queue = null
  }
  var sc = {id: 1, overflow: ''}
  function tc(a, b, c) {
    var d = a.id
    a = a.overflow
    var f = 32 - uc(d) - 1
    d &= ~(1 << f)
    c += 1
    var e = 32 - uc(b) + f
    if (30 < e) {
      var g = f - (f % 5)
      e = (d & ((1 << g) - 1)).toString(32)
      d >>= g
      f -= g
      return {id: (1 << (32 - uc(b) + f)) | (c << f) | d, overflow: e + a}
    }
    return {id: (1 << e) | (c << f) | d, overflow: a}
  }
  var uc = Math.clz32 ? Math.clz32 : vc,
    wc = Math.log,
    xc = Math.LN2
  function vc(a) {
    a >>>= 0
    return 0 === a ? 32 : (31 - ((wc(a) / xc) | 0)) | 0
  }
  function yc(a, b) {
    return (a === b && (0 !== a || 1 / a === 1 / b)) || (a !== a && b !== b)
  }
  var zc = 'function' === typeof Object.is ? Object.is : yc,
    R = null,
    Ac = null,
    Bc = null,
    S = null,
    T = false,
    Cc = false,
    U = 0,
    V = null,
    Dc = 0
  function W() {
    if (null === R) throw Error(k(321))
    return R
  }
  function Ec() {
    if (0 < Dc) throw Error(k(312))
    return {memoizedState: null, queue: null, next: null}
  }
  function Fc() {
    null === S
      ? null === Bc
        ? ((T = false), (Bc = S = Ec()))
        : ((T = true), (S = Bc))
      : null === S.next
      ? ((T = false), (S = S.next = Ec()))
      : ((T = true), (S = S.next))
    return S
  }
  function Gc() {
    Ac = R = null
    Cc = false
    Bc = null
    Dc = 0
    S = V = null
  }
  function Hc(a, b) {
    return 'function' === typeof b ? b(a) : b
  }
  function Ic(a, b, c) {
    R = W()
    S = Fc()
    if (T) {
      var d = S.queue
      b = d.dispatch
      if (null !== V && ((c = V.get(d)), void 0 !== c)) {
        V.delete(d)
        d = S.memoizedState
        do (d = a(d, c.action)), (c = c.next)
        while (null !== c)
        S.memoizedState = d
        return [d, b]
      }
      return [S.memoizedState, b]
    }
    a = a === Hc ? ('function' === typeof b ? b() : b) : void 0 !== c ? c(b) : b
    S.memoizedState = a
    a = S.queue = {last: null, dispatch: null}
    a = a.dispatch = Jc.bind(null, R, a)
    return [S.memoizedState, a]
  }
  function Kc(a, b) {
    R = W()
    S = Fc()
    b = void 0 === b ? null : b
    if (null !== S) {
      var c = S.memoizedState
      if (null !== c && null !== b) {
        var d = c[1]
        a: if (null === d) d = false
        else {
          for (var f = 0; f < d.length && f < b.length; f++)
            if (!zc(b[f], d[f])) {
              d = false
              break a
            }
          d = true
        }
        if (d) return c[0]
      }
    }
    a = a()
    S.memoizedState = [a, b]
    return a
  }
  function Jc(a, b, c) {
    if (25 <= Dc) throw Error(k(301))
    if (a === R)
      if (
        ((Cc = true),
        (a = {action: c, next: null}),
        null === V && (V = /* @__PURE__ */ new Map()),
        (c = V.get(b)),
        void 0 === c)
      )
        V.set(b, a)
      else {
        for (b = c; null !== b.next; ) b = b.next
        b.next = a
      }
  }
  function Lc() {
    throw Error(k(394))
  }
  function Mc() {}
  var Oc = {
      readContext: function (a) {
        return a._currentValue
      },
      useContext: function (a) {
        W()
        return a._currentValue
      },
      useMemo: Kc,
      useReducer: Ic,
      useRef: function (a) {
        R = W()
        S = Fc()
        var b = S.memoizedState
        return null === b ? ((a = {current: a}), (S.memoizedState = a)) : b
      },
      useState: function (a) {
        return Ic(Hc, a)
      },
      useInsertionEffect: Mc,
      useLayoutEffect: function () {},
      useCallback: function (a, b) {
        return Kc(function () {
          return a
        }, b)
      },
      useImperativeHandle: Mc,
      useEffect: Mc,
      useDebugValue: Mc,
      useDeferredValue: function (a) {
        W()
        return a
      },
      useTransition: function () {
        W()
        return [false, Lc]
      },
      useId: function () {
        var a = Ac.treeContext
        var b = a.overflow
        a = a.id
        a = (a & ~(1 << (32 - uc(a) - 1))).toString(32) + b
        var c = Nc
        if (null === c) throw Error(k(404))
        b = U++
        a = ':' + c.idPrefix + 'R' + a
        0 < b && (a += 'H' + b.toString(32))
        return a + ':'
      },
      useMutableSource: function (a, b) {
        W()
        return b(a._source)
      },
      useSyncExternalStore: function (a, b, c) {
        if (void 0 === c) throw Error(k(407))
        return c()
      },
    },
    Nc = null,
    Pc =
      aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
        .ReactCurrentDispatcher
  function Qc(a) {
    console.error(a)
    return null
  }
  function X() {}
  function Rc(a, b, c, d, f, e, g, h, m) {
    var q = [],
      r = /* @__PURE__ */ new Set()
    b = {
      destination: null,
      responseState: b,
      progressiveChunkSize: void 0 === d ? 12800 : d,
      status: 0,
      fatalError: null,
      nextSegmentId: 0,
      allPendingTasks: 0,
      pendingRootTasks: 0,
      completedRootSegment: null,
      abortableTasks: r,
      pingedTasks: q,
      clientRenderedBoundaries: [],
      completedBoundaries: [],
      partialBoundaries: [],
      onError: void 0 === f ? Qc : f,
      onAllReady: void 0 === e ? X : e,
      onShellReady: void 0 === g ? X : g,
      onShellError: void 0 === h ? X : h,
      onFatalError: void 0 === m ? X : m,
    }
    c = Sc(b, 0, null, c, false, false)
    c.parentFlushed = true
    a = Tc(b, a, null, c, r, kc, null, sc)
    q.push(a)
    return b
  }
  function Tc(a, b, c, d, f, e, g, h) {
    a.allPendingTasks++
    null === c ? a.pendingRootTasks++ : c.pendingTasks++
    var m = {
      node: b,
      ping: function () {
        var b2 = a.pingedTasks
        b2.push(m)
        1 === b2.length && Uc(a)
      },
      blockedBoundary: c,
      blockedSegment: d,
      abortSet: f,
      legacyContext: e,
      context: g,
      treeContext: h,
    }
    f.add(m)
    return m
  }
  function Sc(a, b, c, d, f, e) {
    return {
      status: 0,
      id: -1,
      index: b,
      parentFlushed: false,
      chunks: [],
      children: [],
      formatContext: d,
      boundary: c,
      lastPushedText: f,
      textEmbedded: e,
    }
  }
  function Y(a, b) {
    a = a.onError(b)
    if (null != a && 'string' !== typeof a)
      throw Error(
        'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
          typeof a +
          '" instead',
      )
    return a
  }
  function Vc(a, b) {
    var c = a.onShellError
    c(b)
    c = a.onFatalError
    c(b)
    null !== a.destination
      ? ((a.status = 2), da(a.destination, b))
      : ((a.status = 1), (a.fatalError = b))
  }
  function Wc(a, b, c, d, f) {
    R = {}
    Ac = b
    U = 0
    for (a = c(d, f); Cc; )
      (Cc = false), (U = 0), (Dc += 1), (S = null), (a = c(d, f))
    Gc()
    return a
  }
  function Xc(a, b, c, d) {
    var f = c.render(),
      e = d.childContextTypes
    if (null !== e && void 0 !== e) {
      var g = b.legacyContext
      if ('function' !== typeof c.getChildContext) d = g
      else {
        c = c.getChildContext()
        for (var h in c)
          if (!(h in e)) throw Error(k(108, jc(d) || 'Unknown', h))
        d = N({}, g, c)
      }
      b.legacyContext = d
      Z(a, b, f)
      b.legacyContext = g
    } else Z(a, b, f)
  }
  function Yc(a, b) {
    if (a && a.defaultProps) {
      b = N({}, b)
      a = a.defaultProps
      for (var c in a) void 0 === b[c] && (b[c] = a[c])
      return b
    }
    return b
  }
  function Zc(a, b, c, d, f) {
    if ('function' === typeof c)
      if (c.prototype && c.prototype.isReactComponent) {
        f = lc(c, b.legacyContext)
        var e = c.contextType
        e = new c(d, 'object' === typeof e && null !== e ? e._currentValue : f)
        rc(e, c, d, f)
        Xc(a, b, e, c)
      } else {
        e = lc(c, b.legacyContext)
        f = Wc(a, b, c, d, e)
        var g = 0 !== U
        if (
          'object' === typeof f &&
          null !== f &&
          'function' === typeof f.render &&
          void 0 === f.$$typeof
        )
          rc(f, c, d, e), Xc(a, b, f, c)
        else if (g) {
          d = b.treeContext
          b.treeContext = tc(d, 1, 0)
          try {
            Z(a, b, f)
          } finally {
            b.treeContext = d
          }
        } else Z(a, b, f)
      }
    else if ('string' === typeof c) {
      f = b.blockedSegment
      e = Sa(f.chunks, c, d, a.responseState, f.formatContext)
      f.lastPushedText = false
      g = f.formatContext
      f.formatContext = Ba(g, c, d)
      $c(a, b, e)
      f.formatContext = g
      switch (c) {
        case 'area':
        case 'base':
        case 'br':
        case 'col':
        case 'embed':
        case 'hr':
        case 'img':
        case 'input':
        case 'keygen':
        case 'link':
        case 'meta':
        case 'param':
        case 'source':
        case 'track':
        case 'wbr':
          break
        default:
          f.chunks.push(Ta, u(c), Ua)
      }
      f.lastPushedText = false
    } else {
      switch (c) {
        case gc:
        case fc:
        case Wb:
        case Xb:
        case Vb:
          Z(a, b, d.children)
          return
        case bc:
          Z(a, b, d.children)
          return
        case ec:
          throw Error(k(343))
        case ac:
          a: {
            c = b.blockedBoundary
            f = b.blockedSegment
            e = d.fallback
            d = d.children
            g = /* @__PURE__ */ new Set()
            var h = {
                id: null,
                rootSegmentID: -1,
                parentFlushed: false,
                pendingTasks: 0,
                forceClientRender: false,
                completedSegments: [],
                byteSize: 0,
                fallbackAbortableTasks: g,
                errorDigest: null,
              },
              m = Sc(a, f.chunks.length, h, f.formatContext, false, false)
            f.children.push(m)
            f.lastPushedText = false
            var q = Sc(a, 0, null, f.formatContext, false, false)
            q.parentFlushed = true
            b.blockedBoundary = h
            b.blockedSegment = q
            try {
              if (
                ($c(a, b, d),
                q.lastPushedText && q.textEmbedded && q.chunks.push(Ca),
                (q.status = 1),
                ad(h, q),
                0 === h.pendingTasks)
              )
                break a
            } catch (r) {
              ;(q.status = 4),
                (h.forceClientRender = true),
                (h.errorDigest = Y(a, r))
            } finally {
              ;(b.blockedBoundary = c), (b.blockedSegment = f)
            }
            b = Tc(a, e, c, m, g, b.legacyContext, b.context, b.treeContext)
            a.pingedTasks.push(b)
          }
          return
      }
      if ('object' === typeof c && null !== c)
        switch (c.$$typeof) {
          case $b:
            d = Wc(a, b, c.render, d, f)
            if (0 !== U) {
              c = b.treeContext
              b.treeContext = tc(c, 1, 0)
              try {
                Z(a, b, d)
              } finally {
                b.treeContext = c
              }
            } else Z(a, b, d)
            return
          case cc:
            c = c.type
            d = Yc(c, d)
            Zc(a, b, c, d, f)
            return
          case Yb:
            f = d.children
            c = c._context
            d = d.value
            e = c._currentValue
            c._currentValue = d
            g = O
            O = d = {
              parent: g,
              depth: null === g ? 0 : g.depth + 1,
              context: c,
              parentValue: e,
              value: d,
            }
            b.context = d
            Z(a, b, f)
            a = O
            if (null === a) throw Error(k(403))
            d = a.parentValue
            a.context._currentValue = d === hc ? a.context._defaultValue : d
            a = O = a.parent
            b.context = a
            return
          case Zb:
            d = d.children
            d = d(c._currentValue)
            Z(a, b, d)
            return
          case dc:
            f = c._init
            c = f(c._payload)
            d = Yc(c, d)
            Zc(a, b, c, d, void 0)
            return
        }
      throw Error(k(130, null == c ? c : typeof c, ''))
    }
  }
  function Z(a, b, c) {
    b.node = c
    if ('object' === typeof c && null !== c) {
      switch (c.$$typeof) {
        case Tb:
          Zc(a, b, c.type, c.props, c.ref)
          return
        case Ub:
          throw Error(k(257))
        case dc:
          var d = c._init
          c = d(c._payload)
          Z(a, b, c)
          return
      }
      if (ra(c)) {
        bd(a, b, c)
        return
      }
      null === c || 'object' !== typeof c
        ? (d = null)
        : ((d = (ic && c[ic]) || c['@@iterator']),
          (d = 'function' === typeof d ? d : null))
      if (d && (d = d.call(c))) {
        c = d.next()
        if (!c.done) {
          var f = []
          do f.push(c.value), (c = d.next())
          while (!c.done)
          bd(a, b, f)
        }
        return
      }
      a = Object.prototype.toString.call(c)
      throw Error(
        k(
          31,
          '[object Object]' === a
            ? 'object with keys {' + Object.keys(c).join(', ') + '}'
            : a,
        ),
      )
    }
    'string' === typeof c
      ? ((d = b.blockedSegment),
        (d.lastPushedText = Da(
          b.blockedSegment.chunks,
          c,
          a.responseState,
          d.lastPushedText,
        )))
      : 'number' === typeof c &&
        ((d = b.blockedSegment),
        (d.lastPushedText = Da(
          b.blockedSegment.chunks,
          '' + c,
          a.responseState,
          d.lastPushedText,
        )))
  }
  function bd(a, b, c) {
    for (var d = c.length, f = 0; f < d; f++) {
      var e = b.treeContext
      b.treeContext = tc(e, d, f)
      try {
        $c(a, b, c[f])
      } finally {
        b.treeContext = e
      }
    }
  }
  function $c(a, b, c) {
    var d = b.blockedSegment.formatContext,
      f = b.legacyContext,
      e = b.context
    try {
      return Z(a, b, c)
    } catch (m) {
      if (
        (Gc(),
        'object' === typeof m && null !== m && 'function' === typeof m.then)
      ) {
        c = m
        var g = b.blockedSegment,
          h = Sc(
            a,
            g.chunks.length,
            null,
            g.formatContext,
            g.lastPushedText,
            true,
          )
        g.children.push(h)
        g.lastPushedText = false
        a = Tc(
          a,
          b.node,
          b.blockedBoundary,
          h,
          b.abortSet,
          b.legacyContext,
          b.context,
          b.treeContext,
        ).ping
        c.then(a, a)
        b.blockedSegment.formatContext = d
        b.legacyContext = f
        b.context = e
        Q(e)
      } else
        throw (
          ((b.blockedSegment.formatContext = d),
          (b.legacyContext = f),
          (b.context = e),
          Q(e),
          m)
        )
    }
  }
  function cd(a) {
    var b = a.blockedBoundary
    a = a.blockedSegment
    a.status = 3
    dd(this, b, a)
  }
  function ed(a, b, c) {
    var d = a.blockedBoundary
    a.blockedSegment.status = 3
    null === d
      ? (b.allPendingTasks--,
        2 !== b.status &&
          ((b.status = 2), null !== b.destination && b.destination.close()))
      : (d.pendingTasks--,
        d.forceClientRender ||
          ((d.forceClientRender = true),
          (a = void 0 === c ? Error(k(432)) : c),
          (d.errorDigest = b.onError(a)),
          d.parentFlushed && b.clientRenderedBoundaries.push(d)),
        d.fallbackAbortableTasks.forEach(function (a2) {
          return ed(a2, b, c)
        }),
        d.fallbackAbortableTasks.clear(),
        b.allPendingTasks--,
        0 === b.allPendingTasks && ((d = b.onAllReady), d()))
  }
  function ad(a, b) {
    if (
      0 === b.chunks.length &&
      1 === b.children.length &&
      null === b.children[0].boundary
    ) {
      var c = b.children[0]
      c.id = b.id
      c.parentFlushed = true
      1 === c.status && ad(a, c)
    } else a.completedSegments.push(b)
  }
  function dd(a, b, c) {
    if (null === b) {
      if (c.parentFlushed) {
        if (null !== a.completedRootSegment) throw Error(k(389))
        a.completedRootSegment = c
      }
      a.pendingRootTasks--
      0 === a.pendingRootTasks &&
        ((a.onShellError = X), (b = a.onShellReady), b())
    } else
      b.pendingTasks--,
        b.forceClientRender ||
          (0 === b.pendingTasks
            ? (c.parentFlushed && 1 === c.status && ad(b, c),
              b.parentFlushed && a.completedBoundaries.push(b),
              b.fallbackAbortableTasks.forEach(cd, a),
              b.fallbackAbortableTasks.clear())
            : c.parentFlushed &&
              1 === c.status &&
              (ad(b, c),
              1 === b.completedSegments.length &&
                b.parentFlushed &&
                a.partialBoundaries.push(b)))
    a.allPendingTasks--
    0 === a.allPendingTasks && ((a = a.onAllReady), a())
  }
  function Uc(a) {
    if (2 !== a.status) {
      var b = O,
        c = Pc.current
      Pc.current = Oc
      var d = Nc
      Nc = a.responseState
      try {
        var f = a.pingedTasks,
          e
        for (e = 0; e < f.length; e++) {
          var g = f[e]
          var h = a,
            m = g.blockedSegment
          if (0 === m.status) {
            Q(g.context)
            try {
              Z(h, g, g.node),
                m.lastPushedText && m.textEmbedded && m.chunks.push(Ca),
                g.abortSet.delete(g),
                (m.status = 1),
                dd(h, g.blockedBoundary, m)
            } catch (G) {
              if (
                (Gc(),
                'object' === typeof G &&
                  null !== G &&
                  'function' === typeof G.then)
              ) {
                var q = g.ping
                G.then(q, q)
              } else {
                g.abortSet.delete(g)
                m.status = 4
                var r = g.blockedBoundary,
                  v = G,
                  A = Y(h, v)
                null === r
                  ? Vc(h, v)
                  : (r.pendingTasks--,
                    r.forceClientRender ||
                      ((r.forceClientRender = true),
                      (r.errorDigest = A),
                      r.parentFlushed && h.clientRenderedBoundaries.push(r)))
                h.allPendingTasks--
                if (0 === h.allPendingTasks) {
                  var F = h.onAllReady
                  F()
                }
              }
            } finally {
            }
          }
        }
        f.splice(0, e)
        null !== a.destination && fd(a, a.destination)
      } catch (G) {
        Y(a, G), Vc(a, G)
      } finally {
        ;(Nc = d), (Pc.current = c), c === Oc && Q(b)
      }
    }
  }
  function gd(a, b, c) {
    c.parentFlushed = true
    switch (c.status) {
      case 0:
        var d = (c.id = a.nextSegmentId++)
        c.lastPushedText = false
        c.textEmbedded = false
        a = a.responseState
        p(b, Va)
        p(b, a.placeholderPrefix)
        a = u(d.toString(16))
        p(b, a)
        return t(b, Wa)
      case 1:
        c.status = 2
        var f = true
        d = c.chunks
        var e = 0
        c = c.children
        for (var g = 0; g < c.length; g++) {
          for (f = c[g]; e < f.index; e++) p(b, d[e])
          f = hd(a, b, f)
        }
        for (; e < d.length - 1; e++) p(b, d[e])
        e < d.length && (f = t(b, d[e]))
        return f
      default:
        throw Error(k(390))
    }
  }
  function hd(a, b, c) {
    var d = c.boundary
    if (null === d) return gd(a, b, c)
    d.parentFlushed = true
    if (d.forceClientRender)
      (d = d.errorDigest),
        t(b, $a),
        p(b, bb),
        d && (p(b, db2), p(b, u(C(d))), p(b, cb)),
        t(b, eb),
        gd(a, b, c)
    else if (0 < d.pendingTasks) {
      d.rootSegmentID = a.nextSegmentId++
      0 < d.completedSegments.length && a.partialBoundaries.push(d)
      var f = a.responseState
      var e = f.nextSuspenseID++
      f = w(f.boundaryPrefix + e.toString(16))
      d = d.id = f
      fb(b, a.responseState, d)
      gd(a, b, c)
    } else if (d.byteSize > a.progressiveChunkSize)
      (d.rootSegmentID = a.nextSegmentId++),
        a.completedBoundaries.push(d),
        fb(b, a.responseState, d.id),
        gd(a, b, c)
    else {
      t(b, Xa)
      c = d.completedSegments
      if (1 !== c.length) throw Error(k(391))
      hd(a, b, c[0])
    }
    return t(b, ab)
  }
  function id(a, b, c) {
    Bb(b, a.responseState, c.formatContext, c.id)
    hd(a, b, c)
    return Cb(b, c.formatContext)
  }
  function jd(a, b, c) {
    for (var d = c.completedSegments, f = 0; f < d.length; f++)
      kd(a, b, c, d[f])
    d.length = 0
    a = a.responseState
    d = c.id
    c = c.rootSegmentID
    p(b, a.startInlineScript)
    a.sentCompleteBoundaryFunction
      ? p(b, Jb)
      : ((a.sentCompleteBoundaryFunction = true), p(b, Ib))
    if (null === d) throw Error(k(395))
    c = u(c.toString(16))
    p(b, d)
    p(b, Kb)
    p(b, a.segmentPrefix)
    p(b, c)
    return t(b, Lb)
  }
  function kd(a, b, c, d) {
    if (2 === d.status) return true
    var f = d.id
    if (-1 === f) {
      if (-1 === (d.id = c.rootSegmentID)) throw Error(k(392))
      return id(a, b, d)
    }
    id(a, b, d)
    a = a.responseState
    p(b, a.startInlineScript)
    a.sentCompleteSegmentFunction
      ? p(b, Eb)
      : ((a.sentCompleteSegmentFunction = true), p(b, Db))
    p(b, a.segmentPrefix)
    f = u(f.toString(16))
    p(b, f)
    p(b, Gb)
    p(b, a.placeholderPrefix)
    p(b, f)
    return t(b, Hb)
  }
  function fd(a, b) {
    l = new Uint8Array(512)
    n = 0
    try {
      var c = a.completedRootSegment
      if (null !== c && 0 === a.pendingRootTasks) {
        hd(a, b, c)
        a.completedRootSegment = null
        var d = a.responseState.bootstrapChunks
        for (c = 0; c < d.length - 1; c++) p(b, d[c])
        c < d.length && t(b, d[c])
      }
      var f = a.clientRenderedBoundaries,
        e
      for (e = 0; e < f.length; e++) {
        var g = f[e]
        d = b
        var h = a.responseState,
          m = g.id,
          q = g.errorDigest,
          r = g.errorMessage,
          v = g.errorComponentStack
        p(d, h.startInlineScript)
        h.sentClientRenderFunction
          ? p(d, Nb)
          : ((h.sentClientRenderFunction = true), p(d, Mb))
        if (null === m) throw Error(k(395))
        p(d, m)
        p(d, Ob)
        if (q || r || v) p(d, Qb), p(d, u(Sb(q || '')))
        if (r || v) p(d, Qb), p(d, u(Sb(r || '')))
        v && (p(d, Qb), p(d, u(Sb(v))))
        if (!t(d, Pb));
      }
      f.splice(0, e)
      var A = a.completedBoundaries
      for (e = 0; e < A.length; e++) if (!jd(a, b, A[e]));
      A.splice(0, e)
      ba(b)
      l = new Uint8Array(512)
      n = 0
      var F = a.partialBoundaries
      for (e = 0; e < F.length; e++) {
        var G = F[e]
        a: {
          f = a
          g = b
          var ma = G.completedSegments
          for (h = 0; h < ma.length; h++)
            if (!kd(f, g, G, ma[h])) {
              h++
              ma.splice(0, h)
              var Fb = false
              break a
            }
          ma.splice(0, h)
          Fb = true
        }
        if (!Fb) {
          a.destination = null
          e++
          F.splice(0, e)
          return
        }
      }
      F.splice(0, e)
      var na = a.completedBoundaries
      for (e = 0; e < na.length; e++) if (!jd(a, b, na[e]));
      na.splice(0, e)
    } finally {
      ba(b),
        0 === a.allPendingTasks &&
          0 === a.pingedTasks.length &&
          0 === a.clientRenderedBoundaries.length &&
          0 === a.completedBoundaries.length &&
          b.close()
    }
  }
  function ld(a, b) {
    try {
      var c = a.abortableTasks
      c.forEach(function (c2) {
        return ed(c2, a, b)
      })
      c.clear()
      null !== a.destination && fd(a, a.destination)
    } catch (d) {
      Y(a, d), Vc(a, d)
    }
  }
  reactDomServer_browser_production_min.renderToReadableStream = function (
    a,
    b,
  ) {
    return new Promise(function (c, d) {
      var f,
        e,
        g = new Promise(function (a2, b2) {
          e = a2
          f = b2
        }),
        h = Rc(
          a,
          za(
            b ? b.identifierPrefix : void 0,
            b ? b.nonce : void 0,
            b ? b.bootstrapScriptContent : void 0,
            b ? b.bootstrapScripts : void 0,
            b ? b.bootstrapModules : void 0,
          ),
          Aa(b ? b.namespaceURI : void 0),
          b ? b.progressiveChunkSize : void 0,
          b ? b.onError : void 0,
          e,
          function () {
            var a2 = new ReadableStream(
              {
                type: 'bytes',
                pull: function (a3) {
                  if (1 === h.status) (h.status = 2), da(a3, h.fatalError)
                  else if (2 !== h.status && null === h.destination) {
                    h.destination = a3
                    try {
                      fd(h, a3)
                    } catch (A) {
                      Y(h, A), Vc(h, A)
                    }
                  }
                },
                cancel: function () {
                  ld(h)
                },
              },
              {highWaterMark: 0},
            )
            a2.allReady = g
            c(a2)
          },
          function (a2) {
            g.catch(function () {})
            d(a2)
          },
          f,
        )
      if (b && b.signal) {
        var m = b.signal,
          q = function () {
            ld(h, m.reason)
            m.removeEventListener('abort', q)
          }
        m.addEventListener('abort', q)
      }
      Uc(h)
    })
  }
  reactDomServer_browser_production_min.version = '18.2.0'
  return reactDomServer_browser_production_min
}
var reactDomServerLegacy_browser_development = {}
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServerLegacy_browser_development
function requireReactDomServerLegacy_browser_development() {
  if (hasRequiredReactDomServerLegacy_browser_development)
    return reactDomServerLegacy_browser_development
  hasRequiredReactDomServerLegacy_browser_development = 1
  if (process.env.NODE_ENV !== 'production') {
    ;(function () {
      var React2 = requireReact()
      var ReactVersion = '18.2.0'
      var ReactSharedInternals =
        React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      function warn(format2) {
        {
          {
            for (
              var _len = arguments.length,
                args = new Array(_len > 1 ? _len - 1 : 0),
                _key = 1;
              _key < _len;
              _key++
            ) {
              args[_key - 1] = arguments[_key]
            }
            printWarning('warn', format2, args)
          }
        }
      }
      function error(format2) {
        {
          {
            for (
              var _len2 = arguments.length,
                args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                _key2 = 1;
              _key2 < _len2;
              _key2++
            ) {
              args[_key2 - 1] = arguments[_key2]
            }
            printWarning('error', format2, args)
          }
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 =
            ReactSharedInternals.ReactDebugCurrentFrame
          var stack = ReactDebugCurrentFrame2.getStackAddendum()
          if (stack !== '') {
            format2 += '%s'
            args = args.concat([stack])
          }
          var argsWithFormat = args.map(function (item) {
            return String(item)
          })
          argsWithFormat.unshift('Warning: ' + format2)
          Function.prototype.apply.call(console[level], console, argsWithFormat)
        }
      }
      function scheduleWork(callback) {
        callback()
      }
      function beginWriting(destination) {}
      function writeChunk(destination, chunk) {
        writeChunkAndReturn(destination, chunk)
      }
      function writeChunkAndReturn(destination, chunk) {
        return destination.push(chunk)
      }
      function completeWriting(destination) {}
      function close(destination) {
        destination.push(null)
      }
      function stringToChunk(content) {
        return content
      }
      function stringToPrecomputedChunk(content) {
        return content
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2)
      }
      function typeName(value) {
        {
          var hasToStringTag =
            typeof Symbol === 'function' && Symbol.toStringTag
          var type =
            (hasToStringTag && value[Symbol.toStringTag]) ||
            value.constructor.name ||
            'Object'
          return type
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value)
            return false
          } catch (e) {
            return true
          }
        }
      }
      function testStringCoercion(value) {
        return '' + value
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error(
              'The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.',
              attributeName,
              typeName(value),
            )
            return testStringCoercion(value)
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error(
              'The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.',
              propName,
              typeName(value),
            )
            return testStringCoercion(value)
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error(
              'The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.',
              typeName(value),
            )
            return testStringCoercion(value)
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty
      var RESERVED = 0
      var STRING = 1
      var BOOLEANISH_STRING = 2
      var BOOLEAN = 3
      var OVERLOADED_BOOLEAN = 4
      var NUMERIC = 5
      var POSITIVE_NUMERIC = 6
      var ATTRIBUTE_NAME_START_CHAR =
        ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD'
      var ATTRIBUTE_NAME_CHAR =
        ATTRIBUTE_NAME_START_CHAR +
        '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040'
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(
        '^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$',
      )
      var illegalAttributeNameCache = {}
      var validatedAttributeNameCache = {}
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true
          return true
        }
        illegalAttributeNameCache[attributeName] = true
        {
          error('Invalid attribute name: `%s`', attributeName)
        }
        return false
      }
      function shouldRemoveAttributeWithWarning(
        name,
        value,
        propertyInfo,
        isCustomComponentTag,
      ) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false
        }
        switch (typeof value) {
          case 'function':
          // $FlowIssue symbol is perfectly valid here
          case 'symbol':
            return true
          case 'boolean': {
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5)
              return prefix2 !== 'data-' && prefix2 !== 'aria-'
            }
          }
          default:
            return false
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null
      }
      function PropertyInfoRecord(
        name,
        type,
        mustUseProperty,
        attributeName,
        attributeNamespace,
        sanitizeURL2,
        removeEmptyString,
      ) {
        this.acceptsBooleans =
          type === BOOLEANISH_STRING ||
          type === BOOLEAN ||
          type === OVERLOADED_BOOLEAN
        this.attributeName = attributeName
        this.attributeNamespace = attributeNamespace
        this.mustUseProperty = mustUseProperty
        this.propertyName = name
        this.type = type
        this.sanitizeURL = sanitizeURL2
        this.removeEmptyString = removeEmptyString
      }
      var properties = {}
      var reservedProps = [
        'children',
        'dangerouslySetInnerHTML',
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        'defaultValue',
        'defaultChecked',
        'innerHTML',
        'suppressContentEditableWarning',
        'suppressHydrationWarning',
        'style',
      ]
      reservedProps.forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        ['acceptCharset', 'accept-charset'],
        ['className', 'class'],
        ['htmlFor', 'for'],
        ['httpEquiv', 'http-equiv'],
      ].forEach(function (_ref) {
        var name = _ref[0],
          attributeName = _ref[1]
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(
        function (name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false,
          )
        },
      )
      ;[
        'autoReverse',
        'externalResourcesRequired',
        'focusable',
        'preserveAlpha',
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'allowFullScreen',
        'async',
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        'autoFocus',
        'autoPlay',
        'controls',
        'default',
        'defer',
        'disabled',
        'disablePictureInPicture',
        'disableRemotePlayback',
        'formNoValidate',
        'hidden',
        'loop',
        'noModule',
        'noValidate',
        'open',
        'playsInline',
        'readOnly',
        'required',
        'reversed',
        'scoped',
        'seamless',
        // Microdata
        'itemScope',
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'checked',
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        'multiple',
        'muted',
        'selected',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          true,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'capture',
        'download',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'cols',
        'rows',
        'size',
        'span',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;['rowSpan', 'start'].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      var CAMELIZE = /[\-\:]([a-z])/g
      var capitalize = function (token) {
        return token[1].toUpperCase()
      }
      ;[
        'accent-height',
        'alignment-baseline',
        'arabic-form',
        'baseline-shift',
        'cap-height',
        'clip-path',
        'clip-rule',
        'color-interpolation',
        'color-interpolation-filters',
        'color-profile',
        'color-rendering',
        'dominant-baseline',
        'enable-background',
        'fill-opacity',
        'fill-rule',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'glyph-name',
        'glyph-orientation-horizontal',
        'glyph-orientation-vertical',
        'horiz-adv-x',
        'horiz-origin-x',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'overline-position',
        'overline-thickness',
        'paint-order',
        'panose-1',
        'pointer-events',
        'rendering-intent',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'strikethrough-position',
        'strikethrough-thickness',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-rendering',
        'underline-position',
        'underline-thickness',
        'unicode-bidi',
        'unicode-range',
        'units-per-em',
        'v-alphabetic',
        'v-hanging',
        'v-ideographic',
        'v-mathematical',
        'vector-effect',
        'vert-adv-y',
        'vert-origin-x',
        'vert-origin-y',
        'word-spacing',
        'writing-mode',
        'xmlns:xlink',
        'x-height',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize)
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'xlink:actuate',
        'xlink:arcrole',
        'xlink:role',
        'xlink:show',
        'xlink:title',
        'xlink:type',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize)
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          'http://www.w3.org/1999/xlink',
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'xml:base',
        'xml:lang',
        'xml:space',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize)
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          'http://www.w3.org/XML/1998/namespace',
          false,
          // sanitizeURL
          false,
        )
      })
      ;['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      var xlinkHref = 'xlinkHref'
      properties[xlinkHref] = new PropertyInfoRecord(
        'xlinkHref',
        STRING,
        false,
        // mustUseProperty
        'xlink:href',
        'http://www.w3.org/1999/xlink',
        true,
        // sanitizeURL
        false,
      )
      ;['src', 'href', 'action', 'formAction'].forEach(
        function (attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true,
          )
        },
      )
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true,
      }
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1)
      }
      var prefixes = ['Webkit', 'ms', 'Moz', 'O']
      Object.keys(isUnitlessNumber).forEach(function (prop) {
        prefixes.forEach(function (prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop]
        })
      })
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true,
      }
      function checkControlledValueProps(tagName, props) {
        {
          if (
            !(
              hasReadOnlyValue[props.type] ||
              props.onChange ||
              props.onInput ||
              props.readOnly ||
              props.disabled ||
              props.value == null
            )
          ) {
            error(
              'You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.',
            )
          }
          if (
            !(
              props.onChange ||
              props.readOnly ||
              props.disabled ||
              props.checked == null
            )
          ) {
            error(
              'You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.',
            )
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf('-') === -1) {
          return typeof props.is === 'string'
        }
        switch (tagName) {
          // These are reserved SVG and MathML elements.
          // We don't mind this list too much because we expect it to never grow.
          // The alternative is to track the namespace in a few places which is convoluted.
          // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
          case 'annotation-xml':
          case 'color-profile':
          case 'font-face':
          case 'font-face-src':
          case 'font-face-uri':
          case 'font-face-format':
          case 'font-face-name':
          case 'missing-glyph':
            return false
          default:
            return true
        }
      }
      var ariaProperties = {
        'aria-current': 0,
        // state
        'aria-description': 0,
        'aria-details': 0,
        'aria-disabled': 0,
        // state
        'aria-hidden': 0,
        // state
        'aria-invalid': 0,
        // state
        'aria-keyshortcuts': 0,
        'aria-label': 0,
        'aria-roledescription': 0,
        // Widget Attributes
        'aria-autocomplete': 0,
        'aria-checked': 0,
        'aria-expanded': 0,
        'aria-haspopup': 0,
        'aria-level': 0,
        'aria-modal': 0,
        'aria-multiline': 0,
        'aria-multiselectable': 0,
        'aria-orientation': 0,
        'aria-placeholder': 0,
        'aria-pressed': 0,
        'aria-readonly': 0,
        'aria-required': 0,
        'aria-selected': 0,
        'aria-sort': 0,
        'aria-valuemax': 0,
        'aria-valuemin': 0,
        'aria-valuenow': 0,
        'aria-valuetext': 0,
        // Live Region Attributes
        'aria-atomic': 0,
        'aria-busy': 0,
        'aria-live': 0,
        'aria-relevant': 0,
        // Drag-and-Drop Attributes
        'aria-dropeffect': 0,
        'aria-grabbed': 0,
        // Relationship Attributes
        'aria-activedescendant': 0,
        'aria-colcount': 0,
        'aria-colindex': 0,
        'aria-colspan': 0,
        'aria-controls': 0,
        'aria-describedby': 0,
        'aria-errormessage': 0,
        'aria-flowto': 0,
        'aria-labelledby': 0,
        'aria-owns': 0,
        'aria-posinset': 0,
        'aria-rowcount': 0,
        'aria-rowindex': 0,
        'aria-rowspan': 0,
        'aria-setsize': 0,
      }
      var warnedProperties = {}
      var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$')
      var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$')
      function validateProperty(tagName, name) {
        {
          if (
            hasOwnProperty.call(warnedProperties, name) &&
            warnedProperties[name]
          ) {
            return true
          }
          if (rARIACamel.test(name)) {
            var ariaName = 'aria-' + name.slice(4).toLowerCase()
            var correctName = ariaProperties.hasOwnProperty(ariaName)
              ? ariaName
              : null
            if (correctName == null) {
              error(
                'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',
                name,
              )
              warnedProperties[name] = true
              return true
            }
            if (name !== correctName) {
              error(
                'Invalid ARIA attribute `%s`. Did you mean `%s`?',
                name,
                correctName,
              )
              warnedProperties[name] = true
              return true
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase()
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName)
              ? lowerCasedName
              : null
            if (standardName == null) {
              warnedProperties[name] = true
              return false
            }
            if (name !== standardName) {
              error(
                'Unknown ARIA attribute `%s`. Did you mean `%s`?',
                name,
                standardName,
              )
              warnedProperties[name] = true
              return true
            }
          }
        }
        return true
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = []
          for (var key in props) {
            var isValid2 = validateProperty(type, key)
            if (!isValid2) {
              invalidProps.push(key)
            }
          }
          var unknownPropString = invalidProps
            .map(function (prop) {
              return '`' + prop + '`'
            })
            .join(', ')
          if (invalidProps.length === 1) {
            error(
              'Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
              unknownPropString,
              type,
            )
          } else if (invalidProps.length > 1) {
            error(
              'Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
              unknownPropString,
              type,
            )
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return
        }
        warnInvalidARIAProps(type, props)
      }
      var didWarnValueNull = false
      function validateProperties$1(type, props) {
        {
          if (type !== 'input' && type !== 'textarea' && type !== 'select') {
            return
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true
            if (type === 'select' && props.multiple) {
              error(
                '`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.',
                type,
              )
            } else {
              error(
                '`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.',
                type,
              )
            }
          }
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: 'accept',
        acceptcharset: 'acceptCharset',
        'accept-charset': 'acceptCharset',
        accesskey: 'accessKey',
        action: 'action',
        allowfullscreen: 'allowFullScreen',
        alt: 'alt',
        as: 'as',
        async: 'async',
        autocapitalize: 'autoCapitalize',
        autocomplete: 'autoComplete',
        autocorrect: 'autoCorrect',
        autofocus: 'autoFocus',
        autoplay: 'autoPlay',
        autosave: 'autoSave',
        capture: 'capture',
        cellpadding: 'cellPadding',
        cellspacing: 'cellSpacing',
        challenge: 'challenge',
        charset: 'charSet',
        checked: 'checked',
        children: 'children',
        cite: 'cite',
        class: 'className',
        classid: 'classID',
        classname: 'className',
        cols: 'cols',
        colspan: 'colSpan',
        content: 'content',
        contenteditable: 'contentEditable',
        contextmenu: 'contextMenu',
        controls: 'controls',
        controlslist: 'controlsList',
        coords: 'coords',
        crossorigin: 'crossOrigin',
        dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
        data: 'data',
        datetime: 'dateTime',
        default: 'default',
        defaultchecked: 'defaultChecked',
        defaultvalue: 'defaultValue',
        defer: 'defer',
        dir: 'dir',
        disabled: 'disabled',
        disablepictureinpicture: 'disablePictureInPicture',
        disableremoteplayback: 'disableRemotePlayback',
        download: 'download',
        draggable: 'draggable',
        enctype: 'encType',
        enterkeyhint: 'enterKeyHint',
        for: 'htmlFor',
        form: 'form',
        formmethod: 'formMethod',
        formaction: 'formAction',
        formenctype: 'formEncType',
        formnovalidate: 'formNoValidate',
        formtarget: 'formTarget',
        frameborder: 'frameBorder',
        headers: 'headers',
        height: 'height',
        hidden: 'hidden',
        high: 'high',
        href: 'href',
        hreflang: 'hrefLang',
        htmlfor: 'htmlFor',
        httpequiv: 'httpEquiv',
        'http-equiv': 'httpEquiv',
        icon: 'icon',
        id: 'id',
        imagesizes: 'imageSizes',
        imagesrcset: 'imageSrcSet',
        innerhtml: 'innerHTML',
        inputmode: 'inputMode',
        integrity: 'integrity',
        is: 'is',
        itemid: 'itemID',
        itemprop: 'itemProp',
        itemref: 'itemRef',
        itemscope: 'itemScope',
        itemtype: 'itemType',
        keyparams: 'keyParams',
        keytype: 'keyType',
        kind: 'kind',
        label: 'label',
        lang: 'lang',
        list: 'list',
        loop: 'loop',
        low: 'low',
        manifest: 'manifest',
        marginwidth: 'marginWidth',
        marginheight: 'marginHeight',
        max: 'max',
        maxlength: 'maxLength',
        media: 'media',
        mediagroup: 'mediaGroup',
        method: 'method',
        min: 'min',
        minlength: 'minLength',
        multiple: 'multiple',
        muted: 'muted',
        name: 'name',
        nomodule: 'noModule',
        nonce: 'nonce',
        novalidate: 'noValidate',
        open: 'open',
        optimum: 'optimum',
        pattern: 'pattern',
        placeholder: 'placeholder',
        playsinline: 'playsInline',
        poster: 'poster',
        preload: 'preload',
        profile: 'profile',
        radiogroup: 'radioGroup',
        readonly: 'readOnly',
        referrerpolicy: 'referrerPolicy',
        rel: 'rel',
        required: 'required',
        reversed: 'reversed',
        role: 'role',
        rows: 'rows',
        rowspan: 'rowSpan',
        sandbox: 'sandbox',
        scope: 'scope',
        scoped: 'scoped',
        scrolling: 'scrolling',
        seamless: 'seamless',
        selected: 'selected',
        shape: 'shape',
        size: 'size',
        sizes: 'sizes',
        span: 'span',
        spellcheck: 'spellCheck',
        src: 'src',
        srcdoc: 'srcDoc',
        srclang: 'srcLang',
        srcset: 'srcSet',
        start: 'start',
        step: 'step',
        style: 'style',
        summary: 'summary',
        tabindex: 'tabIndex',
        target: 'target',
        title: 'title',
        type: 'type',
        usemap: 'useMap',
        value: 'value',
        width: 'width',
        wmode: 'wmode',
        wrap: 'wrap',
        // SVG
        about: 'about',
        accentheight: 'accentHeight',
        'accent-height': 'accentHeight',
        accumulate: 'accumulate',
        additive: 'additive',
        alignmentbaseline: 'alignmentBaseline',
        'alignment-baseline': 'alignmentBaseline',
        allowreorder: 'allowReorder',
        alphabetic: 'alphabetic',
        amplitude: 'amplitude',
        arabicform: 'arabicForm',
        'arabic-form': 'arabicForm',
        ascent: 'ascent',
        attributename: 'attributeName',
        attributetype: 'attributeType',
        autoreverse: 'autoReverse',
        azimuth: 'azimuth',
        basefrequency: 'baseFrequency',
        baselineshift: 'baselineShift',
        'baseline-shift': 'baselineShift',
        baseprofile: 'baseProfile',
        bbox: 'bbox',
        begin: 'begin',
        bias: 'bias',
        by: 'by',
        calcmode: 'calcMode',
        capheight: 'capHeight',
        'cap-height': 'capHeight',
        clip: 'clip',
        clippath: 'clipPath',
        'clip-path': 'clipPath',
        clippathunits: 'clipPathUnits',
        cliprule: 'clipRule',
        'clip-rule': 'clipRule',
        color: 'color',
        colorinterpolation: 'colorInterpolation',
        'color-interpolation': 'colorInterpolation',
        colorinterpolationfilters: 'colorInterpolationFilters',
        'color-interpolation-filters': 'colorInterpolationFilters',
        colorprofile: 'colorProfile',
        'color-profile': 'colorProfile',
        colorrendering: 'colorRendering',
        'color-rendering': 'colorRendering',
        contentscripttype: 'contentScriptType',
        contentstyletype: 'contentStyleType',
        cursor: 'cursor',
        cx: 'cx',
        cy: 'cy',
        d: 'd',
        datatype: 'datatype',
        decelerate: 'decelerate',
        descent: 'descent',
        diffuseconstant: 'diffuseConstant',
        direction: 'direction',
        display: 'display',
        divisor: 'divisor',
        dominantbaseline: 'dominantBaseline',
        'dominant-baseline': 'dominantBaseline',
        dur: 'dur',
        dx: 'dx',
        dy: 'dy',
        edgemode: 'edgeMode',
        elevation: 'elevation',
        enablebackground: 'enableBackground',
        'enable-background': 'enableBackground',
        end: 'end',
        exponent: 'exponent',
        externalresourcesrequired: 'externalResourcesRequired',
        fill: 'fill',
        fillopacity: 'fillOpacity',
        'fill-opacity': 'fillOpacity',
        fillrule: 'fillRule',
        'fill-rule': 'fillRule',
        filter: 'filter',
        filterres: 'filterRes',
        filterunits: 'filterUnits',
        floodopacity: 'floodOpacity',
        'flood-opacity': 'floodOpacity',
        floodcolor: 'floodColor',
        'flood-color': 'floodColor',
        focusable: 'focusable',
        fontfamily: 'fontFamily',
        'font-family': 'fontFamily',
        fontsize: 'fontSize',
        'font-size': 'fontSize',
        fontsizeadjust: 'fontSizeAdjust',
        'font-size-adjust': 'fontSizeAdjust',
        fontstretch: 'fontStretch',
        'font-stretch': 'fontStretch',
        fontstyle: 'fontStyle',
        'font-style': 'fontStyle',
        fontvariant: 'fontVariant',
        'font-variant': 'fontVariant',
        fontweight: 'fontWeight',
        'font-weight': 'fontWeight',
        format: 'format',
        from: 'from',
        fx: 'fx',
        fy: 'fy',
        g1: 'g1',
        g2: 'g2',
        glyphname: 'glyphName',
        'glyph-name': 'glyphName',
        glyphorientationhorizontal: 'glyphOrientationHorizontal',
        'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
        glyphorientationvertical: 'glyphOrientationVertical',
        'glyph-orientation-vertical': 'glyphOrientationVertical',
        glyphref: 'glyphRef',
        gradienttransform: 'gradientTransform',
        gradientunits: 'gradientUnits',
        hanging: 'hanging',
        horizadvx: 'horizAdvX',
        'horiz-adv-x': 'horizAdvX',
        horizoriginx: 'horizOriginX',
        'horiz-origin-x': 'horizOriginX',
        ideographic: 'ideographic',
        imagerendering: 'imageRendering',
        'image-rendering': 'imageRendering',
        in2: 'in2',
        in: 'in',
        inlist: 'inlist',
        intercept: 'intercept',
        k1: 'k1',
        k2: 'k2',
        k3: 'k3',
        k4: 'k4',
        k: 'k',
        kernelmatrix: 'kernelMatrix',
        kernelunitlength: 'kernelUnitLength',
        kerning: 'kerning',
        keypoints: 'keyPoints',
        keysplines: 'keySplines',
        keytimes: 'keyTimes',
        lengthadjust: 'lengthAdjust',
        letterspacing: 'letterSpacing',
        'letter-spacing': 'letterSpacing',
        lightingcolor: 'lightingColor',
        'lighting-color': 'lightingColor',
        limitingconeangle: 'limitingConeAngle',
        local: 'local',
        markerend: 'markerEnd',
        'marker-end': 'markerEnd',
        markerheight: 'markerHeight',
        markermid: 'markerMid',
        'marker-mid': 'markerMid',
        markerstart: 'markerStart',
        'marker-start': 'markerStart',
        markerunits: 'markerUnits',
        markerwidth: 'markerWidth',
        mask: 'mask',
        maskcontentunits: 'maskContentUnits',
        maskunits: 'maskUnits',
        mathematical: 'mathematical',
        mode: 'mode',
        numoctaves: 'numOctaves',
        offset: 'offset',
        opacity: 'opacity',
        operator: 'operator',
        order: 'order',
        orient: 'orient',
        orientation: 'orientation',
        origin: 'origin',
        overflow: 'overflow',
        overlineposition: 'overlinePosition',
        'overline-position': 'overlinePosition',
        overlinethickness: 'overlineThickness',
        'overline-thickness': 'overlineThickness',
        paintorder: 'paintOrder',
        'paint-order': 'paintOrder',
        panose1: 'panose1',
        'panose-1': 'panose1',
        pathlength: 'pathLength',
        patterncontentunits: 'patternContentUnits',
        patterntransform: 'patternTransform',
        patternunits: 'patternUnits',
        pointerevents: 'pointerEvents',
        'pointer-events': 'pointerEvents',
        points: 'points',
        pointsatx: 'pointsAtX',
        pointsaty: 'pointsAtY',
        pointsatz: 'pointsAtZ',
        prefix: 'prefix',
        preservealpha: 'preserveAlpha',
        preserveaspectratio: 'preserveAspectRatio',
        primitiveunits: 'primitiveUnits',
        property: 'property',
        r: 'r',
        radius: 'radius',
        refx: 'refX',
        refy: 'refY',
        renderingintent: 'renderingIntent',
        'rendering-intent': 'renderingIntent',
        repeatcount: 'repeatCount',
        repeatdur: 'repeatDur',
        requiredextensions: 'requiredExtensions',
        requiredfeatures: 'requiredFeatures',
        resource: 'resource',
        restart: 'restart',
        result: 'result',
        results: 'results',
        rotate: 'rotate',
        rx: 'rx',
        ry: 'ry',
        scale: 'scale',
        security: 'security',
        seed: 'seed',
        shaperendering: 'shapeRendering',
        'shape-rendering': 'shapeRendering',
        slope: 'slope',
        spacing: 'spacing',
        specularconstant: 'specularConstant',
        specularexponent: 'specularExponent',
        speed: 'speed',
        spreadmethod: 'spreadMethod',
        startoffset: 'startOffset',
        stddeviation: 'stdDeviation',
        stemh: 'stemh',
        stemv: 'stemv',
        stitchtiles: 'stitchTiles',
        stopcolor: 'stopColor',
        'stop-color': 'stopColor',
        stopopacity: 'stopOpacity',
        'stop-opacity': 'stopOpacity',
        strikethroughposition: 'strikethroughPosition',
        'strikethrough-position': 'strikethroughPosition',
        strikethroughthickness: 'strikethroughThickness',
        'strikethrough-thickness': 'strikethroughThickness',
        string: 'string',
        stroke: 'stroke',
        strokedasharray: 'strokeDasharray',
        'stroke-dasharray': 'strokeDasharray',
        strokedashoffset: 'strokeDashoffset',
        'stroke-dashoffset': 'strokeDashoffset',
        strokelinecap: 'strokeLinecap',
        'stroke-linecap': 'strokeLinecap',
        strokelinejoin: 'strokeLinejoin',
        'stroke-linejoin': 'strokeLinejoin',
        strokemiterlimit: 'strokeMiterlimit',
        'stroke-miterlimit': 'strokeMiterlimit',
        strokewidth: 'strokeWidth',
        'stroke-width': 'strokeWidth',
        strokeopacity: 'strokeOpacity',
        'stroke-opacity': 'strokeOpacity',
        suppresscontenteditablewarning: 'suppressContentEditableWarning',
        suppresshydrationwarning: 'suppressHydrationWarning',
        surfacescale: 'surfaceScale',
        systemlanguage: 'systemLanguage',
        tablevalues: 'tableValues',
        targetx: 'targetX',
        targety: 'targetY',
        textanchor: 'textAnchor',
        'text-anchor': 'textAnchor',
        textdecoration: 'textDecoration',
        'text-decoration': 'textDecoration',
        textlength: 'textLength',
        textrendering: 'textRendering',
        'text-rendering': 'textRendering',
        to: 'to',
        transform: 'transform',
        typeof: 'typeof',
        u1: 'u1',
        u2: 'u2',
        underlineposition: 'underlinePosition',
        'underline-position': 'underlinePosition',
        underlinethickness: 'underlineThickness',
        'underline-thickness': 'underlineThickness',
        unicode: 'unicode',
        unicodebidi: 'unicodeBidi',
        'unicode-bidi': 'unicodeBidi',
        unicoderange: 'unicodeRange',
        'unicode-range': 'unicodeRange',
        unitsperem: 'unitsPerEm',
        'units-per-em': 'unitsPerEm',
        unselectable: 'unselectable',
        valphabetic: 'vAlphabetic',
        'v-alphabetic': 'vAlphabetic',
        values: 'values',
        vectoreffect: 'vectorEffect',
        'vector-effect': 'vectorEffect',
        version: 'version',
        vertadvy: 'vertAdvY',
        'vert-adv-y': 'vertAdvY',
        vertoriginx: 'vertOriginX',
        'vert-origin-x': 'vertOriginX',
        vertoriginy: 'vertOriginY',
        'vert-origin-y': 'vertOriginY',
        vhanging: 'vHanging',
        'v-hanging': 'vHanging',
        videographic: 'vIdeographic',
        'v-ideographic': 'vIdeographic',
        viewbox: 'viewBox',
        viewtarget: 'viewTarget',
        visibility: 'visibility',
        vmathematical: 'vMathematical',
        'v-mathematical': 'vMathematical',
        vocab: 'vocab',
        widths: 'widths',
        wordspacing: 'wordSpacing',
        'word-spacing': 'wordSpacing',
        writingmode: 'writingMode',
        'writing-mode': 'writingMode',
        x1: 'x1',
        x2: 'x2',
        x: 'x',
        xchannelselector: 'xChannelSelector',
        xheight: 'xHeight',
        'x-height': 'xHeight',
        xlinkactuate: 'xlinkActuate',
        'xlink:actuate': 'xlinkActuate',
        xlinkarcrole: 'xlinkArcrole',
        'xlink:arcrole': 'xlinkArcrole',
        xlinkhref: 'xlinkHref',
        'xlink:href': 'xlinkHref',
        xlinkrole: 'xlinkRole',
        'xlink:role': 'xlinkRole',
        xlinkshow: 'xlinkShow',
        'xlink:show': 'xlinkShow',
        xlinktitle: 'xlinkTitle',
        'xlink:title': 'xlinkTitle',
        xlinktype: 'xlinkType',
        'xlink:type': 'xlinkType',
        xmlbase: 'xmlBase',
        'xml:base': 'xmlBase',
        xmllang: 'xmlLang',
        'xml:lang': 'xmlLang',
        xmlns: 'xmlns',
        'xml:space': 'xmlSpace',
        xmlnsxlink: 'xmlnsXlink',
        'xmlns:xlink': 'xmlnsXlink',
        xmlspace: 'xmlSpace',
        y1: 'y1',
        y2: 'y2',
        y: 'y',
        ychannelselector: 'yChannelSelector',
        z: 'z',
        zoomandpan: 'zoomAndPan',
      }
      var validateProperty$1 = function () {}
      {
        var warnedProperties$1 = {}
        var EVENT_NAME_REGEX = /^on./
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/
        var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$')
        var rARIACamel$1 = new RegExp(
          '^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$',
        )
        validateProperty$1 = function (tagName, name, value, eventRegistry) {
          if (
            hasOwnProperty.call(warnedProperties$1, name) &&
            warnedProperties$1[name]
          ) {
            return true
          }
          var lowerCasedName = name.toLowerCase()
          if (
            lowerCasedName === 'onfocusin' ||
            lowerCasedName === 'onfocusout'
          ) {
            error(
              'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.',
            )
            warnedProperties$1[name] = true
            return true
          }
          if (eventRegistry != null) {
            var registrationNameDependencies =
                eventRegistry.registrationNameDependencies,
              possibleRegistrationNames =
                eventRegistry.possibleRegistrationNames
            if (registrationNameDependencies.hasOwnProperty(name)) {
              return true
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(
              lowerCasedName,
            )
              ? possibleRegistrationNames[lowerCasedName]
              : null
            if (registrationName != null) {
              error(
                'Invalid event handler property `%s`. Did you mean `%s`?',
                name,
                registrationName,
              )
              warnedProperties$1[name] = true
              return true
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error(
                'Unknown event handler property `%s`. It will be ignored.',
                name,
              )
              warnedProperties$1[name] = true
              return true
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error(
                'Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.',
                name,
              )
            }
            warnedProperties$1[name] = true
            return true
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true
          }
          if (lowerCasedName === 'innerhtml') {
            error(
              'Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.',
            )
            warnedProperties$1[name] = true
            return true
          }
          if (lowerCasedName === 'aria') {
            error(
              'The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.',
            )
            warnedProperties$1[name] = true
            return true
          }
          if (
            lowerCasedName === 'is' &&
            value !== null &&
            value !== void 0 &&
            typeof value !== 'string'
          ) {
            error(
              'Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.',
              typeof value,
            )
            warnedProperties$1[name] = true
            return true
          }
          if (typeof value === 'number' && isNaN(value)) {
            error(
              'Received NaN for the `%s` attribute. If this is expected, cast the value to a string.',
              name,
            )
            warnedProperties$1[name] = true
            return true
          }
          var propertyInfo = getPropertyInfo(name)
          var isReserved =
            propertyInfo !== null && propertyInfo.type === RESERVED
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName]
            if (standardName !== name) {
              error(
                'Invalid DOM property `%s`. Did you mean `%s`?',
                name,
                standardName,
              )
              warnedProperties$1[name] = true
              return true
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error(
              'React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.',
              name,
              lowerCasedName,
            )
            warnedProperties$1[name] = true
            return true
          }
          if (
            typeof value === 'boolean' &&
            shouldRemoveAttributeWithWarning(name, value, propertyInfo)
          ) {
            if (value) {
              error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                value,
                name,
                name,
                value,
                name,
              )
            } else {
              error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                value,
                name,
                name,
                value,
                name,
                name,
                name,
              )
            }
            warnedProperties$1[name] = true
            return true
          }
          if (isReserved) {
            return true
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo)) {
            warnedProperties$1[name] = true
            return false
          }
          if (
            (value === 'false' || value === 'true') &&
            propertyInfo !== null &&
            propertyInfo.type === BOOLEAN
          ) {
            error(
              'Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?',
              value,
              name,
              value === 'false'
                ? 'The browser will interpret it as a truthy value.'
                : 'Although this works, it will not work as expected if you pass the string "false".',
              name,
              value,
            )
            warnedProperties$1[name] = true
            return true
          }
          return true
        }
      }
      var warnUnknownProperties = function (type, props, eventRegistry) {
        {
          var unknownProps = []
          for (var key in props) {
            var isValid2 = validateProperty$1(
              type,
              key,
              props[key],
              eventRegistry,
            )
            if (!isValid2) {
              unknownProps.push(key)
            }
          }
          var unknownPropString = unknownProps
            .map(function (prop) {
              return '`' + prop + '`'
            })
            .join(', ')
          if (unknownProps.length === 1) {
            error(
              'Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
              unknownPropString,
              type,
            )
          } else if (unknownProps.length > 1) {
            error(
              'Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
              unknownPropString,
              type,
            )
          }
        }
      }
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return
        }
        warnUnknownProperties(type, props, eventRegistry)
      }
      var warnValidStyle = function () {}
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/
        var msPattern = /^-ms-/
        var hyphenPattern = /-(.)/g
        var badStyleValueWithSemicolonPattern = /;\s*$/
        var warnedStyleNames = {}
        var warnedStyleValues = {}
        var warnedForNaNValue = false
        var warnedForInfinityValue = false
        var camelize = function (string) {
          return string.replace(hyphenPattern, function (_, character) {
            return character.toUpperCase()
          })
        }
        var warnHyphenatedStyleName = function (name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return
          }
          warnedStyleNames[name] = true
          error(
            'Unsupported style property %s. Did you mean %s?',
            name,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name.replace(msPattern, 'ms-')),
          )
        }
        var warnBadVendoredStyleName = function (name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return
          }
          warnedStyleNames[name] = true
          error(
            'Unsupported vendor-prefixed style property %s. Did you mean %s?',
            name,
            name.charAt(0).toUpperCase() + name.slice(1),
          )
        }
        var warnStyleValueWithSemicolon = function (name, value) {
          if (
            warnedStyleValues.hasOwnProperty(value) &&
            warnedStyleValues[value]
          ) {
            return
          }
          warnedStyleValues[value] = true
          error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            name,
            value.replace(badStyleValueWithSemicolonPattern, ''),
          )
        }
        var warnStyleValueIsNaN = function (name, value) {
          if (warnedForNaNValue) {
            return
          }
          warnedForNaNValue = true
          error(
            '`NaN` is an invalid value for the `%s` css style property.',
            name,
          )
        }
        var warnStyleValueIsInfinity = function (name, value) {
          if (warnedForInfinityValue) {
            return
          }
          warnedForInfinityValue = true
          error(
            '`Infinity` is an invalid value for the `%s` css style property.',
            name,
          )
        }
        warnValidStyle = function (name, value) {
          if (name.indexOf('-') > -1) {
            warnHyphenatedStyleName(name)
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name)
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name, value)
          }
          if (typeof value === 'number') {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name, value)
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name, value)
            }
          }
        }
      }
      var warnValidStyle$1 = warnValidStyle
      var matchHtmlRegExp = /["'&<>]/
      function escapeHtml(string) {
        {
          checkHtmlStringCoercion(string)
        }
        var str = '' + string
        var match2 = matchHtmlRegExp.exec(str)
        if (!match2) {
          return str
        }
        var escape
        var html = ''
        var index
        var lastIndex = 0
        for (index = match2.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape = '&quot;'
              break
            case 38:
              escape = '&amp;'
              break
            case 39:
              escape = '&#x27;'
              break
            case 60:
              escape = '&lt;'
              break
            case 62:
              escape = '&gt;'
              break
            default:
              continue
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index)
          }
          lastIndex = index + 1
          html += escape
        }
        return lastIndex !== index
          ? html + str.substring(lastIndex, index)
          : html
      }
      function escapeTextForBrowser(text) {
        if (typeof text === 'boolean' || typeof text === 'number') {
          return '' + text
        }
        return escapeHtml(text)
      }
      var uppercasePattern = /([A-Z])/g
      var msPattern$1 = /^ms-/
      function hyphenateStyleName(name) {
        return name
          .replace(uppercasePattern, '-$1')
          .toLowerCase()
          .replace(msPattern$1, '-ms-')
      }
      var isJavaScriptProtocol =
        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i
      var didWarn = false
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true
            error(
              'A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.',
              JSON.stringify(url),
            )
          }
        }
      }
      var isArrayImpl = Array.isArray
      function isArray2(a) {
        return isArrayImpl(a)
      }
      var startInlineScript = stringToPrecomputedChunk('<script>')
      function createResponseState(
        identifierPrefix,
        nonce,
        bootstrapScriptContent,
        bootstrapScripts,
        bootstrapModules,
      ) {
        var idPrefix = identifierPrefix === void 0 ? '' : identifierPrefix
        var inlineScriptWithNonce = startInlineScript
        var bootstrapChunks = []
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + 'P:'),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + 'S:'),
          boundaryPrefix: idPrefix + 'B:',
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false,
        }
      }
      var ROOT_HTML_MODE = 0
      var HTML_MODE = 1
      var SVG_MODE = 2
      var MATHML_MODE = 3
      var HTML_TABLE_MODE = 4
      var HTML_TABLE_BODY_MODE = 5
      var HTML_TABLE_ROW_MODE = 6
      var HTML_COLGROUP_MODE = 7
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue,
        }
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case 'select':
            return createFormatContext(
              HTML_MODE,
              props.value != null ? props.value : props.defaultValue,
            )
          case 'svg':
            return createFormatContext(SVG_MODE, null)
          case 'math':
            return createFormatContext(MATHML_MODE, null)
          case 'foreignObject':
            return createFormatContext(HTML_MODE, null)
          // Table parents are special in that their children can only be created at all if they're
          // wrapped in a table parent. So we need to encode that we're entering this mode.
          case 'table':
            return createFormatContext(HTML_TABLE_MODE, null)
          case 'thead':
          case 'tbody':
          case 'tfoot':
            return createFormatContext(HTML_TABLE_BODY_MODE, null)
          case 'colgroup':
            return createFormatContext(HTML_COLGROUP_MODE, null)
          case 'tr':
            return createFormatContext(HTML_TABLE_ROW_MODE, null)
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null)
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null)
        }
        return parentContext
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++
        return stringToPrecomputedChunk(
          responseState.boundaryPrefix + generatedID.toString(16),
        )
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix
        var id = ':' + idPrefix + 'R' + treeId
        if (localId > 0) {
          id += 'H' + localId.toString(32)
        }
        return id + ':'
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text)
      }
      var textSeparator = stringToPrecomputedChunk('<!-- -->')
      function pushTextInstance(target, text, responseState, textEmbedded) {
        if (text === '') {
          return textEmbedded
        }
        if (textEmbedded) {
          target.push(textSeparator)
        }
        target.push(stringToChunk(encodeHTMLTextNode(text)))
        return true
      }
      function pushSegmentFinale(
        target,
        responseState,
        lastPushedText,
        textEmbedded,
      ) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator)
        }
      }
      var styleNameCache = /* @__PURE__ */ new Map()
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName)
        if (chunk !== void 0) {
          return chunk
        }
        var result = stringToPrecomputedChunk(
          escapeTextForBrowser(hyphenateStyleName(styleName)),
        )
        styleNameCache.set(styleName, result)
        return result
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="')
      var styleAssign = stringToPrecomputedChunk(':')
      var styleSeparator = stringToPrecomputedChunk(';')
      function pushStyle(target, responseState, style) {
        if (typeof style !== 'object') {
          throw new Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.",
          )
        }
        var isFirst = true
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue
          }
          var styleValue = style[styleName]
          if (
            styleValue == null ||
            typeof styleValue === 'boolean' ||
            styleValue === ''
          ) {
            continue
          }
          var nameChunk = void 0
          var valueChunk = void 0
          var isCustomProperty = styleName.indexOf('--') === 0
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName))
            {
              checkCSSPropertyStringCoercion(styleValue, styleName)
            }
            valueChunk = stringToChunk(
              escapeTextForBrowser(('' + styleValue).trim()),
            )
          } else {
            {
              warnValidStyle$1(styleName, styleValue)
            }
            nameChunk = processStyleName(styleName)
            if (typeof styleValue === 'number') {
              if (
                styleValue !== 0 &&
                !hasOwnProperty.call(isUnitlessNumber, styleName)
              ) {
                valueChunk = stringToChunk(styleValue + 'px')
              } else {
                valueChunk = stringToChunk('' + styleValue)
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName)
              }
              valueChunk = stringToChunk(
                escapeTextForBrowser(('' + styleValue).trim()),
              )
            }
          }
          if (isFirst) {
            isFirst = false
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk)
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk)
          }
        }
        if (!isFirst) {
          target.push(attributeEnd)
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(' ')
      var attributeAssign = stringToPrecomputedChunk('="')
      var attributeEnd = stringToPrecomputedChunk('"')
      var attributeEmptyString = stringToPrecomputedChunk('=""')
      function pushAttribute(target, responseState, name, value) {
        switch (name) {
          case 'style': {
            pushStyle(target, responseState, value)
            return
          }
          case 'defaultValue':
          case 'defaultChecked':
          // These shouldn't be set as attributes on generic HTML elements.
          case 'innerHTML':
          // Must use dangerouslySetInnerHTML instead.
          case 'suppressContentEditableWarning':
          case 'suppressHydrationWarning':
            return
        }
        if (
          // shouldIgnoreAttribute
          // We have already filtered out null/undefined and reserved words.
          name.length > 2 &&
          (name[0] === 'o' || name[0] === 'O') &&
          (name[1] === 'n' || name[1] === 'N')
        ) {
          return
        }
        var propertyInfo = getPropertyInfo(name)
        if (propertyInfo !== null) {
          switch (typeof value) {
            case 'function':
            // $FlowIssue symbol is perfectly valid here
            case 'symbol':
              return
            case 'boolean': {
              if (!propertyInfo.acceptsBooleans) {
                return
              }
            }
          }
          var attributeName = propertyInfo.attributeName
          var attributeNameChunk = stringToChunk(attributeName)
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value) {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeEmptyString,
                )
              }
              return
            case OVERLOADED_BOOLEAN:
              if (value === true) {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeEmptyString,
                )
              } else if (value === false);
              else {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeAssign,
                  stringToChunk(escapeTextForBrowser(value)),
                  attributeEnd,
                )
              }
              return
            case NUMERIC:
              if (!isNaN(value)) {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeAssign,
                  stringToChunk(escapeTextForBrowser(value)),
                  attributeEnd,
                )
              }
              break
            case POSITIVE_NUMERIC:
              if (!isNaN(value) && value >= 1) {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeAssign,
                  stringToChunk(escapeTextForBrowser(value)),
                  attributeEnd,
                )
              }
              break
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value, attributeName)
                }
                value = '' + value
                sanitizeURL(value)
              }
              target.push(
                attributeSeparator,
                attributeNameChunk,
                attributeAssign,
                stringToChunk(escapeTextForBrowser(value)),
                attributeEnd,
              )
          }
        } else if (isAttributeNameSafe(name)) {
          switch (typeof value) {
            case 'function':
            // $FlowIssue symbol is perfectly valid here
            case 'symbol':
              return
            case 'boolean': {
              var prefix2 = name.toLowerCase().slice(0, 5)
              if (prefix2 !== 'data-' && prefix2 !== 'aria-') {
                return
              }
            }
          }
          target.push(
            attributeSeparator,
            stringToChunk(name),
            attributeAssign,
            stringToChunk(escapeTextForBrowser(value)),
            attributeEnd,
          )
        }
      }
      var endOfStartTag = stringToPrecomputedChunk('>')
      var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>')
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error(
              'Can only set one of `children` or `props.dangerouslySetInnerHTML`.',
            )
          }
          if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) {
            throw new Error(
              '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.',
            )
          }
          var html = innerHTML.__html
          if (html !== null && html !== void 0) {
            {
              checkHtmlStringCoercion(html)
            }
            target.push(stringToChunk('' + html))
          }
        }
      }
      var didWarnDefaultInputValue = false
      var didWarnDefaultChecked = false
      var didWarnDefaultSelectValue = false
      var didWarnDefaultTextareaValue = false
      var didWarnInvalidOptionChildren = false
      var didWarnInvalidOptionInnerHTML = false
      var didWarnSelectedSetOnOption = false
      function checkSelectProp(props, propName) {
        {
          var value = props[propName]
          if (value != null) {
            var array = isArray2(value)
            if (props.multiple && !array) {
              error(
                'The `%s` prop supplied to <select> must be an array if `multiple` is true.',
                propName,
              )
            } else if (!props.multiple && array) {
              error(
                'The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.',
                propName,
              )
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps('select', props)
          checkSelectProp(props, 'value')
          checkSelectProp(props, 'defaultValue')
          if (
            props.value !== void 0 &&
            props.defaultValue !== void 0 &&
            !didWarnDefaultSelectValue
          ) {
            error(
              'Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
            )
            didWarnDefaultSelectValue = true
          }
        }
        target.push(startChunkForTag('select'))
        var children = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              case 'defaultValue':
              case 'value':
                break
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        pushInnerHTML(target, innerHTML, children)
        return children
      }
      function flattenOptionChildren(children) {
        var content = ''
        React2.Children.forEach(children, function (child) {
          if (child == null) {
            return
          }
          content += child
          {
            if (
              !didWarnInvalidOptionChildren &&
              typeof child !== 'string' &&
              typeof child !== 'number'
            ) {
              didWarnInvalidOptionChildren = true
              error(
                'Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.',
              )
            }
          }
        })
        return content
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""')
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue
        target.push(startChunkForTag('option'))
        var children = null
        var value = null
        var selected = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'selected':
                selected = propValue
                {
                  if (!didWarnSelectedSetOnOption) {
                    error(
                      'Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.',
                    )
                    didWarnSelectedSetOnOption = true
                  }
                }
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              // eslint-disable-next-line-no-fallthrough
              case 'value':
                value = propValue
              // We intentionally fallthrough to also set the attribute on the node.
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        if (selectedValue != null) {
          var stringValue
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, 'value')
            }
            stringValue = '' + value
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true
                  error(
                    'Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.',
                  )
                }
              }
            }
            stringValue = flattenOptionChildren(children)
          }
          if (isArray2(selectedValue)) {
            for (var i = 0; i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], 'value')
              }
              var v = '' + selectedValue[i]
              if (v === stringValue) {
                target.push(selectedMarkerAttribute)
                break
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, 'select.value')
            }
            if ('' + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute)
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute)
        }
        target.push(endOfStartTag)
        pushInnerHTML(target, innerHTML, children)
        return children
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps('input', props)
          if (
            props.checked !== void 0 &&
            props.defaultChecked !== void 0 &&
            !didWarnDefaultChecked
          ) {
            error(
              '%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
              'A component',
              props.type,
            )
            didWarnDefaultChecked = true
          }
          if (
            props.value !== void 0 &&
            props.defaultValue !== void 0 &&
            !didWarnDefaultInputValue
          ) {
            error(
              '%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
              'A component',
              props.type,
            )
            didWarnDefaultInputValue = true
          }
        }
        target.push(startChunkForTag('input'))
        var value = null
        var defaultValue = null
        var checked = null
        var defaultChecked = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  'input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.',
                )
              // eslint-disable-next-line-no-fallthrough
              case 'defaultChecked':
                defaultChecked = propValue
                break
              case 'defaultValue':
                defaultValue = propValue
                break
              case 'checked':
                checked = propValue
                break
              case 'value':
                value = propValue
                break
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, 'checked', checked)
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, 'checked', defaultChecked)
        }
        if (value !== null) {
          pushAttribute(target, responseState, 'value', value)
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, 'value', defaultValue)
        }
        target.push(endOfStartTagSelfClosing)
        return null
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps('textarea', props)
          if (
            props.value !== void 0 &&
            props.defaultValue !== void 0 &&
            !didWarnDefaultTextareaValue
          ) {
            error(
              'Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components',
            )
            didWarnDefaultTextareaValue = true
          }
        }
        target.push(startChunkForTag('textarea'))
        var value = null
        var defaultValue = null
        var children = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'value':
                value = propValue
                break
              case 'defaultValue':
                defaultValue = propValue
                break
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  '`dangerouslySetInnerHTML` does not make sense on <textarea>.',
                )
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        if (value === null && defaultValue !== null) {
          value = defaultValue
        }
        target.push(endOfStartTag)
        if (children != null) {
          {
            error(
              'Use the `defaultValue` or `value` props instead of setting children on <textarea>.',
            )
          }
          if (value != null) {
            throw new Error(
              'If you supply `defaultValue` on a <textarea>, do not pass children.',
            )
          }
          if (isArray2(children)) {
            if (children.length > 1) {
              throw new Error('<textarea> can only have at most one child.')
            }
            {
              checkHtmlStringCoercion(children[0])
            }
            value = '' + children[0]
          }
          {
            checkHtmlStringCoercion(children)
          }
          value = '' + children
        }
        if (typeof value === 'string' && value[0] === '\n') {
          target.push(leadingNewline)
        }
        if (value !== null) {
          {
            checkAttributeStringCoercion(value, 'value')
          }
          target.push(stringToChunk(encodeHTMLTextNode('' + value)))
        }
        return null
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag))
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  tag +
                    ' is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.',
                )
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTagSelfClosing)
        return null
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag('menuitem'))
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  'menuitems cannot have `children` nor `dangerouslySetInnerHTML`.',
                )
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        return null
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag('title'))
        var children = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  '`dangerouslySetInnerHTML` does not make sense on <title>.',
                )
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        {
          var child =
            Array.isArray(children) && children.length < 2
              ? children[0] || null
              : children
          if (Array.isArray(children) && children.length > 1) {
            error(
              'A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering',
            )
          } else if (child != null && child.$$typeof != null) {
            error(
              'A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering',
            )
          } else if (
            child != null &&
            typeof child !== 'string' &&
            typeof child !== 'number'
          ) {
            error(
              'A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering',
            )
          }
        }
        return children
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag))
        var children = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        pushInnerHTML(target, innerHTML, children)
        if (typeof children === 'string') {
          target.push(stringToChunk(encodeHTMLTextNode(children)))
          return null
        }
        return children
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag))
        var children = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              case 'style':
                pushStyle(target, responseState, propValue)
                break
              case 'suppressContentEditableWarning':
              case 'suppressHydrationWarning':
                break
              default:
                if (
                  isAttributeNameSafe(propKey) &&
                  typeof propValue !== 'function' &&
                  typeof propValue !== 'symbol'
                ) {
                  target.push(
                    attributeSeparator,
                    stringToChunk(propKey),
                    attributeAssign,
                    stringToChunk(escapeTextForBrowser(propValue)),
                    attributeEnd,
                  )
                }
                break
            }
          }
        }
        target.push(endOfStartTag)
        pushInnerHTML(target, innerHTML, children)
        return children
      }
      var leadingNewline = stringToPrecomputedChunk('\n')
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag))
        var children = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        if (innerHTML != null) {
          if (children != null) {
            throw new Error(
              'Can only set one of `children` or `props.dangerouslySetInnerHTML`.',
            )
          }
          if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) {
            throw new Error(
              '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.',
            )
          }
          var html = innerHTML.__html
          if (html !== null && html !== void 0) {
            if (
              typeof html === 'string' &&
              html.length > 0 &&
              html[0] === '\n'
            ) {
              target.push(leadingNewline, stringToChunk(html))
            } else {
              {
                checkHtmlStringCoercion(html)
              }
              target.push(stringToChunk('' + html))
            }
          }
        }
        if (typeof children === 'string' && children[0] === '\n') {
          target.push(leadingNewline)
        }
        return children
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/
      var validatedTagCache = /* @__PURE__ */ new Map()
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag)
        if (tagStartChunk === void 0) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error('Invalid tag: ' + tag)
          }
          tagStartChunk = stringToPrecomputedChunk('<' + tag)
          validatedTagCache.set(tag, tagStartChunk)
        }
        return tagStartChunk
      }
      var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>')
      function pushStartInstance(
        target,
        type,
        props,
        responseState,
        formatContext,
      ) {
        {
          validateProperties(type, props)
          validateProperties$1(type, props)
          validateProperties$2(type, props, null)
          if (
            !props.suppressContentEditableWarning &&
            props.contentEditable &&
            props.children != null
          ) {
            error(
              'A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.',
            )
          }
          if (
            formatContext.insertionMode !== SVG_MODE &&
            formatContext.insertionMode !== MATHML_MODE
          ) {
            if (
              type.indexOf('-') === -1 &&
              typeof props.is !== 'string' &&
              type.toLowerCase() !== type
            ) {
              error(
                '<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.',
                type,
              )
            }
          }
        }
        switch (type) {
          // Special tags
          case 'select':
            return pushStartSelect(target, props, responseState)
          case 'option':
            return pushStartOption(target, props, responseState, formatContext)
          case 'textarea':
            return pushStartTextArea(target, props, responseState)
          case 'input':
            return pushInput(target, props, responseState)
          case 'menuitem':
            return pushStartMenuItem(target, props, responseState)
          case 'title':
            return pushStartTitle(target, props, responseState)
          // Newline eating tags
          case 'listing':
          case 'pre': {
            return pushStartPreformattedElement(
              target,
              props,
              type,
              responseState,
            )
          }
          // Omitted close tags
          case 'area':
          case 'base':
          case 'br':
          case 'col':
          case 'embed':
          case 'hr':
          case 'img':
          case 'keygen':
          case 'link':
          case 'meta':
          case 'param':
          case 'source':
          case 'track':
          case 'wbr': {
            return pushSelfClosing(target, props, type, responseState)
          }
          // These are reserved SVG and MathML elements, that are never custom elements.
          // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
          case 'annotation-xml':
          case 'color-profile':
          case 'font-face':
          case 'font-face-src':
          case 'font-face-uri':
          case 'font-face-format':
          case 'font-face-name':
          case 'missing-glyph': {
            return pushStartGenericElement(target, props, type, responseState)
          }
          case 'html': {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE)
            }
            return pushStartGenericElement(target, props, type, responseState)
          }
          default: {
            if (type.indexOf('-') === -1 && typeof props.is !== 'string') {
              return pushStartGenericElement(target, props, type, responseState)
            } else {
              return pushStartCustomElement(target, props, type, responseState)
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk('</')
      var endTag2 = stringToPrecomputedChunk('>')
      function pushEndInstance(target, type, props) {
        switch (type) {
          // Omitted close tags
          // TODO: Instead of repeating this switch we could try to pass a flag from above.
          // That would require returning a tuple. Which might be ok if it gets inlined.
          case 'area':
          case 'base':
          case 'br':
          case 'col':
          case 'embed':
          case 'hr':
          case 'img':
          case 'input':
          case 'keygen':
          case 'link':
          case 'meta':
          case 'param':
          case 'source':
          case 'track':
          case 'wbr': {
            break
          }
          default: {
            target.push(endTag1, stringToChunk(type), endTag2)
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks
        var i = 0
        for (; i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i])
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i])
        }
        return true
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="')
      var placeholder2 = stringToPrecomputedChunk('"></template>')
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1)
        writeChunk(destination, responseState.placeholderPrefix)
        var formattedID = stringToChunk(id.toString(16))
        writeChunk(destination, formattedID)
        return writeChunkAndReturn(destination, placeholder2)
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->')
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
        '<!--$?--><template id="',
      )
      var startPendingSuspenseBoundary2 =
        stringToPrecomputedChunk('"></template>')
      var startClientRenderedSuspenseBoundary =
        stringToPrecomputedChunk('<!--$!-->')
      var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->')
      var clientRenderedSuspenseBoundaryError1 =
        stringToPrecomputedChunk('<template')
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial =
        stringToPrecomputedChunk('"')
      var clientRenderedSuspenseBoundaryError1A =
        stringToPrecomputedChunk(' data-dgst="')
      var clientRenderedSuspenseBoundaryError1B =
        stringToPrecomputedChunk(' data-msg="')
      var clientRenderedSuspenseBoundaryError1C =
        stringToPrecomputedChunk(' data-stck="')
      var clientRenderedSuspenseBoundaryError2 =
        stringToPrecomputedChunk('></template>')
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary)
      }
      function writeStartPendingSuspenseBoundary(
        destination,
        responseState,
        id,
      ) {
        writeChunk(destination, startPendingSuspenseBoundary1)
        if (id === null) {
          throw new Error(
            'An ID must have been assigned before we can complete the boundary.',
          )
        }
        writeChunk(destination, id)
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2)
      }
      function writeStartClientRenderedSuspenseBoundary(
        destination,
        responseState,
        errorDigest,
        errorMesssage,
        errorComponentStack,
      ) {
        var result
        result = writeChunkAndReturn(
          destination,
          startClientRenderedSuspenseBoundary,
        )
        writeChunk(destination, clientRenderedSuspenseBoundaryError1)
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A)
          writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorDigest)),
          )
          writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial,
          )
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B)
            writeChunk(
              destination,
              stringToChunk(escapeTextForBrowser(errorMesssage)),
            )
            writeChunk(
              destination,
              clientRenderedSuspenseBoundaryErrorAttrInterstitial,
            )
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C)
            writeChunk(
              destination,
              stringToChunk(escapeTextForBrowser(errorComponentStack)),
            )
            writeChunk(
              destination,
              clientRenderedSuspenseBoundaryErrorAttrInterstitial,
            )
          }
        }
        result = writeChunkAndReturn(
          destination,
          clientRenderedSuspenseBoundaryError2,
        )
        return result
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary)
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary)
      }
      function writeEndClientRenderedSuspenseBoundary(
        destination,
        responseState,
      ) {
        return writeChunkAndReturn(destination, endSuspenseBoundary)
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="')
      var startSegmentHTML2 = stringToPrecomputedChunk('">')
      var endSegmentHTML = stringToPrecomputedChunk('</div>')
      var startSegmentSVG = stringToPrecomputedChunk(
        '<svg aria-hidden="true" style="display:none" id="',
      )
      var startSegmentSVG2 = stringToPrecomputedChunk('">')
      var endSegmentSVG = stringToPrecomputedChunk('</svg>')
      var startSegmentMathML = stringToPrecomputedChunk(
        '<math aria-hidden="true" style="display:none" id="',
      )
      var startSegmentMathML2 = stringToPrecomputedChunk('">')
      var endSegmentMathML = stringToPrecomputedChunk('</math>')
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="')
      var startSegmentTable2 = stringToPrecomputedChunk('">')
      var endSegmentTable = stringToPrecomputedChunk('</table>')
      var startSegmentTableBody = stringToPrecomputedChunk(
        '<table hidden><tbody id="',
      )
      var startSegmentTableBody2 = stringToPrecomputedChunk('">')
      var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>')
      var startSegmentTableRow = stringToPrecomputedChunk(
        '<table hidden><tr id="',
      )
      var startSegmentTableRow2 = stringToPrecomputedChunk('">')
      var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>')
      var startSegmentColGroup = stringToPrecomputedChunk(
        '<table hidden><colgroup id="',
      )
      var startSegmentColGroup2 = stringToPrecomputedChunk('">')
      var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>')
      function writeStartSegment(
        destination,
        responseState,
        formatContext,
        id,
      ) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentHTML2)
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentSVG2)
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentMathML2)
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentTable2)
          }
          // TODO: For the rest of these, there will be extra wrapper nodes that never
          // get deleted from the document. We need to delete the table too as part
          // of the injected scripts. They are invisible though so it's not too terrible
          // and it's kind of an edge case to suspend in a table. Totally supported though.
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentTableBody2)
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentTableRow2)
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentColGroup2)
          }
          default: {
            throw new Error('Unknown insertion mode. This is a bug in React.')
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML)
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG)
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML)
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable)
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody)
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow)
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup)
          }
          default: {
            throw new Error('Unknown insertion mode. This is a bug in React.')
          }
        }
      }
      var completeSegmentFunction =
        'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}'
      var completeBoundaryFunction =
        'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}'
      var clientRenderFunction =
        'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}'
      var completeSegmentScript1Full = stringToPrecomputedChunk(
        completeSegmentFunction + ';$RS("',
      )
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("')
      var completeSegmentScript2 = stringToPrecomputedChunk('","')
      var completeSegmentScript3 = stringToPrecomputedChunk('")</script>')
      function writeCompletedSegmentInstruction(
        destination,
        responseState,
        contentSegmentID,
      ) {
        writeChunk(destination, responseState.startInlineScript)
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true
          writeChunk(destination, completeSegmentScript1Full)
        } else {
          writeChunk(destination, completeSegmentScript1Partial)
        }
        writeChunk(destination, responseState.segmentPrefix)
        var formattedID = stringToChunk(contentSegmentID.toString(16))
        writeChunk(destination, formattedID)
        writeChunk(destination, completeSegmentScript2)
        writeChunk(destination, responseState.placeholderPrefix)
        writeChunk(destination, formattedID)
        return writeChunkAndReturn(destination, completeSegmentScript3)
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(
        completeBoundaryFunction + ';$RC("',
      )
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("')
      var completeBoundaryScript2 = stringToPrecomputedChunk('","')
      var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>')
      function writeCompletedBoundaryInstruction(
        destination,
        responseState,
        boundaryID,
        contentSegmentID,
      ) {
        writeChunk(destination, responseState.startInlineScript)
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true
          writeChunk(destination, completeBoundaryScript1Full)
        } else {
          writeChunk(destination, completeBoundaryScript1Partial)
        }
        if (boundaryID === null) {
          throw new Error(
            'An ID must have been assigned before we can complete the boundary.',
          )
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16))
        writeChunk(destination, boundaryID)
        writeChunk(destination, completeBoundaryScript2)
        writeChunk(destination, responseState.segmentPrefix)
        writeChunk(destination, formattedContentID)
        return writeChunkAndReturn(destination, completeBoundaryScript3)
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(
        clientRenderFunction + ';$RX("',
      )
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("')
      var clientRenderScript1A = stringToPrecomputedChunk('"')
      var clientRenderScript2 = stringToPrecomputedChunk(')</script>')
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',')
      function writeClientRenderBoundaryInstruction(
        destination,
        responseState,
        boundaryID,
        errorDigest,
        errorMessage,
        errorComponentStack,
      ) {
        writeChunk(destination, responseState.startInlineScript)
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true
          writeChunk(destination, clientRenderScript1Full)
        } else {
          writeChunk(destination, clientRenderScript1Partial)
        }
        if (boundaryID === null) {
          throw new Error(
            'An ID must have been assigned before we can complete the boundary.',
          )
        }
        writeChunk(destination, boundaryID)
        writeChunk(destination, clientRenderScript1A)
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial)
          writeChunk(
            destination,
            stringToChunk(
              escapeJSStringsForInstructionScripts(errorDigest || ''),
            ),
          )
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial)
          writeChunk(
            destination,
            stringToChunk(
              escapeJSStringsForInstructionScripts(errorMessage || ''),
            ),
          )
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial)
          writeChunk(
            destination,
            stringToChunk(
              escapeJSStringsForInstructionScripts(errorComponentStack),
            ),
          )
        }
        return writeChunkAndReturn(destination, clientRenderScript2)
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input)
        return escaped.replace(regexForJSStringsInScripts, function (match2) {
          switch (match2) {
            // santizing breaking out of strings and script tags
            case '<':
              return '\\u003c'
            case '\u2028':
              return '\\u2028'
            case '\u2029':
              return '\\u2029'
            default: {
              throw new Error(
                'escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React',
              )
            }
          }
        })
      }
      function createResponseState$1(generateStaticMarkup, identifierPrefix) {
        var responseState = createResponseState(identifierPrefix)
        return {
          // Keep this in sync with ReactDOMServerFormatConfig
          bootstrapChunks: responseState.bootstrapChunks,
          startInlineScript: responseState.startInlineScript,
          placeholderPrefix: responseState.placeholderPrefix,
          segmentPrefix: responseState.segmentPrefix,
          boundaryPrefix: responseState.boundaryPrefix,
          idPrefix: responseState.idPrefix,
          nextSuspenseID: responseState.nextSuspenseID,
          sentCompleteSegmentFunction:
            responseState.sentCompleteSegmentFunction,
          sentCompleteBoundaryFunction:
            responseState.sentCompleteBoundaryFunction,
          sentClientRenderFunction: responseState.sentClientRenderFunction,
          // This is an extra field for the legacy renderer
          generateStaticMarkup,
        }
      }
      function createRootFormatContext() {
        return {
          insertionMode: HTML_MODE,
          // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
          selectedValue: null,
        }
      }
      function pushTextInstance$1(target, text, responseState, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          target.push(stringToChunk(escapeTextForBrowser(text)))
          return false
        } else {
          return pushTextInstance(target, text, responseState, textEmbedded)
        }
      }
      function pushSegmentFinale$1(
        target,
        responseState,
        lastPushedText,
        textEmbedded,
      ) {
        if (responseState.generateStaticMarkup) {
          return
        } else {
          return pushSegmentFinale(
            target,
            responseState,
            lastPushedText,
            textEmbedded,
          )
        }
      }
      function writeStartCompletedSuspenseBoundary$1(
        destination,
        responseState,
      ) {
        if (responseState.generateStaticMarkup) {
          return true
        }
        return writeStartCompletedSuspenseBoundary(destination)
      }
      function writeStartClientRenderedSuspenseBoundary$1(
        destination,
        responseState,
        errorDigest,
        errorMessage,
        errorComponentStack,
      ) {
        if (responseState.generateStaticMarkup) {
          return true
        }
        return writeStartClientRenderedSuspenseBoundary(
          destination,
          responseState,
          errorDigest,
          errorMessage,
          errorComponentStack,
        )
      }
      function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true
        }
        return writeEndCompletedSuspenseBoundary(destination)
      }
      function writeEndClientRenderedSuspenseBoundary$1(
        destination,
        responseState,
      ) {
        if (responseState.generateStaticMarkup) {
          return true
        }
        return writeEndClientRenderedSuspenseBoundary(destination)
      }
      var assign2 = Object.assign
      var REACT_ELEMENT_TYPE = Symbol.for('react.element')
      var REACT_PORTAL_TYPE = Symbol.for('react.portal')
      var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')
      var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')
      var REACT_PROFILER_TYPE = Symbol.for('react.profiler')
      var REACT_PROVIDER_TYPE = Symbol.for('react.provider')
      var REACT_CONTEXT_TYPE = Symbol.for('react.context')
      var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')
      var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')
      var REACT_MEMO_TYPE = Symbol.for('react.memo')
      var REACT_LAZY_TYPE = Symbol.for('react.lazy')
      var REACT_SCOPE_TYPE = Symbol.for('react.scope')
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode')
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden')
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(
        'react.default_value',
      )
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator
      var FAUX_ITERATOR_SYMBOL = '@@iterator'
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') {
          return null
        }
        var maybeIterator =
          (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
          maybeIterable[FAUX_ITERATOR_SYMBOL]
        if (typeof maybeIterator === 'function') {
          return maybeIterator
        }
        return null
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName
        if (displayName) {
          return displayName
        }
        var functionName = innerType.displayName || innerType.name || ''
        return functionName !== ''
          ? wrapperName + '(' + functionName + ')'
          : wrapperName
      }
      function getContextName(type) {
        return type.displayName || 'Context'
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null
        }
        {
          if (typeof type.tag === 'number') {
            error(
              'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.',
            )
          }
        }
        if (typeof type === 'function') {
          return type.displayName || type.name || null
        }
        if (typeof type === 'string') {
          return type
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return 'Fragment'
          case REACT_PORTAL_TYPE:
            return 'Portal'
          case REACT_PROFILER_TYPE:
            return 'Profiler'
          case REACT_STRICT_MODE_TYPE:
            return 'StrictMode'
          case REACT_SUSPENSE_TYPE:
            return 'Suspense'
          case REACT_SUSPENSE_LIST_TYPE:
            return 'SuspenseList'
        }
        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type
              return getContextName(context) + '.Consumer'
            case REACT_PROVIDER_TYPE:
              var provider = type
              return getContextName(provider._context) + '.Provider'
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, 'ForwardRef')
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null
              if (outerName !== null) {
                return outerName
              }
              return getComponentNameFromType(type.type) || 'Memo'
            case REACT_LAZY_TYPE: {
              var lazyComponent = type
              var payload = lazyComponent._payload
              var init = lazyComponent._init
              try {
                return getComponentNameFromType(init(payload))
              } catch (x) {
                return null
              }
            }
          }
        }
        return null
      }
      var disabledDepth = 0
      var prevLog
      var prevInfo
      var prevWarn
      var prevError
      var prevGroup
      var prevGroupCollapsed
      var prevGroupEnd
      function disabledLog() {}
      disabledLog.__reactDisabledLog = true
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log
            prevInfo = console.info
            prevWarn = console.warn
            prevError = console.error
            prevGroup = console.group
            prevGroupCollapsed = console.groupCollapsed
            prevGroupEnd = console.groupEnd
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true,
            }
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props,
            })
          }
          disabledDepth++
        }
      }
      function reenableLogs() {
        {
          disabledDepth--
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true,
            }
            Object.defineProperties(console, {
              log: assign2({}, props, {
                value: prevLog,
              }),
              info: assign2({}, props, {
                value: prevInfo,
              }),
              warn: assign2({}, props, {
                value: prevWarn,
              }),
              error: assign2({}, props, {
                value: prevError,
              }),
              group: assign2({}, props, {
                value: prevGroup,
              }),
              groupCollapsed: assign2({}, props, {
                value: prevGroupCollapsed,
              }),
              groupEnd: assign2({}, props, {
                value: prevGroupEnd,
              }),
            })
          }
          if (disabledDepth < 0) {
            error(
              'disabledDepth fell below zero. This is a bug in React. Please file an issue.',
            )
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
      var prefix
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error()
            } catch (x) {
              var match2 = x.stack.trim().match(/\n( *(at )?)/)
              prefix = (match2 && match2[1]) || ''
            }
          }
          return '\n' + prefix + name
        }
      }
      var reentry = false
      var componentFrameCache
      {
        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map
        componentFrameCache = new PossiblyWeakMap()
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return ''
        }
        {
          var frame = componentFrameCache.get(fn)
          if (frame !== void 0) {
            return frame
          }
        }
        var control
        reentry = true
        var previousPrepareStackTrace = Error.prepareStackTrace
        Error.prepareStackTrace = void 0
        var previousDispatcher
        {
          previousDispatcher = ReactCurrentDispatcher.current
          ReactCurrentDispatcher.current = null
          disableLogs()
        }
        try {
          if (construct) {
            var Fake = function () {
              throw Error()
            }
            Object.defineProperty(Fake.prototype, 'props', {
              set: function () {
                throw Error()
              },
            })
            if (typeof Reflect === 'object' && Reflect.construct) {
              try {
                Reflect.construct(Fake, [])
              } catch (x) {
                control = x
              }
              Reflect.construct(fn, [], Fake)
            } else {
              try {
                Fake.call()
              } catch (x) {
                control = x
              }
              fn.call(Fake.prototype)
            }
          } else {
            try {
              throw Error()
            } catch (x) {
              control = x
            }
            fn()
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === 'string') {
            var sampleLines = sample.stack.split('\n')
            var controlLines = control.stack.split('\n')
            var s = sampleLines.length - 1
            var c = controlLines.length - 1
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--
                    c--
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame =
                        '\n' + sampleLines[s].replace(' at new ', ' at ')
                      if (fn.displayName && _frame.includes('<anonymous>')) {
                        _frame = _frame.replace('<anonymous>', fn.displayName)
                      }
                      {
                        if (typeof fn === 'function') {
                          componentFrameCache.set(fn, _frame)
                        }
                      }
                      return _frame
                    }
                  } while (s >= 1 && c >= 0)
                }
                break
              }
            }
          }
        } finally {
          reentry = false
          {
            ReactCurrentDispatcher.current = previousDispatcher
            reenableLogs()
          }
          Error.prepareStackTrace = previousPrepareStackTrace
        }
        var name = fn ? fn.displayName || fn.name : ''
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : ''
        {
          if (typeof fn === 'function') {
            componentFrameCache.set(fn, syntheticFrame)
          }
        }
        return syntheticFrame
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true)
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false)
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype
        return !!(prototype && prototype.isReactComponent)
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return ''
        }
        if (typeof type === 'function') {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type))
          }
        }
        if (typeof type === 'string') {
          return describeBuiltInComponentFrame(type)
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame('Suspense')
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame('SuspenseList')
        }
        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render)
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(
                type.type,
                source,
                ownerFn,
              )
            case REACT_LAZY_TYPE: {
              var lazyComponent = type
              var payload = lazyComponent._payload
              var init = lazyComponent._init
              try {
                return describeUnknownElementTypeFrameInDEV(
                  init(payload),
                  source,
                  ownerFn,
                )
              } catch (x) {}
            }
          }
        }
        return ''
      }
      var loggedTypeFailures = {}
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner
            var stack = describeUnknownElementTypeFrameInDEV(
              element.type,
              element._source,
              owner ? owner.type : null,
            )
            ReactDebugCurrentFrame.setExtraStackFrame(stack)
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null)
          }
        }
      }
      function checkPropTypes(
        typeSpecs,
        values,
        location,
        componentName,
        element,
      ) {
        {
          var has = Function.call.bind(hasOwnProperty)
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0
              try {
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                  var err = Error(
                    (componentName || 'React class') +
                      ': ' +
                      location +
                      ' type `' +
                      typeSpecName +
                      '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                      typeof typeSpecs[typeSpecName] +
                      '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.',
                  )
                  err.name = 'Invariant Violation'
                  throw err
                }
                error$1 = typeSpecs[typeSpecName](
                  values,
                  typeSpecName,
                  componentName,
                  location,
                  null,
                  'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED',
                )
              } catch (ex) {
                error$1 = ex
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element)
                error(
                  '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
                  componentName || 'React class',
                  location,
                  typeSpecName,
                  typeof error$1,
                )
                setCurrentlyValidatingElement(null)
              }
              if (
                error$1 instanceof Error &&
                !(error$1.message in loggedTypeFailures)
              ) {
                loggedTypeFailures[error$1.message] = true
                setCurrentlyValidatingElement(element)
                error('Failed %s type: %s', location, error$1.message)
                setCurrentlyValidatingElement(null)
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext
      {
        warnedAboutMissingGetChildContext = {}
      }
      var emptyContextObject = {}
      {
        Object.freeze(emptyContextObject)
      }
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes
          if (!contextTypes) {
            return emptyContextObject
          }
          var context = {}
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key]
          }
          {
            var name = getComponentNameFromType(type) || 'Unknown'
            checkPropTypes(contextTypes, context, 'context', name)
          }
          return context
        }
      }
      function processChildContext(
        instance,
        type,
        parentContext,
        childContextTypes,
      ) {
        {
          if (typeof instance.getChildContext !== 'function') {
            {
              var componentName = getComponentNameFromType(type) || 'Unknown'
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true
                error(
                  '%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.',
                  componentName,
                  componentName,
                )
              }
            }
            return parentContext
          }
          var childContext = instance.getChildContext()
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error(
                (getComponentNameFromType(type) || 'Unknown') +
                  '.getChildContext(): key "' +
                  contextKey +
                  '" is not defined in childContextTypes.',
              )
            }
          }
          {
            var name = getComponentNameFromType(type) || 'Unknown'
            checkPropTypes(
              childContextTypes,
              childContext,
              'child context',
              name,
            )
          }
          return assign2({}, parentContext, childContext)
        }
      }
      var rendererSigil
      {
        rendererSigil = {}
      }
      var rootContextSnapshot = null
      var currentActiveSnapshot = null
      function popNode(prev) {
        {
          prev.context._currentValue2 = prev.parentValue
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue2 = next.value
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next);
        else {
          popNode(prev)
          var parentPrev = prev.parent
          var parentNext = next.parent
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error(
                'The stacks must reach the root at the same time. This is a bug in React.',
              )
            }
          } else {
            if (parentNext === null) {
              throw new Error(
                'The stacks must reach the root at the same time. This is a bug in React.',
              )
            }
            popToNearestCommonAncestor(parentPrev, parentNext)
          }
          pushNode(next)
        }
      }
      function popAllPrevious(prev) {
        popNode(prev)
        var parentPrev = prev.parent
        if (parentPrev !== null) {
          popAllPrevious(parentPrev)
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent
        if (parentNext !== null) {
          pushAllNext(parentNext)
        }
        pushNode(next)
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev)
        var parentPrev = prev.parent
        if (parentPrev === null) {
          throw new Error(
            'The depth must equal at least at zero before reaching the root. This is a bug in React.',
          )
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next)
        } else {
          popPreviousToCommonLevel(parentPrev, next)
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent
        if (parentNext === null) {
          throw new Error(
            'The depth must equal at least at zero before reaching the root. This is a bug in React.',
          )
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext)
        } else {
          popNextToCommonLevel(prev, parentNext)
        }
        pushNode(next)
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot
        var next = newSnapshot
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next)
          } else if (next === null) {
            popAllPrevious(prev)
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next)
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next)
          } else {
            popNextToCommonLevel(prev, next)
          }
          currentActiveSnapshot = next
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue
        {
          prevValue = context._currentValue2
          context._currentValue2 = nextValue
          {
            if (
              context._currentRenderer2 !== void 0 &&
              context._currentRenderer2 !== null &&
              context._currentRenderer2 !== rendererSigil
            ) {
              error(
                'Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.',
              )
            }
            context._currentRenderer2 = rendererSigil
          }
        }
        var prevNode = currentActiveSnapshot
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue,
        }
        currentActiveSnapshot = newNode
        return newNode
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot
        if (prevSnapshot === null) {
          throw new Error(
            'Tried to pop a Context at the root of the app. This is a bug in React.',
          )
        }
        {
          if (prevSnapshot.context !== context) {
            error(
              'The parent context is not the expected context. This is probably a bug in React.',
            )
          }
        }
        {
          var _value = prevSnapshot.parentValue
          if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue2 =
              prevSnapshot.context._defaultValue
          } else {
            prevSnapshot.context._currentValue2 = _value
          }
          {
            if (
              context._currentRenderer2 !== void 0 &&
              context._currentRenderer2 !== null &&
              context._currentRenderer2 !== rendererSigil
            ) {
              error(
                'Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.',
              )
            }
            context._currentRenderer2 = rendererSigil
          }
        }
        return (currentActiveSnapshot = prevSnapshot.parent)
      }
      function getActiveContext() {
        return currentActiveSnapshot
      }
      function readContext(context) {
        var value = context._currentValue2
        return value
      }
      function get(key) {
        return key._reactInternals
      }
      function set(key, value) {
        key._reactInternals = value
      }
      var didWarnAboutNoopUpdateForComponent = {}
      var didWarnAboutDeprecatedWillMount = {}
      var didWarnAboutUninitializedState
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
      var didWarnAboutLegacyLifecyclesAndDerivedState
      var didWarnAboutUndefinedDerivedState
      var warnOnUndefinedDerivedState
      var warnOnInvalidCallback
      var didWarnAboutDirectlyAssigningPropsToState
      var didWarnAboutContextTypeAndContextTypes
      var didWarnAboutInvalidateContextType
      {
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set()
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate =
          /* @__PURE__ */ new Set()
        didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set()
        didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set()
        didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set()
        didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set()
        didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set()
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set()
        warnOnInvalidCallback = function (callback, callerName) {
          if (callback === null || typeof callback === 'function') {
            return
          }
          var key = callerName + '_' + callback
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key)
            error(
              '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
              callerName,
              callback,
            )
          }
        }
        warnOnUndefinedDerivedState = function (type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || 'Component'
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName)
              error(
                '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.',
                componentName,
              )
            }
          }
        }
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor
          var componentName =
            (_constructor && getComponentNameFromType(_constructor)) ||
            'ReactClass'
          var warningKey = componentName + '.' + callerName
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return
          }
          error(
            '%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.',
            callerName,
            callerName,
            componentName,
          )
          didWarnAboutNoopUpdateForComponent[warningKey] = true
        }
      }
      var classComponentUpdater = {
        isMounted: function (inst) {
          return false
        },
        enqueueSetState: function (inst, payload, callback) {
          var internals = get(inst)
          if (internals.queue === null) {
            warnNoop(inst, 'setState')
          } else {
            internals.queue.push(payload)
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, 'setState')
              }
            }
          }
        },
        enqueueReplaceState: function (inst, payload, callback) {
          var internals = get(inst)
          internals.replace = true
          internals.queue = [payload]
          {
            if (callback !== void 0 && callback !== null) {
              warnOnInvalidCallback(callback, 'setState')
            }
          }
        },
        enqueueForceUpdate: function (inst, callback) {
          var internals = get(inst)
          if (internals.queue === null) {
            warnNoop(inst, 'forceUpdate')
          } else {
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, 'setState')
              }
            }
          }
        },
      }
      function applyDerivedStateFromProps(
        instance,
        ctor,
        getDerivedStateFromProps,
        prevState,
        nextProps,
      ) {
        var partialState = getDerivedStateFromProps(nextProps, prevState)
        {
          warnOnUndefinedDerivedState(ctor, partialState)
        }
        var newState =
          partialState === null || partialState === void 0
            ? prevState
            : assign2({}, prevState, partialState)
        return newState
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject
        var contextType = ctor.contextType
        {
          if ('contextType' in ctor) {
            var isValid2 =
              // Allow null for conditional declaration
              contextType === null ||
              (contextType !== void 0 &&
                contextType.$$typeof === REACT_CONTEXT_TYPE &&
                contextType._context === void 0)
            if (!isValid2 && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor)
              var addendum = ''
              if (contextType === void 0) {
                addendum =
                  ' However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.'
              } else if (typeof contextType !== 'object') {
                addendum =
                  ' However, it is set to a ' + typeof contextType + '.'
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum =
                  ' Did you accidentally pass the Context.Provider instead?'
              } else if (contextType._context !== void 0) {
                addendum =
                  ' Did you accidentally pass the Context.Consumer instead?'
              } else {
                addendum =
                  ' However, it is set to an object with keys {' +
                  Object.keys(contextType).join(', ') +
                  '}.'
              }
              error(
                '%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s',
                getComponentNameFromType(ctor) || 'Component',
                addendum,
              )
            }
          }
        }
        if (typeof contextType === 'object' && contextType !== null) {
          context = readContext(contextType)
        } else {
          context = maskedLegacyContext
        }
        var instance = new ctor(props, context)
        {
          if (
            typeof ctor.getDerivedStateFromProps === 'function' &&
            (instance.state === null || instance.state === void 0)
          ) {
            var componentName = getComponentNameFromType(ctor) || 'Component'
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName)
              error(
                '`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',
                componentName,
                instance.state === null ? 'null' : 'undefined',
                componentName,
              )
            }
          }
          if (
            typeof ctor.getDerivedStateFromProps === 'function' ||
            typeof instance.getSnapshotBeforeUpdate === 'function'
          ) {
            var foundWillMountName = null
            var foundWillReceivePropsName = null
            var foundWillUpdateName = null
            if (
              typeof instance.componentWillMount === 'function' &&
              instance.componentWillMount.__suppressDeprecationWarning !== true
            ) {
              foundWillMountName = 'componentWillMount'
            } else if (
              typeof instance.UNSAFE_componentWillMount === 'function'
            ) {
              foundWillMountName = 'UNSAFE_componentWillMount'
            }
            if (
              typeof instance.componentWillReceiveProps === 'function' &&
              instance.componentWillReceiveProps
                .__suppressDeprecationWarning !== true
            ) {
              foundWillReceivePropsName = 'componentWillReceiveProps'
            } else if (
              typeof instance.UNSAFE_componentWillReceiveProps === 'function'
            ) {
              foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps'
            }
            if (
              typeof instance.componentWillUpdate === 'function' &&
              instance.componentWillUpdate.__suppressDeprecationWarning !== true
            ) {
              foundWillUpdateName = 'componentWillUpdate'
            } else if (
              typeof instance.UNSAFE_componentWillUpdate === 'function'
            ) {
              foundWillUpdateName = 'UNSAFE_componentWillUpdate'
            }
            if (
              foundWillMountName !== null ||
              foundWillReceivePropsName !== null ||
              foundWillUpdateName !== null
            ) {
              var _componentName = getComponentNameFromType(ctor) || 'Component'
              var newApiName =
                typeof ctor.getDerivedStateFromProps === 'function'
                  ? 'getDerivedStateFromProps()'
                  : 'getSnapshotBeforeUpdate()'
              if (
                !didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)
              ) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName)
                error(
                  'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles',
                  _componentName,
                  newApiName,
                  foundWillMountName !== null
                    ? '\n  ' + foundWillMountName
                    : '',
                  foundWillReceivePropsName !== null
                    ? '\n  ' + foundWillReceivePropsName
                    : '',
                  foundWillUpdateName !== null
                    ? '\n  ' + foundWillUpdateName
                    : '',
                )
              }
            }
          }
        }
        return instance
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || 'Component'
          var renderPresent = instance.render
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === 'function') {
              error(
                '%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?',
                name,
              )
            } else {
              error(
                '%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.',
                name,
              )
            }
          }
          if (
            instance.getInitialState &&
            !instance.getInitialState.isReactClassApproved &&
            !instance.state
          ) {
            error(
              'getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?',
              name,
            )
          }
          if (
            instance.getDefaultProps &&
            !instance.getDefaultProps.isReactClassApproved
          ) {
            error(
              'getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.',
              name,
            )
          }
          if (instance.propTypes) {
            error(
              'propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.',
              name,
            )
          }
          if (instance.contextType) {
            error(
              'contextType was defined as an instance property on %s. Use a static property to define contextType instead.',
              name,
            )
          }
          {
            if (instance.contextTypes) {
              error(
                'contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.',
                name,
              )
            }
            if (
              ctor.contextType &&
              ctor.contextTypes &&
              !didWarnAboutContextTypeAndContextTypes.has(ctor)
            ) {
              didWarnAboutContextTypeAndContextTypes.add(ctor)
              error(
                '%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.',
                name,
              )
            }
          }
          if (typeof instance.componentShouldUpdate === 'function') {
            error(
              '%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.',
              name,
            )
          }
          if (
            ctor.prototype &&
            ctor.prototype.isPureReactComponent &&
            typeof instance.shouldComponentUpdate !== 'undefined'
          ) {
            error(
              '%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.',
              getComponentNameFromType(ctor) || 'A pure component',
            )
          }
          if (typeof instance.componentDidUnmount === 'function') {
            error(
              '%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?',
              name,
            )
          }
          if (typeof instance.componentDidReceiveProps === 'function') {
            error(
              '%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
              name,
            )
          }
          if (typeof instance.componentWillRecieveProps === 'function') {
            error(
              '%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
              name,
            )
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
            error(
              '%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',
              name,
            )
          }
          var hasMutatedProps = instance.props !== newProps
          if (instance.props !== void 0 && hasMutatedProps) {
            error(
              "%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              name,
              name,
            )
          }
          if (instance.defaultProps) {
            error(
              'Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.',
              name,
              name,
            )
          }
          if (
            typeof instance.getSnapshotBeforeUpdate === 'function' &&
            typeof instance.componentDidUpdate !== 'function' &&
            !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)
          ) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor)
            error(
              '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.',
              getComponentNameFromType(ctor),
            )
          }
          if (typeof instance.getDerivedStateFromProps === 'function') {
            error(
              '%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
              name,
            )
          }
          if (typeof instance.getDerivedStateFromError === 'function') {
            error(
              '%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
              name,
            )
          }
          if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
            error(
              '%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.',
              name,
            )
          }
          var _state = instance.state
          if (_state && (typeof _state !== 'object' || isArray2(_state))) {
            error('%s.state: must be set to an object or null', name)
          }
          if (
            typeof instance.getChildContext === 'function' &&
            typeof ctor.childContextTypes !== 'object'
          ) {
            error(
              '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().',
              name,
            )
          }
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state
        if (typeof instance.componentWillMount === 'function') {
          {
            if (
              instance.componentWillMount.__suppressDeprecationWarning !== true
            ) {
              var componentName = getComponentNameFromType(type) || 'Unknown'
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn(
                  // keep this warning in sync with ReactStrictModeWarning.js
                  'componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s',
                  componentName,
                )
                didWarnAboutDeprecatedWillMount[componentName] = true
              }
            }
          }
          instance.componentWillMount()
        }
        if (typeof instance.UNSAFE_componentWillMount === 'function') {
          instance.UNSAFE_componentWillMount()
        }
        if (oldState !== instance.state) {
          {
            error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromType(type) || 'Component',
            )
          }
          classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null,
          )
        }
      }
      function processUpdateQueue(
        internalInstance,
        inst,
        props,
        maskedLegacyContext,
      ) {
        if (
          internalInstance.queue !== null &&
          internalInstance.queue.length > 0
        ) {
          var oldQueue = internalInstance.queue
          var oldReplace = internalInstance.replace
          internalInstance.queue = null
          internalInstance.replace = false
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0]
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state
            var dontMutate = true
            for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
              var partial = oldQueue[i]
              var partialState =
                typeof partial === 'function'
                  ? partial.call(inst, nextState, props, maskedLegacyContext)
                  : partial
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false
                  nextState = assign2({}, nextState, partialState)
                } else {
                  assign2(nextState, partialState)
                }
              }
            }
            inst.state = nextState
          }
        } else {
          internalInstance.queue = null
        }
      }
      function mountClassInstance(
        instance,
        ctor,
        newProps,
        maskedLegacyContext,
      ) {
        {
          checkClassInstance(instance, ctor, newProps)
        }
        var initialState = instance.state !== void 0 ? instance.state : null
        instance.updater = classComponentUpdater
        instance.props = newProps
        instance.state = initialState
        var internalInstance = {
          queue: [],
          replace: false,
        }
        set(instance, internalInstance)
        var contextType = ctor.contextType
        if (typeof contextType === 'object' && contextType !== null) {
          instance.context = readContext(contextType)
        } else {
          instance.context = maskedLegacyContext
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || 'Component'
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName)
              error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName,
              )
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps
        if (typeof getDerivedStateFromProps === 'function') {
          instance.state = applyDerivedStateFromProps(
            instance,
            ctor,
            getDerivedStateFromProps,
            initialState,
            newProps,
          )
        }
        if (
          typeof ctor.getDerivedStateFromProps !== 'function' &&
          typeof instance.getSnapshotBeforeUpdate !== 'function' &&
          (typeof instance.UNSAFE_componentWillMount === 'function' ||
            typeof instance.componentWillMount === 'function')
        ) {
          callComponentWillMount(ctor, instance)
          processUpdateQueue(
            internalInstance,
            instance,
            newProps,
            maskedLegacyContext,
          )
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: '',
      }
      function getTreeId(context) {
        var overflow = context.overflow
        var idWithLeadingBit = context.id
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit)
        return id.toString(32) + overflow
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id
        var baseOverflow = baseContext.overflow
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength)
        var slot = index + 1
        var length = getBitLength(totalChildren) + baseLength
        if (length > 30) {
          var numberOfOverflowBits = baseLength - (baseLength % 5)
          var newOverflowBits = (1 << numberOfOverflowBits) - 1
          var newOverflow = (baseId & newOverflowBits).toString(32)
          var restOfBaseId = baseId >> numberOfOverflowBits
          var restOfBaseLength = baseLength - numberOfOverflowBits
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength
          var restOfNewBits = slot << restOfBaseLength
          var id = restOfNewBits | restOfBaseId
          var overflow = newOverflow + baseOverflow
          return {
            id: (1 << restOfLength) | id,
            overflow,
          }
        } else {
          var newBits = slot << baseLength
          var _id = newBits | baseId
          var _overflow = baseOverflow
          return {
            id: (1 << length) | _id,
            overflow: _overflow,
          }
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number)
      }
      function getLeadingBit(id) {
        return 1 << (getBitLength(id) - 1)
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback
      var log = Math.log
      var LN2 = Math.LN2
      function clz32Fallback(x) {
        var asUint = x >>> 0
        if (asUint === 0) {
          return 32
        }
        return (31 - ((log(asUint) / LN2) | 0)) | 0
      }
      function is(x, y) {
        return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)
      }
      var objectIs = typeof Object.is === 'function' ? Object.is : is
      var currentlyRenderingComponent = null
      var currentlyRenderingTask = null
      var firstWorkInProgressHook = null
      var workInProgressHook = null
      var isReRender = false
      var didScheduleRenderPhaseUpdate = false
      var localIdCounter = 0
      var renderPhaseUpdates = null
      var numberOfReRenders = 0
      var RE_RENDER_LIMIT = 25
      var isInHookUserCodeInDev = false
      var currentHookNameInDev
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error(
            'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
          )
        }
        {
          if (isInHookUserCodeInDev) {
            error(
              'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks',
            )
          }
        }
        return currentlyRenderingComponent
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error(
              '%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.',
              currentHookNameInDev,
            )
          }
          return false
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error(
              'The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s',
              currentHookNameInDev,
              '[' + nextDeps.join(', ') + ']',
              '[' + prevDeps.join(', ') + ']',
            )
          }
        }
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue
          }
          return false
        }
        return true
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error('Rendered more hooks than during the previous render')
        }
        return {
          memoizedState: null,
          queue: null,
          next: null,
        }
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false
            firstWorkInProgressHook = workInProgressHook = createHook()
          } else {
            isReRender = true
            workInProgressHook = firstWorkInProgressHook
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false
            workInProgressHook = workInProgressHook.next = createHook()
          } else {
            isReRender = true
            workInProgressHook = workInProgressHook.next
          }
        }
        return workInProgressHook
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity
        currentlyRenderingTask = task
        {
          isInHookUserCodeInDev = false
        }
        localIdCounter = 0
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false
          localIdCounter = 0
          numberOfReRenders += 1
          workInProgressHook = null
          children = Component(props, refOrContext)
        }
        resetHooksState()
        return children
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0
        return didRenderIdHook
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false
        }
        currentlyRenderingComponent = null
        currentlyRenderingTask = null
        didScheduleRenderPhaseUpdate = false
        firstWorkInProgressHook = null
        numberOfReRenders = 0
        renderPhaseUpdates = null
        workInProgressHook = null
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error(
              'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().',
            )
          }
        }
        return readContext(context)
      }
      function useContext(context) {
        {
          currentHookNameInDev = 'useContext'
        }
        resolveCurrentlyRenderingComponent()
        return readContext(context)
      }
      function basicStateReducer(state, action) {
        return typeof action === 'function' ? action(state) : action
      }
      function useState(initialState) {
        {
          currentHookNameInDev = 'useState'
        }
        return useReducer(
          basicStateReducer,
          // useReducer has a special case to support lazy useState initializers
          initialState,
        )
      }
      function useReducer(reducer, initialArg, init) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = 'useReducer'
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent()
        workInProgressHook = createWorkInProgressHook()
        if (isReRender) {
          var queue = workInProgressHook.queue
          var dispatch = queue.dispatch
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue)
              var newState = workInProgressHook.memoizedState
              var update = firstRenderPhaseUpdate
              do {
                var action = update.action
                {
                  isInHookUserCodeInDev = true
                }
                newState = reducer(newState, action)
                {
                  isInHookUserCodeInDev = false
                }
                update = update.next
              } while (update !== null)
              workInProgressHook.memoizedState = newState
              return [newState, dispatch]
            }
          }
          return [workInProgressHook.memoizedState, dispatch]
        } else {
          {
            isInHookUserCodeInDev = true
          }
          var initialState
          if (reducer === basicStateReducer) {
            initialState =
              typeof initialArg === 'function' ? initialArg() : initialArg
          } else {
            initialState = init !== void 0 ? init(initialArg) : initialArg
          }
          {
            isInHookUserCodeInDev = false
          }
          workInProgressHook.memoizedState = initialState
          var _queue = (workInProgressHook.queue = {
            last: null,
            dispatch: null,
          })
          var _dispatch = (_queue.dispatch = dispatchAction.bind(
            null,
            currentlyRenderingComponent,
            _queue,
          ))
          return [workInProgressHook.memoizedState, _dispatch]
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent()
        workInProgressHook = createWorkInProgressHook()
        var nextDeps = deps === void 0 ? null : deps
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1]
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0]
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true
        }
        var nextValue = nextCreate()
        {
          isInHookUserCodeInDev = false
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps]
        return nextValue
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent()
        workInProgressHook = createWorkInProgressHook()
        var previousRef = workInProgressHook.memoizedState
        if (previousRef === null) {
          var ref = {
            current: initialValue,
          }
          {
            Object.seal(ref)
          }
          workInProgressHook.memoizedState = ref
          return ref
        } else {
          return previousRef
        }
      }
      function useLayoutEffect(create, inputs) {
        {
          currentHookNameInDev = 'useLayoutEffect'
          error(
            "useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.",
          )
        }
      }
      function dispatchAction(componentIdentity, queue, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error(
            'Too many re-renders. React limits the number of renders to prevent an infinite loop.',
          )
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true
          var update = {
            action,
            next: null,
          }
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = /* @__PURE__ */ new Map()
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)
          if (firstRenderPhaseUpdate === void 0) {
            renderPhaseUpdates.set(queue, update)
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next
            }
            lastRenderPhaseUpdate.next = update
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function () {
          return callback
        }, deps)
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        resolveCurrentlyRenderingComponent()
        return getSnapshot(source._source)
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === void 0) {
          throw new Error(
            'Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.',
          )
        }
        return getServerSnapshot()
      }
      function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent()
        return value
      }
      function unsupportedStartTransition() {
        throw new Error(
          'startTransition cannot be called during server rendering.',
        )
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent()
        return [false, unsupportedStartTransition]
      }
      function useId() {
        var task = currentlyRenderingTask
        var treeId = getTreeId(task.treeContext)
        var responseState = currentResponseState
        if (responseState === null) {
          throw new Error(
            'Invalid hook call. Hooks can only be called inside of the body of a function component.',
          )
        }
        var localId = localIdCounter++
        return makeId(responseState, treeId, localId)
      }
      function noop2() {}
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop2,
        useLayoutEffect,
        useCallback,
        // useImperativeHandle is not run in the server environment
        useImperativeHandle: noop2,
        // Effects are not run in the server environment.
        useEffect: noop2,
        // Debugging effect
        useDebugValue: noop2,
        useDeferredValue,
        useTransition,
        useId,
        // Subscriptions are not setup in a server environment.
        useMutableSource,
        useSyncExternalStore,
      }
      var currentResponseState = null
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = ''
          var node = componentStack
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null)
                break
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null)
                break
              case 2:
                info += describeClassComponentFrame(node.type, null, null)
                break
            }
            node = node.parent
          } while (node)
          return info
        } catch (x) {
          return '\nError generating stack: ' + x.message + '\n' + x.stack
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame
      var PENDING = 0
      var COMPLETED = 1
      var FLUSHED = 2
      var ABORTED = 3
      var ERRORED = 4
      var OPEN = 0
      var CLOSING = 1
      var CLOSED = 2
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800
      function defaultErrorHandler(error2) {
        console['error'](error2)
        return null
      }
      function noop$1() {}
      function createRequest(
        children,
        responseState,
        rootFormatContext,
        progressiveChunkSize,
        onError2,
        onAllReady,
        onShellReady,
        onShellError,
        onFatalError,
      ) {
        var pingedTasks = []
        var abortSet = /* @__PURE__ */ new Set()
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize:
            progressiveChunkSize === void 0
              ? DEFAULT_PROGRESSIVE_CHUNK_SIZE
              : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError2 === void 0 ? defaultErrorHandler : onError2,
          onAllReady: noop$1,
          onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
          onShellError: noop$1,
          onFatalError: noop$1,
        }
        var rootSegment = createPendingSegment(
          request,
          0,
          null,
          rootFormatContext,
          // Root segments are never embedded in Text on either edge
          false,
          false,
        )
        rootSegment.parentFlushed = true
        var rootTask = createTask(
          request,
          children,
          null,
          rootSegment,
          abortSet,
          emptyContextObject,
          rootContextSnapshot,
          emptyTreeContext,
        )
        pingedTasks.push(rootTask)
        return request
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks
        pingedTasks.push(task)
        if (pingedTasks.length === 1) {
          scheduleWork(function () {
            return performWork(request)
          })
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null,
        }
      }
      function createTask(
        request,
        node,
        blockedBoundary,
        blockedSegment,
        abortSet,
        legacyContext,
        context,
        treeContext,
      ) {
        request.allPendingTasks++
        if (blockedBoundary === null) {
          request.pendingRootTasks++
        } else {
          blockedBoundary.pendingTasks++
        }
        var task = {
          node,
          ping: function () {
            return pingTask(request, task)
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext,
        }
        {
          task.componentStack = null
        }
        abortSet.add(task)
        return task
      }
      function createPendingSegment(
        request,
        index,
        boundary,
        formatContext,
        lastPushedText,
        textEmbedded,
      ) {
        return {
          status: PENDING,
          id: -1,
          // lazily assigned later
          index,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded,
        }
      }
      var currentTaskInDEV = null
      function getCurrentStackInDEV() {
        {
          if (
            currentTaskInDEV === null ||
            currentTaskInDEV.componentStack === null
          ) {
            return ''
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack)
        }
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type,
          }
        }
      }
      function pushFunctionComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type,
          }
        }
      }
      function pushClassComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type,
          }
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error(
              'Unexpectedly popped too many stack frames. This is a bug in React.',
            )
          } else {
            task.componentStack = task.componentStack.parent
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage
          if (typeof error2 === 'string') {
            errorMessage = error2
          } else if (error2 && typeof error2.message === 'string') {
            errorMessage = error2.message
          } else {
            errorMessage = String(error2)
          }
          var errorComponentStack =
            lastBoundaryErrorComponentStackDev || getCurrentStackInDEV()
          lastBoundaryErrorComponentStackDev = null
          boundary.errorMessage = errorMessage
          boundary.errorComponentStack = errorComponentStack
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2)
        if (errorDigest != null && typeof errorDigest !== 'string') {
          throw new Error(
            'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
              typeof errorDigest +
              '" instead',
          )
        }
        return errorDigest
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError
        onShellError(error2)
        var onFatalError = request.onFatalError
        onFatalError(error2)
        if (request.destination !== null) {
          request.status = CLOSED
          closeWithError(request.destination, error2)
        } else {
          request.status = CLOSING
          request.fatalError = error2
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, 'Suspense')
        var parentBoundary = task.blockedBoundary
        var parentSegment = task.blockedSegment
        var fallback = props.fallback
        var content = props.children
        var fallbackAbortSet = /* @__PURE__ */ new Set()
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet)
        var insertionIndex = parentSegment.chunks.length
        var boundarySegment = createPendingSegment(
          request,
          insertionIndex,
          newBoundary,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          false,
          false,
        )
        parentSegment.children.push(boundarySegment)
        parentSegment.lastPushedText = false
        var contentRootSegment = createPendingSegment(
          request,
          0,
          null,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          false,
          false,
        )
        contentRootSegment.parentFlushed = true
        task.blockedBoundary = newBoundary
        task.blockedSegment = contentRootSegment
        try {
          renderNode(request, task, content)
          pushSegmentFinale$1(
            contentRootSegment.chunks,
            request.responseState,
            contentRootSegment.lastPushedText,
            contentRootSegment.textEmbedded,
          )
          contentRootSegment.status = COMPLETED
          queueCompletedSegment(newBoundary, contentRootSegment)
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task)
            return
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED
          newBoundary.forceClientRender = true
          newBoundary.errorDigest = logRecoverableError(request, error2)
          {
            captureBoundaryErrorDetailsDev(newBoundary, error2)
          }
        } finally {
          task.blockedBoundary = parentBoundary
          task.blockedSegment = parentSegment
        }
        var suspendedFallbackTask = createTask(
          request,
          fallback,
          parentBoundary,
          boundarySegment,
          fallbackAbortSet,
          task.legacyContext,
          task.context,
          task.treeContext,
        )
        {
          suspendedFallbackTask.componentStack = task.componentStack
        }
        request.pingedTasks.push(suspendedFallbackTask)
        popComponentStackInDEV(task)
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type)
        var segment = task.blockedSegment
        var children = pushStartInstance(
          segment.chunks,
          type,
          props,
          request.responseState,
          segment.formatContext,
        )
        segment.lastPushedText = false
        var prevContext = segment.formatContext
        segment.formatContext = getChildFormatContext(prevContext, type, props)
        renderNode(request, task, children)
        segment.formatContext = prevContext
        pushEndInstance(segment.chunks, type)
        segment.lastPushedText = false
        popComponentStackInDEV(task)
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {}
        prepareToUseHooks(task, componentIdentity)
        var result = Component(props, secondArg)
        return finishHooks(Component, props, result, secondArg)
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render()
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error(
                'It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.',
                getComponentNameFromType(Component) || 'a component',
              )
            }
            didWarnAboutReassigningProps = true
          }
        }
        {
          var childContextTypes = Component.childContextTypes
          if (childContextTypes !== null && childContextTypes !== void 0) {
            var previousContext = task.legacyContext
            var mergedContext = processChildContext(
              instance,
              Component,
              previousContext,
              childContextTypes,
            )
            task.legacyContext = mergedContext
            renderNodeDestructive(request, task, nextChildren)
            task.legacyContext = previousContext
            return
          }
        }
        renderNodeDestructive(request, task, nextChildren)
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component)
        var maskedContext = getMaskedContext(Component, task.legacyContext)
        var instance = constructClassInstance(Component, props, maskedContext)
        mountClassInstance(instance, Component, props, maskedContext)
        finishClassComponent(request, task, instance, Component, props)
        popComponentStackInDEV(task)
      }
      var didWarnAboutBadClass = {}
      var didWarnAboutModulePatternComponent = {}
      var didWarnAboutContextTypeOnFunctionComponent = {}
      var didWarnAboutGetDerivedStateOnFunctionComponent = {}
      var didWarnAboutReassigningProps = false
      var didWarnAboutGenerators = false
      var didWarnAboutMaps = false
      var hasWarnedAboutUsingContextAsConsumer = false
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext
        {
          legacyContext = getMaskedContext(Component, task.legacyContext)
        }
        pushFunctionComponentStackInDEV(task, Component)
        {
          if (
            Component.prototype &&
            typeof Component.prototype.render === 'function'
          ) {
            var componentName = getComponentNameFromType(Component) || 'Unknown'
            if (!didWarnAboutBadClass[componentName]) {
              error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName,
                componentName,
              )
              didWarnAboutBadClass[componentName] = true
            }
          }
        }
        var value = renderWithHooks(
          request,
          task,
          Component,
          props,
          legacyContext,
        )
        var hasId = checkDidRenderIdHook()
        {
          if (
            typeof value === 'object' &&
            value !== null &&
            typeof value.render === 'function' &&
            value.$$typeof === void 0
          ) {
            var _componentName =
              getComponentNameFromType(Component) || 'Unknown'
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error(
                "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
                _componentName,
                _componentName,
                _componentName,
              )
              didWarnAboutModulePatternComponent[_componentName] = true
            }
          }
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value === 'object' &&
          value !== null &&
          typeof value.render === 'function' &&
          value.$$typeof === void 0
        ) {
          {
            var _componentName2 =
              getComponentNameFromType(Component) || 'Unknown'
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error(
                "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
                _componentName2,
                _componentName2,
                _componentName2,
              )
              didWarnAboutModulePatternComponent[_componentName2] = true
            }
          }
          mountClassInstance(value, Component, props, legacyContext)
          finishClassComponent(request, task, value, Component, props)
        } else {
          {
            validateFunctionComponentInDev(Component)
          }
          if (hasId) {
            var prevTreeContext = task.treeContext
            var totalChildren = 1
            var index = 0
            task.treeContext = pushTreeContext(
              prevTreeContext,
              totalChildren,
              index,
            )
            try {
              renderNodeDestructive(request, task, value)
            } finally {
              task.treeContext = prevTreeContext
            }
          } else {
            renderNodeDestructive(request, task, value)
          }
        }
        popComponentStackInDEV(task)
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error(
                '%s(...): childContextTypes cannot be defined on a function component.',
                Component.displayName || Component.name || 'Component',
              )
            }
          }
          if (typeof Component.getDerivedStateFromProps === 'function') {
            var _componentName3 =
              getComponentNameFromType(Component) || 'Unknown'
            if (
              !didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]
            ) {
              error(
                '%s: Function components do not support getDerivedStateFromProps.',
                _componentName3,
              )
              didWarnAboutGetDerivedStateOnFunctionComponent[
                _componentName3
              ] = true
            }
          }
          if (
            typeof Component.contextType === 'object' &&
            Component.contextType !== null
          ) {
            var _componentName4 =
              getComponentNameFromType(Component) || 'Unknown'
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error(
                '%s: Function components do not support contextType.',
                _componentName4,
              )
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign2({}, baseProps)
          var defaultProps = Component.defaultProps
          for (var propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName]
            }
          }
          return props
        }
        return baseProps
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render)
        var children = renderWithHooks(request, task, type.render, props, ref)
        var hasId = checkDidRenderIdHook()
        if (hasId) {
          var prevTreeContext = task.treeContext
          var totalChildren = 1
          var index = 0
          task.treeContext = pushTreeContext(
            prevTreeContext,
            totalChildren,
            index,
          )
          try {
            renderNodeDestructive(request, task, children)
          } finally {
            task.treeContext = prevTreeContext
          }
        } else {
          renderNodeDestructive(request, task, children)
        }
        popComponentStackInDEV(task)
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type
        var resolvedProps = resolveDefaultProps(innerType, props)
        renderElement(request, task, innerType, resolvedProps, ref)
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === void 0) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true
                error(
                  'Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?',
                )
              }
            }
          } else {
            context = context._context
          }
        }
        var render = props.children
        {
          if (typeof render !== 'function') {
            error(
              "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.",
            )
          }
        }
        var newValue = readContext(context)
        var newChildren = render(newValue)
        renderNodeDestructive(request, task, newChildren)
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context
        var value = props.value
        var children = props.children
        var prevSnapshot
        {
          prevSnapshot = task.context
        }
        task.context = pushProvider(context, value)
        renderNodeDestructive(request, task, children)
        task.context = popProvider(context)
        {
          if (prevSnapshot !== task.context) {
            error(
              'Popping the context provider did not return back to the original snapshot. This is a bug in React.',
            )
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, 'Lazy')
        var payload = lazyComponent._payload
        var init = lazyComponent._init
        var Component = init(payload)
        var resolvedProps = resolveDefaultProps(Component, props)
        renderElement(request, task, Component, resolvedProps, ref)
        popComponentStackInDEV(task)
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type === 'function') {
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props)
            return
          } else {
            renderIndeterminateComponent(request, task, type, props)
            return
          }
        }
        if (typeof type === 'string') {
          renderHostElement(request, task, type, props)
          return
        }
        switch (type) {
          // TODO: LegacyHidden acts the same as a fragment. This only works
          // because we currently assume that every instance of LegacyHidden is
          // accompanied by a host component wrapper. In the hidden mode, the host
          // component is given a `hidden` attribute, which ensures that the
          // initial HTML is not visible. To support the use of LegacyHidden as a
          // true fragment, without an extra DOM node, we would have to hide the
          // initial HTML in some other way.
          // TODO: Add REACT_OFFSCREEN_TYPE here too with the same capability.
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children)
            return
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, 'SuspenseList')
            renderNodeDestructive(request, task, props.children)
            popComponentStackInDEV(task)
            return
          }
          case REACT_SCOPE_TYPE: {
            throw new Error(
              'ReactDOMServer does not yet support scope components.',
            )
          }
          // eslint-disable-next-line-no-fallthrough
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props)
            }
            return
          }
        }
        if (typeof type === 'object' && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref)
              return
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref)
              return
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props)
              return
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props)
              return
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props)
              return
            }
          }
        }
        var info = ''
        {
          if (
            type === void 0 ||
            (typeof type === 'object' &&
              type !== null &&
              Object.keys(type).length === 0)
          ) {
            info +=
              " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."
          }
        }
        throw new Error(
          'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) ' +
            ('but got: ' + (type == null ? type : typeof type) + '.' + info),
        )
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (
            typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === 'Generator'
          ) {
            if (!didWarnAboutGenerators) {
              error(
                'Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.',
              )
            }
            didWarnAboutGenerators = true
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error(
                'Using Maps as children is not supported. Use an array of keyed ReactElements instead.',
              )
            }
            didWarnAboutMaps = true
          }
        }
      }
      function renderNodeDestructive(request, task, node) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node)
          } catch (x) {
            if (
              typeof x === 'object' &&
              x !== null &&
              typeof x.then === 'function'
            );
            else {
              lastBoundaryErrorComponentStackDev =
                lastBoundaryErrorComponentStackDev !== null
                  ? lastBoundaryErrorComponentStackDev
                  : getCurrentStackInDEV()
            }
            throw x
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        task.node = node
        if (typeof node === 'object' && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node
              var type = element.type
              var props = element.props
              var ref = element.ref
              renderElement(request, task, type, props, ref)
              return
            }
            case REACT_PORTAL_TYPE:
              throw new Error(
                'Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.',
              )
            // eslint-disable-next-line-no-fallthrough
            case REACT_LAZY_TYPE: {
              var lazyNode = node
              var payload = lazyNode._payload
              var init = lazyNode._init
              var resolvedNode
              {
                try {
                  resolvedNode = init(payload)
                } catch (x) {
                  if (
                    typeof x === 'object' &&
                    x !== null &&
                    typeof x.then === 'function'
                  ) {
                    pushBuiltInComponentStackInDEV(task, 'Lazy')
                  }
                  throw x
                }
              }
              renderNodeDestructive(request, task, resolvedNode)
              return
            }
          }
          if (isArray2(node)) {
            renderChildrenArray(request, task, node)
            return
          }
          var iteratorFn = getIteratorFn(node)
          if (iteratorFn) {
            {
              validateIterable(node, iteratorFn)
            }
            var iterator = iteratorFn.call(node)
            if (iterator) {
              var step = iterator.next()
              if (!step.done) {
                var children = []
                do {
                  children.push(step.value)
                  step = iterator.next()
                } while (!step.done)
                renderChildrenArray(request, task, children)
                return
              }
              return
            }
          }
          var childString = Object.prototype.toString.call(node)
          throw new Error(
            'Objects are not valid as a React child (found: ' +
              (childString === '[object Object]'
                ? 'object with keys {' + Object.keys(node).join(', ') + '}'
                : childString) +
              '). If you meant to render a collection of children, use an array instead.',
          )
        }
        if (typeof node === 'string') {
          var segment = task.blockedSegment
          segment.lastPushedText = pushTextInstance$1(
            task.blockedSegment.chunks,
            node,
            request.responseState,
            segment.lastPushedText,
          )
          return
        }
        if (typeof node === 'number') {
          var _segment = task.blockedSegment
          _segment.lastPushedText = pushTextInstance$1(
            task.blockedSegment.chunks,
            '' + node,
            request.responseState,
            _segment.lastPushedText,
          )
          return
        }
        {
          if (typeof node === 'function') {
            error(
              'Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.',
            )
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length
        for (var i = 0; i < totalChildren; i++) {
          var prevTreeContext = task.treeContext
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i)
          try {
            renderNode(request, task, children[i])
          } finally {
            task.treeContext = prevTreeContext
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment
        var insertionIndex = segment.chunks.length
        var newSegment = createPendingSegment(
          request,
          insertionIndex,
          null,
          segment.formatContext,
          // Adopt the parent segment's leading text embed
          segment.lastPushedText,
          // Assume we are text embedded at the trailing edge
          true,
        )
        segment.children.push(newSegment)
        segment.lastPushedText = false
        var newTask = createTask(
          request,
          task.node,
          task.blockedBoundary,
          newSegment,
          task.abortSet,
          task.legacyContext,
          task.context,
          task.treeContext,
        )
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent
          }
        }
        var ping = newTask.ping
        x.then(ping, ping)
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext
        var previousLegacyContext = task.legacyContext
        var previousContext = task.context
        var previousComponentStack = null
        {
          previousComponentStack = task.componentStack
        }
        try {
          return renderNodeDestructive(request, task, node)
        } catch (x) {
          resetHooksState()
          if (
            typeof x === 'object' &&
            x !== null &&
            typeof x.then === 'function'
          ) {
            spawnNewSuspendedTask(request, task, x)
            task.blockedSegment.formatContext = previousFormatContext
            task.legacyContext = previousLegacyContext
            task.context = previousContext
            switchContext(previousContext)
            {
              task.componentStack = previousComponentStack
            }
            return
          } else {
            task.blockedSegment.formatContext = previousFormatContext
            task.legacyContext = previousLegacyContext
            task.context = previousContext
            switchContext(previousContext)
            {
              task.componentStack = previousComponentStack
            }
            throw x
          }
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2)
        if (boundary === null) {
          fatalError(request, error2)
        } else {
          boundary.pendingTasks--
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true
            boundary.errorDigest = errorDigest
            {
              captureBoundaryErrorDetailsDev(boundary, error2)
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary)
            }
          }
        }
        request.allPendingTasks--
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady
          onAllReady()
        }
      }
      function abortTaskSoft(task) {
        var request = this
        var boundary = task.blockedBoundary
        var segment = task.blockedSegment
        segment.status = ABORTED
        finishedTask(request, boundary, segment)
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary
        var segment = task.blockedSegment
        segment.status = ABORTED
        if (boundary === null) {
          request.allPendingTasks--
          if (request.status !== CLOSED) {
            request.status = CLOSED
            if (request.destination !== null) {
              close(request.destination)
            }
          }
        } else {
          boundary.pendingTasks--
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true
            var _error =
              reason === void 0
                ? new Error(
                    'The render was aborted by the server without a reason.',
                  )
                : reason
            boundary.errorDigest = request.onError(_error)
            {
              var errorPrefix =
                'The server did not finish this Suspense boundary: '
              if (_error && typeof _error.message === 'string') {
                _error = errorPrefix + _error.message
              } else {
                _error = errorPrefix + String(_error)
              }
              var previousTaskInDev = currentTaskInDEV
              currentTaskInDEV = task
              try {
                captureBoundaryErrorDetailsDev(boundary, _error)
              } finally {
                currentTaskInDEV = previousTaskInDev
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary)
            }
          }
          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
            return abortTask(fallbackTask, request, reason)
          })
          boundary.fallbackAbortableTasks.clear()
          request.allPendingTasks--
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady
            onAllReady()
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (
          segment.chunks.length === 0 &&
          segment.children.length === 1 &&
          segment.children[0].boundary === null
        ) {
          var childSegment = segment.children[0]
          childSegment.id = segment.id
          childSegment.parentFlushed = true
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment)
          }
        } else {
          var completedSegments = boundary.completedSegments
          completedSegments.push(segment)
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error(
                'There can only be one root segment. This is a bug in React.',
              )
            }
            request.completedRootSegment = segment
          }
          request.pendingRootTasks--
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1
            var onShellReady = request.onShellReady
            onShellReady()
          }
        } else {
          boundary.pendingTasks--
          if (boundary.forceClientRender);
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment)
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary)
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request)
            boundary.fallbackAbortableTasks.clear()
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment)
                var completedSegments = boundary.completedSegments
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary)
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady
          onAllReady()
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment
        if (segment.status !== PENDING) {
          return
        }
        switchContext(task.context)
        var prevTaskInDEV = null
        {
          prevTaskInDEV = currentTaskInDEV
          currentTaskInDEV = task
        }
        try {
          renderNodeDestructive(request, task, task.node)
          pushSegmentFinale$1(
            segment.chunks,
            request.responseState,
            segment.lastPushedText,
            segment.textEmbedded,
          )
          task.abortSet.delete(task)
          segment.status = COMPLETED
          finishedTask(request, task.blockedBoundary, segment)
        } catch (x) {
          resetHooksState()
          if (
            typeof x === 'object' &&
            x !== null &&
            typeof x.then === 'function'
          ) {
            var ping = task.ping
            x.then(ping, ping)
          } else {
            task.abortSet.delete(task)
            segment.status = ERRORED
            erroredTask(request, task.blockedBoundary, segment, x)
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return
        }
        var prevContext = getActiveContext()
        var prevDispatcher = ReactCurrentDispatcher$1.current
        ReactCurrentDispatcher$1.current = Dispatcher
        var prevGetCurrentStackImpl
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV
        }
        var prevResponseState = currentResponseState
        setCurrentResponseState(request.responseState)
        try {
          var pingedTasks = request.pingedTasks
          var i
          for (i = 0; i < pingedTasks.length; i++) {
            var task = pingedTasks[i]
            retryTask(request, task)
          }
          pingedTasks.splice(0, i)
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination)
          }
        } catch (error2) {
          logRecoverableError(request, error2)
          fatalError(request, error2)
        } finally {
          setCurrentResponseState(prevResponseState)
          ReactCurrentDispatcher$1.current = prevDispatcher
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext)
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true
        switch (segment.status) {
          case PENDING: {
            var segmentID = (segment.id = request.nextSegmentId++)
            segment.lastPushedText = false
            segment.textEmbedded = false
            return writePlaceholder(
              destination,
              request.responseState,
              segmentID,
            )
          }
          case COMPLETED: {
            segment.status = FLUSHED
            var r = true
            var chunks = segment.chunks
            var chunkIdx = 0
            var children = segment.children
            for (var childIdx = 0; childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx]
              for (; chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx])
              }
              r = flushSegment(request, destination, nextChild)
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx])
            }
            if (chunkIdx < chunks.length) {
              r = writeChunkAndReturn(destination, chunks[chunkIdx])
            }
            return r
          }
          default: {
            throw new Error(
              'Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.',
            )
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary
        if (boundary === null) {
          return flushSubtree(request, destination, segment)
        }
        boundary.parentFlushed = true
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary$1(
            destination,
            request.responseState,
            boundary.errorDigest,
            boundary.errorMessage,
            boundary.errorComponentStack,
          )
          flushSubtree(request, destination, segment)
          return writeEndClientRenderedSuspenseBoundary$1(
            destination,
            request.responseState,
          )
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary)
          }
          var id = (boundary.id = assignSuspenseBoundaryID(
            request.responseState,
          ))
          writeStartPendingSuspenseBoundary(
            destination,
            request.responseState,
            id,
          )
          flushSubtree(request, destination, segment)
          return writeEndPendingSuspenseBoundary(
            destination,
            request.responseState,
          )
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++
          request.completedBoundaries.push(boundary)
          writeStartPendingSuspenseBoundary(
            destination,
            request.responseState,
            boundary.id,
          )
          flushSubtree(request, destination, segment)
          return writeEndPendingSuspenseBoundary(
            destination,
            request.responseState,
          )
        } else {
          writeStartCompletedSuspenseBoundary$1(
            destination,
            request.responseState,
          )
          var completedSegments = boundary.completedSegments
          if (completedSegments.length !== 1) {
            throw new Error(
              'A previously unvisited boundary must have exactly one root segment. This is a bug in React.',
            )
          }
          var contentSegment = completedSegments[0]
          flushSegment(request, destination, contentSegment)
          return writeEndCompletedSuspenseBoundary$1(
            destination,
            request.responseState,
          )
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(
          destination,
          request.responseState,
          boundary.id,
          boundary.errorDigest,
          boundary.errorMessage,
          boundary.errorComponentStack,
        )
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(
          destination,
          request.responseState,
          segment.formatContext,
          segment.id,
        )
        flushSegment(request, destination, segment)
        return writeEndSegment(destination, segment.formatContext)
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments
        var i = 0
        for (; i < completedSegments.length; i++) {
          var segment = completedSegments[i]
          flushPartiallyCompletedSegment(
            request,
            destination,
            boundary,
            segment,
          )
        }
        completedSegments.length = 0
        return writeCompletedBoundaryInstruction(
          destination,
          request.responseState,
          boundary.id,
          boundary.rootSegmentID,
        )
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments
        var i = 0
        for (; i < completedSegments.length; i++) {
          var segment = completedSegments[i]
          if (
            !flushPartiallyCompletedSegment(
              request,
              destination,
              boundary,
              segment,
            )
          ) {
            i++
            completedSegments.splice(0, i)
            return false
          }
        }
        completedSegments.splice(0, i)
        return true
      }
      function flushPartiallyCompletedSegment(
        request,
        destination,
        boundary,
        segment,
      ) {
        if (segment.status === FLUSHED) {
          return true
        }
        var segmentID = segment.id
        if (segmentID === -1) {
          var rootSegmentID = (segment.id = boundary.rootSegmentID)
          if (rootSegmentID === -1) {
            throw new Error(
              'A root segment ID must have been assigned by now. This is a bug in React.',
            )
          }
          return flushSegmentContainer(request, destination, segment)
        } else {
          flushSegmentContainer(request, destination, segment)
          return writeCompletedSegmentInstruction(
            destination,
            request.responseState,
            segmentID,
          )
        }
      }
      function flushCompletedQueues(request, destination) {
        try {
          var completedRootSegment = request.completedRootSegment
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment)
            request.completedRootSegment = null
            writeCompletedRoot(destination, request.responseState)
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries
          var i
          for (i = 0; i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i]
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null
              i++
              clientRenderedBoundaries.splice(0, i)
              return
            }
          }
          clientRenderedBoundaries.splice(0, i)
          var completedBoundaries = request.completedBoundaries
          for (i = 0; i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i]
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null
              i++
              completedBoundaries.splice(0, i)
              return
            }
          }
          completedBoundaries.splice(0, i)
          completeWriting(destination)
          beginWriting(destination)
          var partialBoundaries = request.partialBoundaries
          for (i = 0; i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i]
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null
              i++
              partialBoundaries.splice(0, i)
              return
            }
          }
          partialBoundaries.splice(0, i)
          var largeBoundaries = request.completedBoundaries
          for (i = 0; i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i]
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null
              i++
              largeBoundaries.splice(0, i)
              return
            }
          }
          largeBoundaries.splice(0, i)
        } finally {
          if (
            request.allPendingTasks === 0 &&
            request.pingedTasks.length === 0 &&
            request.clientRenderedBoundaries.length === 0 &&
            request.completedBoundaries.length === 0
          ) {
            {
              if (request.abortableTasks.size !== 0) {
                error(
                  'There was still abortable task at the root when we closed. This is a bug in React.',
                )
              }
            }
            close(destination)
          }
        }
      }
      function startWork(request) {
        scheduleWork(function () {
          return performWork(request)
        })
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED
          closeWithError(destination, request.fatalError)
          return
        }
        if (request.status === CLOSED) {
          return
        }
        if (request.destination !== null) {
          return
        }
        request.destination = destination
        try {
          flushCompletedQueues(request, destination)
        } catch (error2) {
          logRecoverableError(request, error2)
          fatalError(request, error2)
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks
          abortableTasks.forEach(function (task) {
            return abortTask(task, request, reason)
          })
          abortableTasks.clear()
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination)
          }
        } catch (error2) {
          logRecoverableError(request, error2)
          fatalError(request, error2)
        }
      }
      function onError() {}
      function renderToStringImpl(
        children,
        options,
        generateStaticMarkup,
        abortReason,
      ) {
        var didFatal = false
        var fatalError2 = null
        var result = ''
        var destination = {
          push: function (chunk) {
            if (chunk !== null) {
              result += chunk
            }
            return true
          },
          destroy: function (error2) {
            didFatal = true
            fatalError2 = error2
          },
        }
        var readyToStream = false
        function onShellReady() {
          readyToStream = true
        }
        var request = createRequest(
          children,
          createResponseState$1(
            generateStaticMarkup,
            options ? options.identifierPrefix : void 0,
          ),
          createRootFormatContext(),
          Infinity,
          onError,
          void 0,
          onShellReady,
        )
        startWork(request)
        abort(request, abortReason)
        startFlowing(request, destination)
        if (didFatal) {
          throw fatalError2
        }
        if (!readyToStream) {
          throw new Error(
            'A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.',
          )
        }
        return result
      }
      function renderToString(children, options) {
        return renderToStringImpl(
          children,
          options,
          false,
          'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server',
        )
      }
      function renderToStaticMarkup(children, options) {
        return renderToStringImpl(
          children,
          options,
          true,
          'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server',
        )
      }
      function renderToNodeStream() {
        throw new Error(
          'ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.',
        )
      }
      function renderToStaticNodeStream() {
        throw new Error(
          'ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.',
        )
      }
      reactDomServerLegacy_browser_development.renderToNodeStream =
        renderToNodeStream
      reactDomServerLegacy_browser_development.renderToStaticMarkup =
        renderToStaticMarkup
      reactDomServerLegacy_browser_development.renderToStaticNodeStream =
        renderToStaticNodeStream
      reactDomServerLegacy_browser_development.renderToString = renderToString
      reactDomServerLegacy_browser_development.version = ReactVersion
    })()
  }
  return reactDomServerLegacy_browser_development
}
var reactDomServer_browser_development = {}
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServer_browser_development
function requireReactDomServer_browser_development() {
  if (hasRequiredReactDomServer_browser_development)
    return reactDomServer_browser_development
  hasRequiredReactDomServer_browser_development = 1
  if (process.env.NODE_ENV !== 'production') {
    ;(function () {
      var React2 = requireReact()
      var ReactVersion = '18.2.0'
      var ReactSharedInternals =
        React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      function warn(format2) {
        {
          {
            for (
              var _len = arguments.length,
                args = new Array(_len > 1 ? _len - 1 : 0),
                _key = 1;
              _key < _len;
              _key++
            ) {
              args[_key - 1] = arguments[_key]
            }
            printWarning('warn', format2, args)
          }
        }
      }
      function error(format2) {
        {
          {
            for (
              var _len2 = arguments.length,
                args = new Array(_len2 > 1 ? _len2 - 1 : 0),
                _key2 = 1;
              _key2 < _len2;
              _key2++
            ) {
              args[_key2 - 1] = arguments[_key2]
            }
            printWarning('error', format2, args)
          }
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 =
            ReactSharedInternals.ReactDebugCurrentFrame
          var stack = ReactDebugCurrentFrame2.getStackAddendum()
          if (stack !== '') {
            format2 += '%s'
            args = args.concat([stack])
          }
          var argsWithFormat = args.map(function (item) {
            return String(item)
          })
          argsWithFormat.unshift('Warning: ' + format2)
          Function.prototype.apply.call(console[level], console, argsWithFormat)
        }
      }
      function scheduleWork(callback) {
        callback()
      }
      var VIEW_SIZE = 512
      var currentView = null
      var writtenBytes = 0
      function beginWriting(destination) {
        currentView = new Uint8Array(VIEW_SIZE)
        writtenBytes = 0
      }
      function writeChunk(destination, chunk) {
        if (chunk.length === 0) {
          return
        }
        if (chunk.length > VIEW_SIZE) {
          if (writtenBytes > 0) {
            destination.enqueue(
              new Uint8Array(currentView.buffer, 0, writtenBytes),
            )
            currentView = new Uint8Array(VIEW_SIZE)
            writtenBytes = 0
          }
          destination.enqueue(chunk)
          return
        }
        var bytesToWrite = chunk
        var allowableBytes = currentView.length - writtenBytes
        if (allowableBytes < bytesToWrite.length) {
          if (allowableBytes === 0) {
            destination.enqueue(currentView)
          } else {
            currentView.set(
              bytesToWrite.subarray(0, allowableBytes),
              writtenBytes,
            )
            destination.enqueue(currentView)
            bytesToWrite = bytesToWrite.subarray(allowableBytes)
          }
          currentView = new Uint8Array(VIEW_SIZE)
          writtenBytes = 0
        }
        currentView.set(bytesToWrite, writtenBytes)
        writtenBytes += bytesToWrite.length
      }
      function writeChunkAndReturn(destination, chunk) {
        writeChunk(destination, chunk)
        return true
      }
      function completeWriting(destination) {
        if (currentView && writtenBytes > 0) {
          destination.enqueue(
            new Uint8Array(currentView.buffer, 0, writtenBytes),
          )
          currentView = null
          writtenBytes = 0
        }
      }
      function close(destination) {
        destination.close()
      }
      var textEncoder = new TextEncoder()
      function stringToChunk(content) {
        return textEncoder.encode(content)
      }
      function stringToPrecomputedChunk(content) {
        return textEncoder.encode(content)
      }
      function closeWithError(destination, error2) {
        if (typeof destination.error === 'function') {
          destination.error(error2)
        } else {
          destination.close()
        }
      }
      function typeName(value) {
        {
          var hasToStringTag =
            typeof Symbol === 'function' && Symbol.toStringTag
          var type =
            (hasToStringTag && value[Symbol.toStringTag]) ||
            value.constructor.name ||
            'Object'
          return type
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value)
            return false
          } catch (e) {
            return true
          }
        }
      }
      function testStringCoercion(value) {
        return '' + value
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error(
              'The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.',
              attributeName,
              typeName(value),
            )
            return testStringCoercion(value)
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error(
              'The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.',
              propName,
              typeName(value),
            )
            return testStringCoercion(value)
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error(
              'The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.',
              typeName(value),
            )
            return testStringCoercion(value)
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty
      var RESERVED = 0
      var STRING = 1
      var BOOLEANISH_STRING = 2
      var BOOLEAN = 3
      var OVERLOADED_BOOLEAN = 4
      var NUMERIC = 5
      var POSITIVE_NUMERIC = 6
      var ATTRIBUTE_NAME_START_CHAR =
        ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD'
      var ATTRIBUTE_NAME_CHAR =
        ATTRIBUTE_NAME_START_CHAR +
        '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040'
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(
        '^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$',
      )
      var illegalAttributeNameCache = {}
      var validatedAttributeNameCache = {}
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true
          return true
        }
        illegalAttributeNameCache[attributeName] = true
        {
          error('Invalid attribute name: `%s`', attributeName)
        }
        return false
      }
      function shouldRemoveAttributeWithWarning(
        name,
        value,
        propertyInfo,
        isCustomComponentTag,
      ) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false
        }
        switch (typeof value) {
          case 'function':
          // $FlowIssue symbol is perfectly valid here
          case 'symbol':
            return true
          case 'boolean': {
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5)
              return prefix2 !== 'data-' && prefix2 !== 'aria-'
            }
          }
          default:
            return false
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null
      }
      function PropertyInfoRecord(
        name,
        type,
        mustUseProperty,
        attributeName,
        attributeNamespace,
        sanitizeURL2,
        removeEmptyString,
      ) {
        this.acceptsBooleans =
          type === BOOLEANISH_STRING ||
          type === BOOLEAN ||
          type === OVERLOADED_BOOLEAN
        this.attributeName = attributeName
        this.attributeNamespace = attributeNamespace
        this.mustUseProperty = mustUseProperty
        this.propertyName = name
        this.type = type
        this.sanitizeURL = sanitizeURL2
        this.removeEmptyString = removeEmptyString
      }
      var properties = {}
      var reservedProps = [
        'children',
        'dangerouslySetInnerHTML',
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        'defaultValue',
        'defaultChecked',
        'innerHTML',
        'suppressContentEditableWarning',
        'suppressHydrationWarning',
        'style',
      ]
      reservedProps.forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        ['acceptCharset', 'accept-charset'],
        ['className', 'class'],
        ['htmlFor', 'for'],
        ['httpEquiv', 'http-equiv'],
      ].forEach(function (_ref) {
        var name = _ref[0],
          attributeName = _ref[1]
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(
        function (name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false,
          )
        },
      )
      ;[
        'autoReverse',
        'externalResourcesRequired',
        'focusable',
        'preserveAlpha',
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'allowFullScreen',
        'async',
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        'autoFocus',
        'autoPlay',
        'controls',
        'default',
        'defer',
        'disabled',
        'disablePictureInPicture',
        'disableRemotePlayback',
        'formNoValidate',
        'hidden',
        'loop',
        'noModule',
        'noValidate',
        'open',
        'playsInline',
        'readOnly',
        'required',
        'reversed',
        'scoped',
        'seamless',
        // Microdata
        'itemScope',
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'checked',
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        'multiple',
        'muted',
        'selected',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          true,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'capture',
        'download',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'cols',
        'rows',
        'size',
        'span',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;['rowSpan', 'start'].forEach(function (name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      var CAMELIZE = /[\-\:]([a-z])/g
      var capitalize = function (token) {
        return token[1].toUpperCase()
      }
      ;[
        'accent-height',
        'alignment-baseline',
        'arabic-form',
        'baseline-shift',
        'cap-height',
        'clip-path',
        'clip-rule',
        'color-interpolation',
        'color-interpolation-filters',
        'color-profile',
        'color-rendering',
        'dominant-baseline',
        'enable-background',
        'fill-opacity',
        'fill-rule',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'glyph-name',
        'glyph-orientation-horizontal',
        'glyph-orientation-vertical',
        'horiz-adv-x',
        'horiz-origin-x',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'overline-position',
        'overline-thickness',
        'paint-order',
        'panose-1',
        'pointer-events',
        'rendering-intent',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'strikethrough-position',
        'strikethrough-thickness',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-rendering',
        'underline-position',
        'underline-thickness',
        'unicode-bidi',
        'unicode-range',
        'units-per-em',
        'v-alphabetic',
        'v-hanging',
        'v-ideographic',
        'v-mathematical',
        'vector-effect',
        'vert-adv-y',
        'vert-origin-x',
        'vert-origin-y',
        'word-spacing',
        'writing-mode',
        'xmlns:xlink',
        'x-height',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize)
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'xlink:actuate',
        'xlink:arcrole',
        'xlink:role',
        'xlink:show',
        'xlink:title',
        'xlink:type',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize)
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          'http://www.w3.org/1999/xlink',
          false,
          // sanitizeURL
          false,
        )
      })
      ;[
        'xml:base',
        'xml:lang',
        'xml:space',
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function (attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize)
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          'http://www.w3.org/XML/1998/namespace',
          false,
          // sanitizeURL
          false,
        )
      })
      ;['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false,
        )
      })
      var xlinkHref = 'xlinkHref'
      properties[xlinkHref] = new PropertyInfoRecord(
        'xlinkHref',
        STRING,
        false,
        // mustUseProperty
        'xlink:href',
        'http://www.w3.org/1999/xlink',
        true,
        // sanitizeURL
        false,
      )
      ;['src', 'href', 'action', 'formAction'].forEach(
        function (attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true,
          )
        },
      )
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true,
      }
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1)
      }
      var prefixes = ['Webkit', 'ms', 'Moz', 'O']
      Object.keys(isUnitlessNumber).forEach(function (prop) {
        prefixes.forEach(function (prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop]
        })
      })
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true,
      }
      function checkControlledValueProps(tagName, props) {
        {
          if (
            !(
              hasReadOnlyValue[props.type] ||
              props.onChange ||
              props.onInput ||
              props.readOnly ||
              props.disabled ||
              props.value == null
            )
          ) {
            error(
              'You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.',
            )
          }
          if (
            !(
              props.onChange ||
              props.readOnly ||
              props.disabled ||
              props.checked == null
            )
          ) {
            error(
              'You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.',
            )
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf('-') === -1) {
          return typeof props.is === 'string'
        }
        switch (tagName) {
          // These are reserved SVG and MathML elements.
          // We don't mind this list too much because we expect it to never grow.
          // The alternative is to track the namespace in a few places which is convoluted.
          // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
          case 'annotation-xml':
          case 'color-profile':
          case 'font-face':
          case 'font-face-src':
          case 'font-face-uri':
          case 'font-face-format':
          case 'font-face-name':
          case 'missing-glyph':
            return false
          default:
            return true
        }
      }
      var ariaProperties = {
        'aria-current': 0,
        // state
        'aria-description': 0,
        'aria-details': 0,
        'aria-disabled': 0,
        // state
        'aria-hidden': 0,
        // state
        'aria-invalid': 0,
        // state
        'aria-keyshortcuts': 0,
        'aria-label': 0,
        'aria-roledescription': 0,
        // Widget Attributes
        'aria-autocomplete': 0,
        'aria-checked': 0,
        'aria-expanded': 0,
        'aria-haspopup': 0,
        'aria-level': 0,
        'aria-modal': 0,
        'aria-multiline': 0,
        'aria-multiselectable': 0,
        'aria-orientation': 0,
        'aria-placeholder': 0,
        'aria-pressed': 0,
        'aria-readonly': 0,
        'aria-required': 0,
        'aria-selected': 0,
        'aria-sort': 0,
        'aria-valuemax': 0,
        'aria-valuemin': 0,
        'aria-valuenow': 0,
        'aria-valuetext': 0,
        // Live Region Attributes
        'aria-atomic': 0,
        'aria-busy': 0,
        'aria-live': 0,
        'aria-relevant': 0,
        // Drag-and-Drop Attributes
        'aria-dropeffect': 0,
        'aria-grabbed': 0,
        // Relationship Attributes
        'aria-activedescendant': 0,
        'aria-colcount': 0,
        'aria-colindex': 0,
        'aria-colspan': 0,
        'aria-controls': 0,
        'aria-describedby': 0,
        'aria-errormessage': 0,
        'aria-flowto': 0,
        'aria-labelledby': 0,
        'aria-owns': 0,
        'aria-posinset': 0,
        'aria-rowcount': 0,
        'aria-rowindex': 0,
        'aria-rowspan': 0,
        'aria-setsize': 0,
      }
      var warnedProperties = {}
      var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$')
      var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$')
      function validateProperty(tagName, name) {
        {
          if (
            hasOwnProperty.call(warnedProperties, name) &&
            warnedProperties[name]
          ) {
            return true
          }
          if (rARIACamel.test(name)) {
            var ariaName = 'aria-' + name.slice(4).toLowerCase()
            var correctName = ariaProperties.hasOwnProperty(ariaName)
              ? ariaName
              : null
            if (correctName == null) {
              error(
                'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',
                name,
              )
              warnedProperties[name] = true
              return true
            }
            if (name !== correctName) {
              error(
                'Invalid ARIA attribute `%s`. Did you mean `%s`?',
                name,
                correctName,
              )
              warnedProperties[name] = true
              return true
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase()
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName)
              ? lowerCasedName
              : null
            if (standardName == null) {
              warnedProperties[name] = true
              return false
            }
            if (name !== standardName) {
              error(
                'Unknown ARIA attribute `%s`. Did you mean `%s`?',
                name,
                standardName,
              )
              warnedProperties[name] = true
              return true
            }
          }
        }
        return true
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = []
          for (var key in props) {
            var isValid2 = validateProperty(type, key)
            if (!isValid2) {
              invalidProps.push(key)
            }
          }
          var unknownPropString = invalidProps
            .map(function (prop) {
              return '`' + prop + '`'
            })
            .join(', ')
          if (invalidProps.length === 1) {
            error(
              'Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
              unknownPropString,
              type,
            )
          } else if (invalidProps.length > 1) {
            error(
              'Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props',
              unknownPropString,
              type,
            )
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return
        }
        warnInvalidARIAProps(type, props)
      }
      var didWarnValueNull = false
      function validateProperties$1(type, props) {
        {
          if (type !== 'input' && type !== 'textarea' && type !== 'select') {
            return
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true
            if (type === 'select' && props.multiple) {
              error(
                '`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.',
                type,
              )
            } else {
              error(
                '`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.',
                type,
              )
            }
          }
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: 'accept',
        acceptcharset: 'acceptCharset',
        'accept-charset': 'acceptCharset',
        accesskey: 'accessKey',
        action: 'action',
        allowfullscreen: 'allowFullScreen',
        alt: 'alt',
        as: 'as',
        async: 'async',
        autocapitalize: 'autoCapitalize',
        autocomplete: 'autoComplete',
        autocorrect: 'autoCorrect',
        autofocus: 'autoFocus',
        autoplay: 'autoPlay',
        autosave: 'autoSave',
        capture: 'capture',
        cellpadding: 'cellPadding',
        cellspacing: 'cellSpacing',
        challenge: 'challenge',
        charset: 'charSet',
        checked: 'checked',
        children: 'children',
        cite: 'cite',
        class: 'className',
        classid: 'classID',
        classname: 'className',
        cols: 'cols',
        colspan: 'colSpan',
        content: 'content',
        contenteditable: 'contentEditable',
        contextmenu: 'contextMenu',
        controls: 'controls',
        controlslist: 'controlsList',
        coords: 'coords',
        crossorigin: 'crossOrigin',
        dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
        data: 'data',
        datetime: 'dateTime',
        default: 'default',
        defaultchecked: 'defaultChecked',
        defaultvalue: 'defaultValue',
        defer: 'defer',
        dir: 'dir',
        disabled: 'disabled',
        disablepictureinpicture: 'disablePictureInPicture',
        disableremoteplayback: 'disableRemotePlayback',
        download: 'download',
        draggable: 'draggable',
        enctype: 'encType',
        enterkeyhint: 'enterKeyHint',
        for: 'htmlFor',
        form: 'form',
        formmethod: 'formMethod',
        formaction: 'formAction',
        formenctype: 'formEncType',
        formnovalidate: 'formNoValidate',
        formtarget: 'formTarget',
        frameborder: 'frameBorder',
        headers: 'headers',
        height: 'height',
        hidden: 'hidden',
        high: 'high',
        href: 'href',
        hreflang: 'hrefLang',
        htmlfor: 'htmlFor',
        httpequiv: 'httpEquiv',
        'http-equiv': 'httpEquiv',
        icon: 'icon',
        id: 'id',
        imagesizes: 'imageSizes',
        imagesrcset: 'imageSrcSet',
        innerhtml: 'innerHTML',
        inputmode: 'inputMode',
        integrity: 'integrity',
        is: 'is',
        itemid: 'itemID',
        itemprop: 'itemProp',
        itemref: 'itemRef',
        itemscope: 'itemScope',
        itemtype: 'itemType',
        keyparams: 'keyParams',
        keytype: 'keyType',
        kind: 'kind',
        label: 'label',
        lang: 'lang',
        list: 'list',
        loop: 'loop',
        low: 'low',
        manifest: 'manifest',
        marginwidth: 'marginWidth',
        marginheight: 'marginHeight',
        max: 'max',
        maxlength: 'maxLength',
        media: 'media',
        mediagroup: 'mediaGroup',
        method: 'method',
        min: 'min',
        minlength: 'minLength',
        multiple: 'multiple',
        muted: 'muted',
        name: 'name',
        nomodule: 'noModule',
        nonce: 'nonce',
        novalidate: 'noValidate',
        open: 'open',
        optimum: 'optimum',
        pattern: 'pattern',
        placeholder: 'placeholder',
        playsinline: 'playsInline',
        poster: 'poster',
        preload: 'preload',
        profile: 'profile',
        radiogroup: 'radioGroup',
        readonly: 'readOnly',
        referrerpolicy: 'referrerPolicy',
        rel: 'rel',
        required: 'required',
        reversed: 'reversed',
        role: 'role',
        rows: 'rows',
        rowspan: 'rowSpan',
        sandbox: 'sandbox',
        scope: 'scope',
        scoped: 'scoped',
        scrolling: 'scrolling',
        seamless: 'seamless',
        selected: 'selected',
        shape: 'shape',
        size: 'size',
        sizes: 'sizes',
        span: 'span',
        spellcheck: 'spellCheck',
        src: 'src',
        srcdoc: 'srcDoc',
        srclang: 'srcLang',
        srcset: 'srcSet',
        start: 'start',
        step: 'step',
        style: 'style',
        summary: 'summary',
        tabindex: 'tabIndex',
        target: 'target',
        title: 'title',
        type: 'type',
        usemap: 'useMap',
        value: 'value',
        width: 'width',
        wmode: 'wmode',
        wrap: 'wrap',
        // SVG
        about: 'about',
        accentheight: 'accentHeight',
        'accent-height': 'accentHeight',
        accumulate: 'accumulate',
        additive: 'additive',
        alignmentbaseline: 'alignmentBaseline',
        'alignment-baseline': 'alignmentBaseline',
        allowreorder: 'allowReorder',
        alphabetic: 'alphabetic',
        amplitude: 'amplitude',
        arabicform: 'arabicForm',
        'arabic-form': 'arabicForm',
        ascent: 'ascent',
        attributename: 'attributeName',
        attributetype: 'attributeType',
        autoreverse: 'autoReverse',
        azimuth: 'azimuth',
        basefrequency: 'baseFrequency',
        baselineshift: 'baselineShift',
        'baseline-shift': 'baselineShift',
        baseprofile: 'baseProfile',
        bbox: 'bbox',
        begin: 'begin',
        bias: 'bias',
        by: 'by',
        calcmode: 'calcMode',
        capheight: 'capHeight',
        'cap-height': 'capHeight',
        clip: 'clip',
        clippath: 'clipPath',
        'clip-path': 'clipPath',
        clippathunits: 'clipPathUnits',
        cliprule: 'clipRule',
        'clip-rule': 'clipRule',
        color: 'color',
        colorinterpolation: 'colorInterpolation',
        'color-interpolation': 'colorInterpolation',
        colorinterpolationfilters: 'colorInterpolationFilters',
        'color-interpolation-filters': 'colorInterpolationFilters',
        colorprofile: 'colorProfile',
        'color-profile': 'colorProfile',
        colorrendering: 'colorRendering',
        'color-rendering': 'colorRendering',
        contentscripttype: 'contentScriptType',
        contentstyletype: 'contentStyleType',
        cursor: 'cursor',
        cx: 'cx',
        cy: 'cy',
        d: 'd',
        datatype: 'datatype',
        decelerate: 'decelerate',
        descent: 'descent',
        diffuseconstant: 'diffuseConstant',
        direction: 'direction',
        display: 'display',
        divisor: 'divisor',
        dominantbaseline: 'dominantBaseline',
        'dominant-baseline': 'dominantBaseline',
        dur: 'dur',
        dx: 'dx',
        dy: 'dy',
        edgemode: 'edgeMode',
        elevation: 'elevation',
        enablebackground: 'enableBackground',
        'enable-background': 'enableBackground',
        end: 'end',
        exponent: 'exponent',
        externalresourcesrequired: 'externalResourcesRequired',
        fill: 'fill',
        fillopacity: 'fillOpacity',
        'fill-opacity': 'fillOpacity',
        fillrule: 'fillRule',
        'fill-rule': 'fillRule',
        filter: 'filter',
        filterres: 'filterRes',
        filterunits: 'filterUnits',
        floodopacity: 'floodOpacity',
        'flood-opacity': 'floodOpacity',
        floodcolor: 'floodColor',
        'flood-color': 'floodColor',
        focusable: 'focusable',
        fontfamily: 'fontFamily',
        'font-family': 'fontFamily',
        fontsize: 'fontSize',
        'font-size': 'fontSize',
        fontsizeadjust: 'fontSizeAdjust',
        'font-size-adjust': 'fontSizeAdjust',
        fontstretch: 'fontStretch',
        'font-stretch': 'fontStretch',
        fontstyle: 'fontStyle',
        'font-style': 'fontStyle',
        fontvariant: 'fontVariant',
        'font-variant': 'fontVariant',
        fontweight: 'fontWeight',
        'font-weight': 'fontWeight',
        format: 'format',
        from: 'from',
        fx: 'fx',
        fy: 'fy',
        g1: 'g1',
        g2: 'g2',
        glyphname: 'glyphName',
        'glyph-name': 'glyphName',
        glyphorientationhorizontal: 'glyphOrientationHorizontal',
        'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
        glyphorientationvertical: 'glyphOrientationVertical',
        'glyph-orientation-vertical': 'glyphOrientationVertical',
        glyphref: 'glyphRef',
        gradienttransform: 'gradientTransform',
        gradientunits: 'gradientUnits',
        hanging: 'hanging',
        horizadvx: 'horizAdvX',
        'horiz-adv-x': 'horizAdvX',
        horizoriginx: 'horizOriginX',
        'horiz-origin-x': 'horizOriginX',
        ideographic: 'ideographic',
        imagerendering: 'imageRendering',
        'image-rendering': 'imageRendering',
        in2: 'in2',
        in: 'in',
        inlist: 'inlist',
        intercept: 'intercept',
        k1: 'k1',
        k2: 'k2',
        k3: 'k3',
        k4: 'k4',
        k: 'k',
        kernelmatrix: 'kernelMatrix',
        kernelunitlength: 'kernelUnitLength',
        kerning: 'kerning',
        keypoints: 'keyPoints',
        keysplines: 'keySplines',
        keytimes: 'keyTimes',
        lengthadjust: 'lengthAdjust',
        letterspacing: 'letterSpacing',
        'letter-spacing': 'letterSpacing',
        lightingcolor: 'lightingColor',
        'lighting-color': 'lightingColor',
        limitingconeangle: 'limitingConeAngle',
        local: 'local',
        markerend: 'markerEnd',
        'marker-end': 'markerEnd',
        markerheight: 'markerHeight',
        markermid: 'markerMid',
        'marker-mid': 'markerMid',
        markerstart: 'markerStart',
        'marker-start': 'markerStart',
        markerunits: 'markerUnits',
        markerwidth: 'markerWidth',
        mask: 'mask',
        maskcontentunits: 'maskContentUnits',
        maskunits: 'maskUnits',
        mathematical: 'mathematical',
        mode: 'mode',
        numoctaves: 'numOctaves',
        offset: 'offset',
        opacity: 'opacity',
        operator: 'operator',
        order: 'order',
        orient: 'orient',
        orientation: 'orientation',
        origin: 'origin',
        overflow: 'overflow',
        overlineposition: 'overlinePosition',
        'overline-position': 'overlinePosition',
        overlinethickness: 'overlineThickness',
        'overline-thickness': 'overlineThickness',
        paintorder: 'paintOrder',
        'paint-order': 'paintOrder',
        panose1: 'panose1',
        'panose-1': 'panose1',
        pathlength: 'pathLength',
        patterncontentunits: 'patternContentUnits',
        patterntransform: 'patternTransform',
        patternunits: 'patternUnits',
        pointerevents: 'pointerEvents',
        'pointer-events': 'pointerEvents',
        points: 'points',
        pointsatx: 'pointsAtX',
        pointsaty: 'pointsAtY',
        pointsatz: 'pointsAtZ',
        prefix: 'prefix',
        preservealpha: 'preserveAlpha',
        preserveaspectratio: 'preserveAspectRatio',
        primitiveunits: 'primitiveUnits',
        property: 'property',
        r: 'r',
        radius: 'radius',
        refx: 'refX',
        refy: 'refY',
        renderingintent: 'renderingIntent',
        'rendering-intent': 'renderingIntent',
        repeatcount: 'repeatCount',
        repeatdur: 'repeatDur',
        requiredextensions: 'requiredExtensions',
        requiredfeatures: 'requiredFeatures',
        resource: 'resource',
        restart: 'restart',
        result: 'result',
        results: 'results',
        rotate: 'rotate',
        rx: 'rx',
        ry: 'ry',
        scale: 'scale',
        security: 'security',
        seed: 'seed',
        shaperendering: 'shapeRendering',
        'shape-rendering': 'shapeRendering',
        slope: 'slope',
        spacing: 'spacing',
        specularconstant: 'specularConstant',
        specularexponent: 'specularExponent',
        speed: 'speed',
        spreadmethod: 'spreadMethod',
        startoffset: 'startOffset',
        stddeviation: 'stdDeviation',
        stemh: 'stemh',
        stemv: 'stemv',
        stitchtiles: 'stitchTiles',
        stopcolor: 'stopColor',
        'stop-color': 'stopColor',
        stopopacity: 'stopOpacity',
        'stop-opacity': 'stopOpacity',
        strikethroughposition: 'strikethroughPosition',
        'strikethrough-position': 'strikethroughPosition',
        strikethroughthickness: 'strikethroughThickness',
        'strikethrough-thickness': 'strikethroughThickness',
        string: 'string',
        stroke: 'stroke',
        strokedasharray: 'strokeDasharray',
        'stroke-dasharray': 'strokeDasharray',
        strokedashoffset: 'strokeDashoffset',
        'stroke-dashoffset': 'strokeDashoffset',
        strokelinecap: 'strokeLinecap',
        'stroke-linecap': 'strokeLinecap',
        strokelinejoin: 'strokeLinejoin',
        'stroke-linejoin': 'strokeLinejoin',
        strokemiterlimit: 'strokeMiterlimit',
        'stroke-miterlimit': 'strokeMiterlimit',
        strokewidth: 'strokeWidth',
        'stroke-width': 'strokeWidth',
        strokeopacity: 'strokeOpacity',
        'stroke-opacity': 'strokeOpacity',
        suppresscontenteditablewarning: 'suppressContentEditableWarning',
        suppresshydrationwarning: 'suppressHydrationWarning',
        surfacescale: 'surfaceScale',
        systemlanguage: 'systemLanguage',
        tablevalues: 'tableValues',
        targetx: 'targetX',
        targety: 'targetY',
        textanchor: 'textAnchor',
        'text-anchor': 'textAnchor',
        textdecoration: 'textDecoration',
        'text-decoration': 'textDecoration',
        textlength: 'textLength',
        textrendering: 'textRendering',
        'text-rendering': 'textRendering',
        to: 'to',
        transform: 'transform',
        typeof: 'typeof',
        u1: 'u1',
        u2: 'u2',
        underlineposition: 'underlinePosition',
        'underline-position': 'underlinePosition',
        underlinethickness: 'underlineThickness',
        'underline-thickness': 'underlineThickness',
        unicode: 'unicode',
        unicodebidi: 'unicodeBidi',
        'unicode-bidi': 'unicodeBidi',
        unicoderange: 'unicodeRange',
        'unicode-range': 'unicodeRange',
        unitsperem: 'unitsPerEm',
        'units-per-em': 'unitsPerEm',
        unselectable: 'unselectable',
        valphabetic: 'vAlphabetic',
        'v-alphabetic': 'vAlphabetic',
        values: 'values',
        vectoreffect: 'vectorEffect',
        'vector-effect': 'vectorEffect',
        version: 'version',
        vertadvy: 'vertAdvY',
        'vert-adv-y': 'vertAdvY',
        vertoriginx: 'vertOriginX',
        'vert-origin-x': 'vertOriginX',
        vertoriginy: 'vertOriginY',
        'vert-origin-y': 'vertOriginY',
        vhanging: 'vHanging',
        'v-hanging': 'vHanging',
        videographic: 'vIdeographic',
        'v-ideographic': 'vIdeographic',
        viewbox: 'viewBox',
        viewtarget: 'viewTarget',
        visibility: 'visibility',
        vmathematical: 'vMathematical',
        'v-mathematical': 'vMathematical',
        vocab: 'vocab',
        widths: 'widths',
        wordspacing: 'wordSpacing',
        'word-spacing': 'wordSpacing',
        writingmode: 'writingMode',
        'writing-mode': 'writingMode',
        x1: 'x1',
        x2: 'x2',
        x: 'x',
        xchannelselector: 'xChannelSelector',
        xheight: 'xHeight',
        'x-height': 'xHeight',
        xlinkactuate: 'xlinkActuate',
        'xlink:actuate': 'xlinkActuate',
        xlinkarcrole: 'xlinkArcrole',
        'xlink:arcrole': 'xlinkArcrole',
        xlinkhref: 'xlinkHref',
        'xlink:href': 'xlinkHref',
        xlinkrole: 'xlinkRole',
        'xlink:role': 'xlinkRole',
        xlinkshow: 'xlinkShow',
        'xlink:show': 'xlinkShow',
        xlinktitle: 'xlinkTitle',
        'xlink:title': 'xlinkTitle',
        xlinktype: 'xlinkType',
        'xlink:type': 'xlinkType',
        xmlbase: 'xmlBase',
        'xml:base': 'xmlBase',
        xmllang: 'xmlLang',
        'xml:lang': 'xmlLang',
        xmlns: 'xmlns',
        'xml:space': 'xmlSpace',
        xmlnsxlink: 'xmlnsXlink',
        'xmlns:xlink': 'xmlnsXlink',
        xmlspace: 'xmlSpace',
        y1: 'y1',
        y2: 'y2',
        y: 'y',
        ychannelselector: 'yChannelSelector',
        z: 'z',
        zoomandpan: 'zoomAndPan',
      }
      var validateProperty$1 = function () {}
      {
        var warnedProperties$1 = {}
        var EVENT_NAME_REGEX = /^on./
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/
        var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$')
        var rARIACamel$1 = new RegExp(
          '^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$',
        )
        validateProperty$1 = function (tagName, name, value, eventRegistry) {
          if (
            hasOwnProperty.call(warnedProperties$1, name) &&
            warnedProperties$1[name]
          ) {
            return true
          }
          var lowerCasedName = name.toLowerCase()
          if (
            lowerCasedName === 'onfocusin' ||
            lowerCasedName === 'onfocusout'
          ) {
            error(
              'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.',
            )
            warnedProperties$1[name] = true
            return true
          }
          if (eventRegistry != null) {
            var registrationNameDependencies =
                eventRegistry.registrationNameDependencies,
              possibleRegistrationNames =
                eventRegistry.possibleRegistrationNames
            if (registrationNameDependencies.hasOwnProperty(name)) {
              return true
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(
              lowerCasedName,
            )
              ? possibleRegistrationNames[lowerCasedName]
              : null
            if (registrationName != null) {
              error(
                'Invalid event handler property `%s`. Did you mean `%s`?',
                name,
                registrationName,
              )
              warnedProperties$1[name] = true
              return true
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error(
                'Unknown event handler property `%s`. It will be ignored.',
                name,
              )
              warnedProperties$1[name] = true
              return true
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error(
                'Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.',
                name,
              )
            }
            warnedProperties$1[name] = true
            return true
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true
          }
          if (lowerCasedName === 'innerhtml') {
            error(
              'Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.',
            )
            warnedProperties$1[name] = true
            return true
          }
          if (lowerCasedName === 'aria') {
            error(
              'The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.',
            )
            warnedProperties$1[name] = true
            return true
          }
          if (
            lowerCasedName === 'is' &&
            value !== null &&
            value !== void 0 &&
            typeof value !== 'string'
          ) {
            error(
              'Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.',
              typeof value,
            )
            warnedProperties$1[name] = true
            return true
          }
          if (typeof value === 'number' && isNaN(value)) {
            error(
              'Received NaN for the `%s` attribute. If this is expected, cast the value to a string.',
              name,
            )
            warnedProperties$1[name] = true
            return true
          }
          var propertyInfo = getPropertyInfo(name)
          var isReserved =
            propertyInfo !== null && propertyInfo.type === RESERVED
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName]
            if (standardName !== name) {
              error(
                'Invalid DOM property `%s`. Did you mean `%s`?',
                name,
                standardName,
              )
              warnedProperties$1[name] = true
              return true
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error(
              'React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.',
              name,
              lowerCasedName,
            )
            warnedProperties$1[name] = true
            return true
          }
          if (
            typeof value === 'boolean' &&
            shouldRemoveAttributeWithWarning(name, value, propertyInfo)
          ) {
            if (value) {
              error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                value,
                name,
                name,
                value,
                name,
              )
            } else {
              error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                value,
                name,
                name,
                value,
                name,
                name,
                name,
              )
            }
            warnedProperties$1[name] = true
            return true
          }
          if (isReserved) {
            return true
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo)) {
            warnedProperties$1[name] = true
            return false
          }
          if (
            (value === 'false' || value === 'true') &&
            propertyInfo !== null &&
            propertyInfo.type === BOOLEAN
          ) {
            error(
              'Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?',
              value,
              name,
              value === 'false'
                ? 'The browser will interpret it as a truthy value.'
                : 'Although this works, it will not work as expected if you pass the string "false".',
              name,
              value,
            )
            warnedProperties$1[name] = true
            return true
          }
          return true
        }
      }
      var warnUnknownProperties = function (type, props, eventRegistry) {
        {
          var unknownProps = []
          for (var key in props) {
            var isValid2 = validateProperty$1(
              type,
              key,
              props[key],
              eventRegistry,
            )
            if (!isValid2) {
              unknownProps.push(key)
            }
          }
          var unknownPropString = unknownProps
            .map(function (prop) {
              return '`' + prop + '`'
            })
            .join(', ')
          if (unknownProps.length === 1) {
            error(
              'Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
              unknownPropString,
              type,
            )
          } else if (unknownProps.length > 1) {
            error(
              'Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ',
              unknownPropString,
              type,
            )
          }
        }
      }
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return
        }
        warnUnknownProperties(type, props, eventRegistry)
      }
      var warnValidStyle = function () {}
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/
        var msPattern = /^-ms-/
        var hyphenPattern = /-(.)/g
        var badStyleValueWithSemicolonPattern = /;\s*$/
        var warnedStyleNames = {}
        var warnedStyleValues = {}
        var warnedForNaNValue = false
        var warnedForInfinityValue = false
        var camelize = function (string) {
          return string.replace(hyphenPattern, function (_, character) {
            return character.toUpperCase()
          })
        }
        var warnHyphenatedStyleName = function (name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return
          }
          warnedStyleNames[name] = true
          error(
            'Unsupported style property %s. Did you mean %s?',
            name,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name.replace(msPattern, 'ms-')),
          )
        }
        var warnBadVendoredStyleName = function (name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return
          }
          warnedStyleNames[name] = true
          error(
            'Unsupported vendor-prefixed style property %s. Did you mean %s?',
            name,
            name.charAt(0).toUpperCase() + name.slice(1),
          )
        }
        var warnStyleValueWithSemicolon = function (name, value) {
          if (
            warnedStyleValues.hasOwnProperty(value) &&
            warnedStyleValues[value]
          ) {
            return
          }
          warnedStyleValues[value] = true
          error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            name,
            value.replace(badStyleValueWithSemicolonPattern, ''),
          )
        }
        var warnStyleValueIsNaN = function (name, value) {
          if (warnedForNaNValue) {
            return
          }
          warnedForNaNValue = true
          error(
            '`NaN` is an invalid value for the `%s` css style property.',
            name,
          )
        }
        var warnStyleValueIsInfinity = function (name, value) {
          if (warnedForInfinityValue) {
            return
          }
          warnedForInfinityValue = true
          error(
            '`Infinity` is an invalid value for the `%s` css style property.',
            name,
          )
        }
        warnValidStyle = function (name, value) {
          if (name.indexOf('-') > -1) {
            warnHyphenatedStyleName(name)
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name)
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name, value)
          }
          if (typeof value === 'number') {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name, value)
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name, value)
            }
          }
        }
      }
      var warnValidStyle$1 = warnValidStyle
      var matchHtmlRegExp = /["'&<>]/
      function escapeHtml(string) {
        {
          checkHtmlStringCoercion(string)
        }
        var str = '' + string
        var match2 = matchHtmlRegExp.exec(str)
        if (!match2) {
          return str
        }
        var escape
        var html = ''
        var index
        var lastIndex = 0
        for (index = match2.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape = '&quot;'
              break
            case 38:
              escape = '&amp;'
              break
            case 39:
              escape = '&#x27;'
              break
            case 60:
              escape = '&lt;'
              break
            case 62:
              escape = '&gt;'
              break
            default:
              continue
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index)
          }
          lastIndex = index + 1
          html += escape
        }
        return lastIndex !== index
          ? html + str.substring(lastIndex, index)
          : html
      }
      function escapeTextForBrowser(text) {
        if (typeof text === 'boolean' || typeof text === 'number') {
          return '' + text
        }
        return escapeHtml(text)
      }
      var uppercasePattern = /([A-Z])/g
      var msPattern$1 = /^ms-/
      function hyphenateStyleName(name) {
        return name
          .replace(uppercasePattern, '-$1')
          .toLowerCase()
          .replace(msPattern$1, '-ms-')
      }
      var isJavaScriptProtocol =
        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i
      var didWarn = false
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true
            error(
              'A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.',
              JSON.stringify(url),
            )
          }
        }
      }
      var isArrayImpl = Array.isArray
      function isArray2(a) {
        return isArrayImpl(a)
      }
      var startInlineScript = stringToPrecomputedChunk('<script>')
      var endInlineScript = stringToPrecomputedChunk('</script>')
      var startScriptSrc = stringToPrecomputedChunk('<script src="')
      var startModuleSrc = stringToPrecomputedChunk(
        '<script type="module" src="',
      )
      var endAsyncScript = stringToPrecomputedChunk('" async=""></script>')
      function escapeBootstrapScriptContent(scriptText) {
        {
          checkHtmlStringCoercion(scriptText)
        }
        return ('' + scriptText).replace(scriptRegex, scriptReplacer)
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi
      var scriptReplacer = function (match2, prefix2, s, suffix) {
        return '' + prefix2 + (s === 's' ? '\\u0073' : '\\u0053') + suffix
      }
      function createResponseState(
        identifierPrefix,
        nonce,
        bootstrapScriptContent,
        bootstrapScripts,
        bootstrapModules,
      ) {
        var idPrefix = identifierPrefix === void 0 ? '' : identifierPrefix
        var inlineScriptWithNonce =
          nonce === void 0
            ? startInlineScript
            : stringToPrecomputedChunk(
                '<script nonce="' + escapeTextForBrowser(nonce) + '">',
              )
        var bootstrapChunks = []
        if (bootstrapScriptContent !== void 0) {
          bootstrapChunks.push(
            inlineScriptWithNonce,
            stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)),
            endInlineScript,
          )
        }
        if (bootstrapScripts !== void 0) {
          for (var i = 0; i < bootstrapScripts.length; i++) {
            bootstrapChunks.push(
              startScriptSrc,
              stringToChunk(escapeTextForBrowser(bootstrapScripts[i])),
              endAsyncScript,
            )
          }
        }
        if (bootstrapModules !== void 0) {
          for (var _i = 0; _i < bootstrapModules.length; _i++) {
            bootstrapChunks.push(
              startModuleSrc,
              stringToChunk(escapeTextForBrowser(bootstrapModules[_i])),
              endAsyncScript,
            )
          }
        }
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + 'P:'),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + 'S:'),
          boundaryPrefix: idPrefix + 'B:',
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false,
        }
      }
      var ROOT_HTML_MODE = 0
      var HTML_MODE = 1
      var SVG_MODE = 2
      var MATHML_MODE = 3
      var HTML_TABLE_MODE = 4
      var HTML_TABLE_BODY_MODE = 5
      var HTML_TABLE_ROW_MODE = 6
      var HTML_COLGROUP_MODE = 7
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue,
        }
      }
      function createRootFormatContext(namespaceURI) {
        var insertionMode =
          namespaceURI === 'http://www.w3.org/2000/svg'
            ? SVG_MODE
            : namespaceURI === 'http://www.w3.org/1998/Math/MathML'
            ? MATHML_MODE
            : ROOT_HTML_MODE
        return createFormatContext(insertionMode, null)
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case 'select':
            return createFormatContext(
              HTML_MODE,
              props.value != null ? props.value : props.defaultValue,
            )
          case 'svg':
            return createFormatContext(SVG_MODE, null)
          case 'math':
            return createFormatContext(MATHML_MODE, null)
          case 'foreignObject':
            return createFormatContext(HTML_MODE, null)
          // Table parents are special in that their children can only be created at all if they're
          // wrapped in a table parent. So we need to encode that we're entering this mode.
          case 'table':
            return createFormatContext(HTML_TABLE_MODE, null)
          case 'thead':
          case 'tbody':
          case 'tfoot':
            return createFormatContext(HTML_TABLE_BODY_MODE, null)
          case 'colgroup':
            return createFormatContext(HTML_COLGROUP_MODE, null)
          case 'tr':
            return createFormatContext(HTML_TABLE_ROW_MODE, null)
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null)
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null)
        }
        return parentContext
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++
        return stringToPrecomputedChunk(
          responseState.boundaryPrefix + generatedID.toString(16),
        )
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix
        var id = ':' + idPrefix + 'R' + treeId
        if (localId > 0) {
          id += 'H' + localId.toString(32)
        }
        return id + ':'
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text)
      }
      var textSeparator = stringToPrecomputedChunk('<!-- -->')
      function pushTextInstance(target, text, responseState, textEmbedded) {
        if (text === '') {
          return textEmbedded
        }
        if (textEmbedded) {
          target.push(textSeparator)
        }
        target.push(stringToChunk(encodeHTMLTextNode(text)))
        return true
      }
      function pushSegmentFinale(
        target,
        responseState,
        lastPushedText,
        textEmbedded,
      ) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator)
        }
      }
      var styleNameCache = /* @__PURE__ */ new Map()
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName)
        if (chunk !== void 0) {
          return chunk
        }
        var result = stringToPrecomputedChunk(
          escapeTextForBrowser(hyphenateStyleName(styleName)),
        )
        styleNameCache.set(styleName, result)
        return result
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="')
      var styleAssign = stringToPrecomputedChunk(':')
      var styleSeparator = stringToPrecomputedChunk(';')
      function pushStyle(target, responseState, style) {
        if (typeof style !== 'object') {
          throw new Error(
            "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.",
          )
        }
        var isFirst = true
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue
          }
          var styleValue = style[styleName]
          if (
            styleValue == null ||
            typeof styleValue === 'boolean' ||
            styleValue === ''
          ) {
            continue
          }
          var nameChunk = void 0
          var valueChunk = void 0
          var isCustomProperty = styleName.indexOf('--') === 0
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName))
            {
              checkCSSPropertyStringCoercion(styleValue, styleName)
            }
            valueChunk = stringToChunk(
              escapeTextForBrowser(('' + styleValue).trim()),
            )
          } else {
            {
              warnValidStyle$1(styleName, styleValue)
            }
            nameChunk = processStyleName(styleName)
            if (typeof styleValue === 'number') {
              if (
                styleValue !== 0 &&
                !hasOwnProperty.call(isUnitlessNumber, styleName)
              ) {
                valueChunk = stringToChunk(styleValue + 'px')
              } else {
                valueChunk = stringToChunk('' + styleValue)
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName)
              }
              valueChunk = stringToChunk(
                escapeTextForBrowser(('' + styleValue).trim()),
              )
            }
          }
          if (isFirst) {
            isFirst = false
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk)
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk)
          }
        }
        if (!isFirst) {
          target.push(attributeEnd)
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(' ')
      var attributeAssign = stringToPrecomputedChunk('="')
      var attributeEnd = stringToPrecomputedChunk('"')
      var attributeEmptyString = stringToPrecomputedChunk('=""')
      function pushAttribute(target, responseState, name, value) {
        switch (name) {
          case 'style': {
            pushStyle(target, responseState, value)
            return
          }
          case 'defaultValue':
          case 'defaultChecked':
          // These shouldn't be set as attributes on generic HTML elements.
          case 'innerHTML':
          // Must use dangerouslySetInnerHTML instead.
          case 'suppressContentEditableWarning':
          case 'suppressHydrationWarning':
            return
        }
        if (
          // shouldIgnoreAttribute
          // We have already filtered out null/undefined and reserved words.
          name.length > 2 &&
          (name[0] === 'o' || name[0] === 'O') &&
          (name[1] === 'n' || name[1] === 'N')
        ) {
          return
        }
        var propertyInfo = getPropertyInfo(name)
        if (propertyInfo !== null) {
          switch (typeof value) {
            case 'function':
            // $FlowIssue symbol is perfectly valid here
            case 'symbol':
              return
            case 'boolean': {
              if (!propertyInfo.acceptsBooleans) {
                return
              }
            }
          }
          var attributeName = propertyInfo.attributeName
          var attributeNameChunk = stringToChunk(attributeName)
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value) {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeEmptyString,
                )
              }
              return
            case OVERLOADED_BOOLEAN:
              if (value === true) {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeEmptyString,
                )
              } else if (value === false);
              else {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeAssign,
                  stringToChunk(escapeTextForBrowser(value)),
                  attributeEnd,
                )
              }
              return
            case NUMERIC:
              if (!isNaN(value)) {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeAssign,
                  stringToChunk(escapeTextForBrowser(value)),
                  attributeEnd,
                )
              }
              break
            case POSITIVE_NUMERIC:
              if (!isNaN(value) && value >= 1) {
                target.push(
                  attributeSeparator,
                  attributeNameChunk,
                  attributeAssign,
                  stringToChunk(escapeTextForBrowser(value)),
                  attributeEnd,
                )
              }
              break
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value, attributeName)
                }
                value = '' + value
                sanitizeURL(value)
              }
              target.push(
                attributeSeparator,
                attributeNameChunk,
                attributeAssign,
                stringToChunk(escapeTextForBrowser(value)),
                attributeEnd,
              )
          }
        } else if (isAttributeNameSafe(name)) {
          switch (typeof value) {
            case 'function':
            // $FlowIssue symbol is perfectly valid here
            case 'symbol':
              return
            case 'boolean': {
              var prefix2 = name.toLowerCase().slice(0, 5)
              if (prefix2 !== 'data-' && prefix2 !== 'aria-') {
                return
              }
            }
          }
          target.push(
            attributeSeparator,
            stringToChunk(name),
            attributeAssign,
            stringToChunk(escapeTextForBrowser(value)),
            attributeEnd,
          )
        }
      }
      var endOfStartTag = stringToPrecomputedChunk('>')
      var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>')
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error(
              'Can only set one of `children` or `props.dangerouslySetInnerHTML`.',
            )
          }
          if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) {
            throw new Error(
              '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.',
            )
          }
          var html = innerHTML.__html
          if (html !== null && html !== void 0) {
            {
              checkHtmlStringCoercion(html)
            }
            target.push(stringToChunk('' + html))
          }
        }
      }
      var didWarnDefaultInputValue = false
      var didWarnDefaultChecked = false
      var didWarnDefaultSelectValue = false
      var didWarnDefaultTextareaValue = false
      var didWarnInvalidOptionChildren = false
      var didWarnInvalidOptionInnerHTML = false
      var didWarnSelectedSetOnOption = false
      function checkSelectProp(props, propName) {
        {
          var value = props[propName]
          if (value != null) {
            var array = isArray2(value)
            if (props.multiple && !array) {
              error(
                'The `%s` prop supplied to <select> must be an array if `multiple` is true.',
                propName,
              )
            } else if (!props.multiple && array) {
              error(
                'The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.',
                propName,
              )
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps('select', props)
          checkSelectProp(props, 'value')
          checkSelectProp(props, 'defaultValue')
          if (
            props.value !== void 0 &&
            props.defaultValue !== void 0 &&
            !didWarnDefaultSelectValue
          ) {
            error(
              'Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
            )
            didWarnDefaultSelectValue = true
          }
        }
        target.push(startChunkForTag('select'))
        var children = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              case 'defaultValue':
              case 'value':
                break
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        pushInnerHTML(target, innerHTML, children)
        return children
      }
      function flattenOptionChildren(children) {
        var content = ''
        React2.Children.forEach(children, function (child) {
          if (child == null) {
            return
          }
          content += child
          {
            if (
              !didWarnInvalidOptionChildren &&
              typeof child !== 'string' &&
              typeof child !== 'number'
            ) {
              didWarnInvalidOptionChildren = true
              error(
                'Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.',
              )
            }
          }
        })
        return content
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""')
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue
        target.push(startChunkForTag('option'))
        var children = null
        var value = null
        var selected = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'selected':
                selected = propValue
                {
                  if (!didWarnSelectedSetOnOption) {
                    error(
                      'Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.',
                    )
                    didWarnSelectedSetOnOption = true
                  }
                }
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              // eslint-disable-next-line-no-fallthrough
              case 'value':
                value = propValue
              // We intentionally fallthrough to also set the attribute on the node.
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        if (selectedValue != null) {
          var stringValue
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, 'value')
            }
            stringValue = '' + value
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true
                  error(
                    'Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.',
                  )
                }
              }
            }
            stringValue = flattenOptionChildren(children)
          }
          if (isArray2(selectedValue)) {
            for (var i = 0; i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], 'value')
              }
              var v = '' + selectedValue[i]
              if (v === stringValue) {
                target.push(selectedMarkerAttribute)
                break
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, 'select.value')
            }
            if ('' + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute)
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute)
        }
        target.push(endOfStartTag)
        pushInnerHTML(target, innerHTML, children)
        return children
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps('input', props)
          if (
            props.checked !== void 0 &&
            props.defaultChecked !== void 0 &&
            !didWarnDefaultChecked
          ) {
            error(
              '%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
              'A component',
              props.type,
            )
            didWarnDefaultChecked = true
          }
          if (
            props.value !== void 0 &&
            props.defaultValue !== void 0 &&
            !didWarnDefaultInputValue
          ) {
            error(
              '%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components',
              'A component',
              props.type,
            )
            didWarnDefaultInputValue = true
          }
        }
        target.push(startChunkForTag('input'))
        var value = null
        var defaultValue = null
        var checked = null
        var defaultChecked = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  'input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.',
                )
              // eslint-disable-next-line-no-fallthrough
              case 'defaultChecked':
                defaultChecked = propValue
                break
              case 'defaultValue':
                defaultValue = propValue
                break
              case 'checked':
                checked = propValue
                break
              case 'value':
                value = propValue
                break
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, 'checked', checked)
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, 'checked', defaultChecked)
        }
        if (value !== null) {
          pushAttribute(target, responseState, 'value', value)
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, 'value', defaultValue)
        }
        target.push(endOfStartTagSelfClosing)
        return null
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps('textarea', props)
          if (
            props.value !== void 0 &&
            props.defaultValue !== void 0 &&
            !didWarnDefaultTextareaValue
          ) {
            error(
              'Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components',
            )
            didWarnDefaultTextareaValue = true
          }
        }
        target.push(startChunkForTag('textarea'))
        var value = null
        var defaultValue = null
        var children = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'value':
                value = propValue
                break
              case 'defaultValue':
                defaultValue = propValue
                break
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  '`dangerouslySetInnerHTML` does not make sense on <textarea>.',
                )
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        if (value === null && defaultValue !== null) {
          value = defaultValue
        }
        target.push(endOfStartTag)
        if (children != null) {
          {
            error(
              'Use the `defaultValue` or `value` props instead of setting children on <textarea>.',
            )
          }
          if (value != null) {
            throw new Error(
              'If you supply `defaultValue` on a <textarea>, do not pass children.',
            )
          }
          if (isArray2(children)) {
            if (children.length > 1) {
              throw new Error('<textarea> can only have at most one child.')
            }
            {
              checkHtmlStringCoercion(children[0])
            }
            value = '' + children[0]
          }
          {
            checkHtmlStringCoercion(children)
          }
          value = '' + children
        }
        if (typeof value === 'string' && value[0] === '\n') {
          target.push(leadingNewline)
        }
        if (value !== null) {
          {
            checkAttributeStringCoercion(value, 'value')
          }
          target.push(stringToChunk(encodeHTMLTextNode('' + value)))
        }
        return null
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag))
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  tag +
                    ' is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.',
                )
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTagSelfClosing)
        return null
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag('menuitem'))
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  'menuitems cannot have `children` nor `dangerouslySetInnerHTML`.',
                )
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        return null
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag('title'))
        var children = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                throw new Error(
                  '`dangerouslySetInnerHTML` does not make sense on <title>.',
                )
              // eslint-disable-next-line-no-fallthrough
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        {
          var child =
            Array.isArray(children) && children.length < 2
              ? children[0] || null
              : children
          if (Array.isArray(children) && children.length > 1) {
            error(
              'A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering',
            )
          } else if (child != null && child.$$typeof != null) {
            error(
              'A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering',
            )
          } else if (
            child != null &&
            typeof child !== 'string' &&
            typeof child !== 'number'
          ) {
            error(
              'A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering',
            )
          }
        }
        return children
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag))
        var children = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        pushInnerHTML(target, innerHTML, children)
        if (typeof children === 'string') {
          target.push(stringToChunk(encodeHTMLTextNode(children)))
          return null
        }
        return children
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag))
        var children = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              case 'style':
                pushStyle(target, responseState, propValue)
                break
              case 'suppressContentEditableWarning':
              case 'suppressHydrationWarning':
                break
              default:
                if (
                  isAttributeNameSafe(propKey) &&
                  typeof propValue !== 'function' &&
                  typeof propValue !== 'symbol'
                ) {
                  target.push(
                    attributeSeparator,
                    stringToChunk(propKey),
                    attributeAssign,
                    stringToChunk(escapeTextForBrowser(propValue)),
                    attributeEnd,
                  )
                }
                break
            }
          }
        }
        target.push(endOfStartTag)
        pushInnerHTML(target, innerHTML, children)
        return children
      }
      var leadingNewline = stringToPrecomputedChunk('\n')
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag))
        var children = null
        var innerHTML = null
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey]
            if (propValue == null) {
              continue
            }
            switch (propKey) {
              case 'children':
                children = propValue
                break
              case 'dangerouslySetInnerHTML':
                innerHTML = propValue
                break
              default:
                pushAttribute(target, responseState, propKey, propValue)
                break
            }
          }
        }
        target.push(endOfStartTag)
        if (innerHTML != null) {
          if (children != null) {
            throw new Error(
              'Can only set one of `children` or `props.dangerouslySetInnerHTML`.',
            )
          }
          if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) {
            throw new Error(
              '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.',
            )
          }
          var html = innerHTML.__html
          if (html !== null && html !== void 0) {
            if (
              typeof html === 'string' &&
              html.length > 0 &&
              html[0] === '\n'
            ) {
              target.push(leadingNewline, stringToChunk(html))
            } else {
              {
                checkHtmlStringCoercion(html)
              }
              target.push(stringToChunk('' + html))
            }
          }
        }
        if (typeof children === 'string' && children[0] === '\n') {
          target.push(leadingNewline)
        }
        return children
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/
      var validatedTagCache = /* @__PURE__ */ new Map()
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag)
        if (tagStartChunk === void 0) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error('Invalid tag: ' + tag)
          }
          tagStartChunk = stringToPrecomputedChunk('<' + tag)
          validatedTagCache.set(tag, tagStartChunk)
        }
        return tagStartChunk
      }
      var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>')
      function pushStartInstance(
        target,
        type,
        props,
        responseState,
        formatContext,
      ) {
        {
          validateProperties(type, props)
          validateProperties$1(type, props)
          validateProperties$2(type, props, null)
          if (
            !props.suppressContentEditableWarning &&
            props.contentEditable &&
            props.children != null
          ) {
            error(
              'A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.',
            )
          }
          if (
            formatContext.insertionMode !== SVG_MODE &&
            formatContext.insertionMode !== MATHML_MODE
          ) {
            if (
              type.indexOf('-') === -1 &&
              typeof props.is !== 'string' &&
              type.toLowerCase() !== type
            ) {
              error(
                '<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.',
                type,
              )
            }
          }
        }
        switch (type) {
          // Special tags
          case 'select':
            return pushStartSelect(target, props, responseState)
          case 'option':
            return pushStartOption(target, props, responseState, formatContext)
          case 'textarea':
            return pushStartTextArea(target, props, responseState)
          case 'input':
            return pushInput(target, props, responseState)
          case 'menuitem':
            return pushStartMenuItem(target, props, responseState)
          case 'title':
            return pushStartTitle(target, props, responseState)
          // Newline eating tags
          case 'listing':
          case 'pre': {
            return pushStartPreformattedElement(
              target,
              props,
              type,
              responseState,
            )
          }
          // Omitted close tags
          case 'area':
          case 'base':
          case 'br':
          case 'col':
          case 'embed':
          case 'hr':
          case 'img':
          case 'keygen':
          case 'link':
          case 'meta':
          case 'param':
          case 'source':
          case 'track':
          case 'wbr': {
            return pushSelfClosing(target, props, type, responseState)
          }
          // These are reserved SVG and MathML elements, that are never custom elements.
          // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
          case 'annotation-xml':
          case 'color-profile':
          case 'font-face':
          case 'font-face-src':
          case 'font-face-uri':
          case 'font-face-format':
          case 'font-face-name':
          case 'missing-glyph': {
            return pushStartGenericElement(target, props, type, responseState)
          }
          case 'html': {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE)
            }
            return pushStartGenericElement(target, props, type, responseState)
          }
          default: {
            if (type.indexOf('-') === -1 && typeof props.is !== 'string') {
              return pushStartGenericElement(target, props, type, responseState)
            } else {
              return pushStartCustomElement(target, props, type, responseState)
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk('</')
      var endTag2 = stringToPrecomputedChunk('>')
      function pushEndInstance(target, type, props) {
        switch (type) {
          // Omitted close tags
          // TODO: Instead of repeating this switch we could try to pass a flag from above.
          // That would require returning a tuple. Which might be ok if it gets inlined.
          case 'area':
          case 'base':
          case 'br':
          case 'col':
          case 'embed':
          case 'hr':
          case 'img':
          case 'input':
          case 'keygen':
          case 'link':
          case 'meta':
          case 'param':
          case 'source':
          case 'track':
          case 'wbr': {
            break
          }
          default: {
            target.push(endTag1, stringToChunk(type), endTag2)
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks
        var i = 0
        for (; i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i])
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i])
        }
        return true
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="')
      var placeholder2 = stringToPrecomputedChunk('"></template>')
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1)
        writeChunk(destination, responseState.placeholderPrefix)
        var formattedID = stringToChunk(id.toString(16))
        writeChunk(destination, formattedID)
        return writeChunkAndReturn(destination, placeholder2)
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->')
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
        '<!--$?--><template id="',
      )
      var startPendingSuspenseBoundary2 =
        stringToPrecomputedChunk('"></template>')
      var startClientRenderedSuspenseBoundary =
        stringToPrecomputedChunk('<!--$!-->')
      var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->')
      var clientRenderedSuspenseBoundaryError1 =
        stringToPrecomputedChunk('<template')
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial =
        stringToPrecomputedChunk('"')
      var clientRenderedSuspenseBoundaryError1A =
        stringToPrecomputedChunk(' data-dgst="')
      var clientRenderedSuspenseBoundaryError1B =
        stringToPrecomputedChunk(' data-msg="')
      var clientRenderedSuspenseBoundaryError1C =
        stringToPrecomputedChunk(' data-stck="')
      var clientRenderedSuspenseBoundaryError2 =
        stringToPrecomputedChunk('></template>')
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary)
      }
      function writeStartPendingSuspenseBoundary(
        destination,
        responseState,
        id,
      ) {
        writeChunk(destination, startPendingSuspenseBoundary1)
        if (id === null) {
          throw new Error(
            'An ID must have been assigned before we can complete the boundary.',
          )
        }
        writeChunk(destination, id)
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2)
      }
      function writeStartClientRenderedSuspenseBoundary(
        destination,
        responseState,
        errorDigest,
        errorMesssage,
        errorComponentStack,
      ) {
        var result
        result = writeChunkAndReturn(
          destination,
          startClientRenderedSuspenseBoundary,
        )
        writeChunk(destination, clientRenderedSuspenseBoundaryError1)
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A)
          writeChunk(
            destination,
            stringToChunk(escapeTextForBrowser(errorDigest)),
          )
          writeChunk(
            destination,
            clientRenderedSuspenseBoundaryErrorAttrInterstitial,
          )
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B)
            writeChunk(
              destination,
              stringToChunk(escapeTextForBrowser(errorMesssage)),
            )
            writeChunk(
              destination,
              clientRenderedSuspenseBoundaryErrorAttrInterstitial,
            )
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C)
            writeChunk(
              destination,
              stringToChunk(escapeTextForBrowser(errorComponentStack)),
            )
            writeChunk(
              destination,
              clientRenderedSuspenseBoundaryErrorAttrInterstitial,
            )
          }
        }
        result = writeChunkAndReturn(
          destination,
          clientRenderedSuspenseBoundaryError2,
        )
        return result
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary)
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary)
      }
      function writeEndClientRenderedSuspenseBoundary(
        destination,
        responseState,
      ) {
        return writeChunkAndReturn(destination, endSuspenseBoundary)
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="')
      var startSegmentHTML2 = stringToPrecomputedChunk('">')
      var endSegmentHTML = stringToPrecomputedChunk('</div>')
      var startSegmentSVG = stringToPrecomputedChunk(
        '<svg aria-hidden="true" style="display:none" id="',
      )
      var startSegmentSVG2 = stringToPrecomputedChunk('">')
      var endSegmentSVG = stringToPrecomputedChunk('</svg>')
      var startSegmentMathML = stringToPrecomputedChunk(
        '<math aria-hidden="true" style="display:none" id="',
      )
      var startSegmentMathML2 = stringToPrecomputedChunk('">')
      var endSegmentMathML = stringToPrecomputedChunk('</math>')
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="')
      var startSegmentTable2 = stringToPrecomputedChunk('">')
      var endSegmentTable = stringToPrecomputedChunk('</table>')
      var startSegmentTableBody = stringToPrecomputedChunk(
        '<table hidden><tbody id="',
      )
      var startSegmentTableBody2 = stringToPrecomputedChunk('">')
      var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>')
      var startSegmentTableRow = stringToPrecomputedChunk(
        '<table hidden><tr id="',
      )
      var startSegmentTableRow2 = stringToPrecomputedChunk('">')
      var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>')
      var startSegmentColGroup = stringToPrecomputedChunk(
        '<table hidden><colgroup id="',
      )
      var startSegmentColGroup2 = stringToPrecomputedChunk('">')
      var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>')
      function writeStartSegment(
        destination,
        responseState,
        formatContext,
        id,
      ) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentHTML2)
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentSVG2)
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentMathML2)
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentTable2)
          }
          // TODO: For the rest of these, there will be extra wrapper nodes that never
          // get deleted from the document. We need to delete the table too as part
          // of the injected scripts. They are invisible though so it's not too terrible
          // and it's kind of an edge case to suspend in a table. Totally supported though.
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentTableBody2)
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentTableRow2)
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup)
            writeChunk(destination, responseState.segmentPrefix)
            writeChunk(destination, stringToChunk(id.toString(16)))
            return writeChunkAndReturn(destination, startSegmentColGroup2)
          }
          default: {
            throw new Error('Unknown insertion mode. This is a bug in React.')
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML)
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG)
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML)
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable)
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody)
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow)
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup)
          }
          default: {
            throw new Error('Unknown insertion mode. This is a bug in React.')
          }
        }
      }
      var completeSegmentFunction =
        'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}'
      var completeBoundaryFunction =
        'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}'
      var clientRenderFunction =
        'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}'
      var completeSegmentScript1Full = stringToPrecomputedChunk(
        completeSegmentFunction + ';$RS("',
      )
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("')
      var completeSegmentScript2 = stringToPrecomputedChunk('","')
      var completeSegmentScript3 = stringToPrecomputedChunk('")</script>')
      function writeCompletedSegmentInstruction(
        destination,
        responseState,
        contentSegmentID,
      ) {
        writeChunk(destination, responseState.startInlineScript)
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true
          writeChunk(destination, completeSegmentScript1Full)
        } else {
          writeChunk(destination, completeSegmentScript1Partial)
        }
        writeChunk(destination, responseState.segmentPrefix)
        var formattedID = stringToChunk(contentSegmentID.toString(16))
        writeChunk(destination, formattedID)
        writeChunk(destination, completeSegmentScript2)
        writeChunk(destination, responseState.placeholderPrefix)
        writeChunk(destination, formattedID)
        return writeChunkAndReturn(destination, completeSegmentScript3)
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(
        completeBoundaryFunction + ';$RC("',
      )
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("')
      var completeBoundaryScript2 = stringToPrecomputedChunk('","')
      var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>')
      function writeCompletedBoundaryInstruction(
        destination,
        responseState,
        boundaryID,
        contentSegmentID,
      ) {
        writeChunk(destination, responseState.startInlineScript)
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true
          writeChunk(destination, completeBoundaryScript1Full)
        } else {
          writeChunk(destination, completeBoundaryScript1Partial)
        }
        if (boundaryID === null) {
          throw new Error(
            'An ID must have been assigned before we can complete the boundary.',
          )
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16))
        writeChunk(destination, boundaryID)
        writeChunk(destination, completeBoundaryScript2)
        writeChunk(destination, responseState.segmentPrefix)
        writeChunk(destination, formattedContentID)
        return writeChunkAndReturn(destination, completeBoundaryScript3)
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(
        clientRenderFunction + ';$RX("',
      )
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("')
      var clientRenderScript1A = stringToPrecomputedChunk('"')
      var clientRenderScript2 = stringToPrecomputedChunk(')</script>')
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',')
      function writeClientRenderBoundaryInstruction(
        destination,
        responseState,
        boundaryID,
        errorDigest,
        errorMessage,
        errorComponentStack,
      ) {
        writeChunk(destination, responseState.startInlineScript)
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true
          writeChunk(destination, clientRenderScript1Full)
        } else {
          writeChunk(destination, clientRenderScript1Partial)
        }
        if (boundaryID === null) {
          throw new Error(
            'An ID must have been assigned before we can complete the boundary.',
          )
        }
        writeChunk(destination, boundaryID)
        writeChunk(destination, clientRenderScript1A)
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial)
          writeChunk(
            destination,
            stringToChunk(
              escapeJSStringsForInstructionScripts(errorDigest || ''),
            ),
          )
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial)
          writeChunk(
            destination,
            stringToChunk(
              escapeJSStringsForInstructionScripts(errorMessage || ''),
            ),
          )
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial)
          writeChunk(
            destination,
            stringToChunk(
              escapeJSStringsForInstructionScripts(errorComponentStack),
            ),
          )
        }
        return writeChunkAndReturn(destination, clientRenderScript2)
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input)
        return escaped.replace(regexForJSStringsInScripts, function (match2) {
          switch (match2) {
            // santizing breaking out of strings and script tags
            case '<':
              return '\\u003c'
            case '\u2028':
              return '\\u2028'
            case '\u2029':
              return '\\u2029'
            default: {
              throw new Error(
                'escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React',
              )
            }
          }
        })
      }
      var assign2 = Object.assign
      var REACT_ELEMENT_TYPE = Symbol.for('react.element')
      var REACT_PORTAL_TYPE = Symbol.for('react.portal')
      var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment')
      var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode')
      var REACT_PROFILER_TYPE = Symbol.for('react.profiler')
      var REACT_PROVIDER_TYPE = Symbol.for('react.provider')
      var REACT_CONTEXT_TYPE = Symbol.for('react.context')
      var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')
      var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense')
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list')
      var REACT_MEMO_TYPE = Symbol.for('react.memo')
      var REACT_LAZY_TYPE = Symbol.for('react.lazy')
      var REACT_SCOPE_TYPE = Symbol.for('react.scope')
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode')
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden')
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(
        'react.default_value',
      )
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator
      var FAUX_ITERATOR_SYMBOL = '@@iterator'
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') {
          return null
        }
        var maybeIterator =
          (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
          maybeIterable[FAUX_ITERATOR_SYMBOL]
        if (typeof maybeIterator === 'function') {
          return maybeIterator
        }
        return null
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName
        if (displayName) {
          return displayName
        }
        var functionName = innerType.displayName || innerType.name || ''
        return functionName !== ''
          ? wrapperName + '(' + functionName + ')'
          : wrapperName
      }
      function getContextName(type) {
        return type.displayName || 'Context'
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null
        }
        {
          if (typeof type.tag === 'number') {
            error(
              'Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.',
            )
          }
        }
        if (typeof type === 'function') {
          return type.displayName || type.name || null
        }
        if (typeof type === 'string') {
          return type
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return 'Fragment'
          case REACT_PORTAL_TYPE:
            return 'Portal'
          case REACT_PROFILER_TYPE:
            return 'Profiler'
          case REACT_STRICT_MODE_TYPE:
            return 'StrictMode'
          case REACT_SUSPENSE_TYPE:
            return 'Suspense'
          case REACT_SUSPENSE_LIST_TYPE:
            return 'SuspenseList'
        }
        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type
              return getContextName(context) + '.Consumer'
            case REACT_PROVIDER_TYPE:
              var provider = type
              return getContextName(provider._context) + '.Provider'
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, 'ForwardRef')
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null
              if (outerName !== null) {
                return outerName
              }
              return getComponentNameFromType(type.type) || 'Memo'
            case REACT_LAZY_TYPE: {
              var lazyComponent = type
              var payload = lazyComponent._payload
              var init = lazyComponent._init
              try {
                return getComponentNameFromType(init(payload))
              } catch (x) {
                return null
              }
            }
          }
        }
        return null
      }
      var disabledDepth = 0
      var prevLog
      var prevInfo
      var prevWarn
      var prevError
      var prevGroup
      var prevGroupCollapsed
      var prevGroupEnd
      function disabledLog() {}
      disabledLog.__reactDisabledLog = true
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log
            prevInfo = console.info
            prevWarn = console.warn
            prevError = console.error
            prevGroup = console.group
            prevGroupCollapsed = console.groupCollapsed
            prevGroupEnd = console.groupEnd
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true,
            }
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props,
            })
          }
          disabledDepth++
        }
      }
      function reenableLogs() {
        {
          disabledDepth--
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true,
            }
            Object.defineProperties(console, {
              log: assign2({}, props, {
                value: prevLog,
              }),
              info: assign2({}, props, {
                value: prevInfo,
              }),
              warn: assign2({}, props, {
                value: prevWarn,
              }),
              error: assign2({}, props, {
                value: prevError,
              }),
              group: assign2({}, props, {
                value: prevGroup,
              }),
              groupCollapsed: assign2({}, props, {
                value: prevGroupCollapsed,
              }),
              groupEnd: assign2({}, props, {
                value: prevGroupEnd,
              }),
            })
          }
          if (disabledDepth < 0) {
            error(
              'disabledDepth fell below zero. This is a bug in React. Please file an issue.',
            )
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
      var prefix
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error()
            } catch (x) {
              var match2 = x.stack.trim().match(/\n( *(at )?)/)
              prefix = (match2 && match2[1]) || ''
            }
          }
          return '\n' + prefix + name
        }
      }
      var reentry = false
      var componentFrameCache
      {
        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map
        componentFrameCache = new PossiblyWeakMap()
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return ''
        }
        {
          var frame = componentFrameCache.get(fn)
          if (frame !== void 0) {
            return frame
          }
        }
        var control
        reentry = true
        var previousPrepareStackTrace = Error.prepareStackTrace
        Error.prepareStackTrace = void 0
        var previousDispatcher
        {
          previousDispatcher = ReactCurrentDispatcher.current
          ReactCurrentDispatcher.current = null
          disableLogs()
        }
        try {
          if (construct) {
            var Fake = function () {
              throw Error()
            }
            Object.defineProperty(Fake.prototype, 'props', {
              set: function () {
                throw Error()
              },
            })
            if (typeof Reflect === 'object' && Reflect.construct) {
              try {
                Reflect.construct(Fake, [])
              } catch (x) {
                control = x
              }
              Reflect.construct(fn, [], Fake)
            } else {
              try {
                Fake.call()
              } catch (x) {
                control = x
              }
              fn.call(Fake.prototype)
            }
          } else {
            try {
              throw Error()
            } catch (x) {
              control = x
            }
            fn()
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === 'string') {
            var sampleLines = sample.stack.split('\n')
            var controlLines = control.stack.split('\n')
            var s = sampleLines.length - 1
            var c = controlLines.length - 1
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--
                    c--
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame =
                        '\n' + sampleLines[s].replace(' at new ', ' at ')
                      if (fn.displayName && _frame.includes('<anonymous>')) {
                        _frame = _frame.replace('<anonymous>', fn.displayName)
                      }
                      {
                        if (typeof fn === 'function') {
                          componentFrameCache.set(fn, _frame)
                        }
                      }
                      return _frame
                    }
                  } while (s >= 1 && c >= 0)
                }
                break
              }
            }
          }
        } finally {
          reentry = false
          {
            ReactCurrentDispatcher.current = previousDispatcher
            reenableLogs()
          }
          Error.prepareStackTrace = previousPrepareStackTrace
        }
        var name = fn ? fn.displayName || fn.name : ''
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : ''
        {
          if (typeof fn === 'function') {
            componentFrameCache.set(fn, syntheticFrame)
          }
        }
        return syntheticFrame
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true)
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false)
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype
        return !!(prototype && prototype.isReactComponent)
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return ''
        }
        if (typeof type === 'function') {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type))
          }
        }
        if (typeof type === 'string') {
          return describeBuiltInComponentFrame(type)
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame('Suspense')
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame('SuspenseList')
        }
        if (typeof type === 'object') {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render)
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(
                type.type,
                source,
                ownerFn,
              )
            case REACT_LAZY_TYPE: {
              var lazyComponent = type
              var payload = lazyComponent._payload
              var init = lazyComponent._init
              try {
                return describeUnknownElementTypeFrameInDEV(
                  init(payload),
                  source,
                  ownerFn,
                )
              } catch (x) {}
            }
          }
        }
        return ''
      }
      var loggedTypeFailures = {}
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner
            var stack = describeUnknownElementTypeFrameInDEV(
              element.type,
              element._source,
              owner ? owner.type : null,
            )
            ReactDebugCurrentFrame.setExtraStackFrame(stack)
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null)
          }
        }
      }
      function checkPropTypes(
        typeSpecs,
        values,
        location,
        componentName,
        element,
      ) {
        {
          var has = Function.call.bind(hasOwnProperty)
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0
              try {
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                  var err = Error(
                    (componentName || 'React class') +
                      ': ' +
                      location +
                      ' type `' +
                      typeSpecName +
                      '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                      typeof typeSpecs[typeSpecName] +
                      '`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.',
                  )
                  err.name = 'Invariant Violation'
                  throw err
                }
                error$1 = typeSpecs[typeSpecName](
                  values,
                  typeSpecName,
                  componentName,
                  location,
                  null,
                  'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED',
                )
              } catch (ex) {
                error$1 = ex
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element)
                error(
                  '%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).',
                  componentName || 'React class',
                  location,
                  typeSpecName,
                  typeof error$1,
                )
                setCurrentlyValidatingElement(null)
              }
              if (
                error$1 instanceof Error &&
                !(error$1.message in loggedTypeFailures)
              ) {
                loggedTypeFailures[error$1.message] = true
                setCurrentlyValidatingElement(element)
                error('Failed %s type: %s', location, error$1.message)
                setCurrentlyValidatingElement(null)
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext
      {
        warnedAboutMissingGetChildContext = {}
      }
      var emptyContextObject = {}
      {
        Object.freeze(emptyContextObject)
      }
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes
          if (!contextTypes) {
            return emptyContextObject
          }
          var context = {}
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key]
          }
          {
            var name = getComponentNameFromType(type) || 'Unknown'
            checkPropTypes(contextTypes, context, 'context', name)
          }
          return context
        }
      }
      function processChildContext(
        instance,
        type,
        parentContext,
        childContextTypes,
      ) {
        {
          if (typeof instance.getChildContext !== 'function') {
            {
              var componentName = getComponentNameFromType(type) || 'Unknown'
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true
                error(
                  '%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.',
                  componentName,
                  componentName,
                )
              }
            }
            return parentContext
          }
          var childContext = instance.getChildContext()
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error(
                (getComponentNameFromType(type) || 'Unknown') +
                  '.getChildContext(): key "' +
                  contextKey +
                  '" is not defined in childContextTypes.',
              )
            }
          }
          {
            var name = getComponentNameFromType(type) || 'Unknown'
            checkPropTypes(
              childContextTypes,
              childContext,
              'child context',
              name,
            )
          }
          return assign2({}, parentContext, childContext)
        }
      }
      var rendererSigil
      {
        rendererSigil = {}
      }
      var rootContextSnapshot = null
      var currentActiveSnapshot = null
      function popNode(prev) {
        {
          prev.context._currentValue = prev.parentValue
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue = next.value
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next);
        else {
          popNode(prev)
          var parentPrev = prev.parent
          var parentNext = next.parent
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error(
                'The stacks must reach the root at the same time. This is a bug in React.',
              )
            }
          } else {
            if (parentNext === null) {
              throw new Error(
                'The stacks must reach the root at the same time. This is a bug in React.',
              )
            }
            popToNearestCommonAncestor(parentPrev, parentNext)
          }
          pushNode(next)
        }
      }
      function popAllPrevious(prev) {
        popNode(prev)
        var parentPrev = prev.parent
        if (parentPrev !== null) {
          popAllPrevious(parentPrev)
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent
        if (parentNext !== null) {
          pushAllNext(parentNext)
        }
        pushNode(next)
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev)
        var parentPrev = prev.parent
        if (parentPrev === null) {
          throw new Error(
            'The depth must equal at least at zero before reaching the root. This is a bug in React.',
          )
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next)
        } else {
          popPreviousToCommonLevel(parentPrev, next)
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent
        if (parentNext === null) {
          throw new Error(
            'The depth must equal at least at zero before reaching the root. This is a bug in React.',
          )
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext)
        } else {
          popNextToCommonLevel(prev, parentNext)
        }
        pushNode(next)
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot
        var next = newSnapshot
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next)
          } else if (next === null) {
            popAllPrevious(prev)
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next)
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next)
          } else {
            popNextToCommonLevel(prev, next)
          }
          currentActiveSnapshot = next
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue
        {
          prevValue = context._currentValue
          context._currentValue = nextValue
          {
            if (
              context._currentRenderer !== void 0 &&
              context._currentRenderer !== null &&
              context._currentRenderer !== rendererSigil
            ) {
              error(
                'Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.',
              )
            }
            context._currentRenderer = rendererSigil
          }
        }
        var prevNode = currentActiveSnapshot
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue,
        }
        currentActiveSnapshot = newNode
        return newNode
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot
        if (prevSnapshot === null) {
          throw new Error(
            'Tried to pop a Context at the root of the app. This is a bug in React.',
          )
        }
        {
          if (prevSnapshot.context !== context) {
            error(
              'The parent context is not the expected context. This is probably a bug in React.',
            )
          }
        }
        {
          var value = prevSnapshot.parentValue
          if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue =
              prevSnapshot.context._defaultValue
          } else {
            prevSnapshot.context._currentValue = value
          }
          {
            if (
              context._currentRenderer !== void 0 &&
              context._currentRenderer !== null &&
              context._currentRenderer !== rendererSigil
            ) {
              error(
                'Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.',
              )
            }
            context._currentRenderer = rendererSigil
          }
        }
        return (currentActiveSnapshot = prevSnapshot.parent)
      }
      function getActiveContext() {
        return currentActiveSnapshot
      }
      function readContext(context) {
        var value = context._currentValue
        return value
      }
      function get(key) {
        return key._reactInternals
      }
      function set(key, value) {
        key._reactInternals = value
      }
      var didWarnAboutNoopUpdateForComponent = {}
      var didWarnAboutDeprecatedWillMount = {}
      var didWarnAboutUninitializedState
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
      var didWarnAboutLegacyLifecyclesAndDerivedState
      var didWarnAboutUndefinedDerivedState
      var warnOnUndefinedDerivedState
      var warnOnInvalidCallback
      var didWarnAboutDirectlyAssigningPropsToState
      var didWarnAboutContextTypeAndContextTypes
      var didWarnAboutInvalidateContextType
      {
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set()
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate =
          /* @__PURE__ */ new Set()
        didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set()
        didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set()
        didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set()
        didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set()
        didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set()
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set()
        warnOnInvalidCallback = function (callback, callerName) {
          if (callback === null || typeof callback === 'function') {
            return
          }
          var key = callerName + '_' + callback
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key)
            error(
              '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
              callerName,
              callback,
            )
          }
        }
        warnOnUndefinedDerivedState = function (type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || 'Component'
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName)
              error(
                '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.',
                componentName,
              )
            }
          }
        }
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor
          var componentName =
            (_constructor && getComponentNameFromType(_constructor)) ||
            'ReactClass'
          var warningKey = componentName + '.' + callerName
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return
          }
          error(
            '%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.',
            callerName,
            callerName,
            componentName,
          )
          didWarnAboutNoopUpdateForComponent[warningKey] = true
        }
      }
      var classComponentUpdater = {
        isMounted: function (inst) {
          return false
        },
        enqueueSetState: function (inst, payload, callback) {
          var internals = get(inst)
          if (internals.queue === null) {
            warnNoop(inst, 'setState')
          } else {
            internals.queue.push(payload)
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, 'setState')
              }
            }
          }
        },
        enqueueReplaceState: function (inst, payload, callback) {
          var internals = get(inst)
          internals.replace = true
          internals.queue = [payload]
          {
            if (callback !== void 0 && callback !== null) {
              warnOnInvalidCallback(callback, 'setState')
            }
          }
        },
        enqueueForceUpdate: function (inst, callback) {
          var internals = get(inst)
          if (internals.queue === null) {
            warnNoop(inst, 'forceUpdate')
          } else {
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, 'setState')
              }
            }
          }
        },
      }
      function applyDerivedStateFromProps(
        instance,
        ctor,
        getDerivedStateFromProps,
        prevState,
        nextProps,
      ) {
        var partialState = getDerivedStateFromProps(nextProps, prevState)
        {
          warnOnUndefinedDerivedState(ctor, partialState)
        }
        var newState =
          partialState === null || partialState === void 0
            ? prevState
            : assign2({}, prevState, partialState)
        return newState
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject
        var contextType = ctor.contextType
        {
          if ('contextType' in ctor) {
            var isValid2 =
              // Allow null for conditional declaration
              contextType === null ||
              (contextType !== void 0 &&
                contextType.$$typeof === REACT_CONTEXT_TYPE &&
                contextType._context === void 0)
            if (!isValid2 && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor)
              var addendum = ''
              if (contextType === void 0) {
                addendum =
                  ' However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.'
              } else if (typeof contextType !== 'object') {
                addendum =
                  ' However, it is set to a ' + typeof contextType + '.'
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum =
                  ' Did you accidentally pass the Context.Provider instead?'
              } else if (contextType._context !== void 0) {
                addendum =
                  ' Did you accidentally pass the Context.Consumer instead?'
              } else {
                addendum =
                  ' However, it is set to an object with keys {' +
                  Object.keys(contextType).join(', ') +
                  '}.'
              }
              error(
                '%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s',
                getComponentNameFromType(ctor) || 'Component',
                addendum,
              )
            }
          }
        }
        if (typeof contextType === 'object' && contextType !== null) {
          context = readContext(contextType)
        } else {
          context = maskedLegacyContext
        }
        var instance = new ctor(props, context)
        {
          if (
            typeof ctor.getDerivedStateFromProps === 'function' &&
            (instance.state === null || instance.state === void 0)
          ) {
            var componentName = getComponentNameFromType(ctor) || 'Component'
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName)
              error(
                '`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',
                componentName,
                instance.state === null ? 'null' : 'undefined',
                componentName,
              )
            }
          }
          if (
            typeof ctor.getDerivedStateFromProps === 'function' ||
            typeof instance.getSnapshotBeforeUpdate === 'function'
          ) {
            var foundWillMountName = null
            var foundWillReceivePropsName = null
            var foundWillUpdateName = null
            if (
              typeof instance.componentWillMount === 'function' &&
              instance.componentWillMount.__suppressDeprecationWarning !== true
            ) {
              foundWillMountName = 'componentWillMount'
            } else if (
              typeof instance.UNSAFE_componentWillMount === 'function'
            ) {
              foundWillMountName = 'UNSAFE_componentWillMount'
            }
            if (
              typeof instance.componentWillReceiveProps === 'function' &&
              instance.componentWillReceiveProps
                .__suppressDeprecationWarning !== true
            ) {
              foundWillReceivePropsName = 'componentWillReceiveProps'
            } else if (
              typeof instance.UNSAFE_componentWillReceiveProps === 'function'
            ) {
              foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps'
            }
            if (
              typeof instance.componentWillUpdate === 'function' &&
              instance.componentWillUpdate.__suppressDeprecationWarning !== true
            ) {
              foundWillUpdateName = 'componentWillUpdate'
            } else if (
              typeof instance.UNSAFE_componentWillUpdate === 'function'
            ) {
              foundWillUpdateName = 'UNSAFE_componentWillUpdate'
            }
            if (
              foundWillMountName !== null ||
              foundWillReceivePropsName !== null ||
              foundWillUpdateName !== null
            ) {
              var _componentName = getComponentNameFromType(ctor) || 'Component'
              var newApiName =
                typeof ctor.getDerivedStateFromProps === 'function'
                  ? 'getDerivedStateFromProps()'
                  : 'getSnapshotBeforeUpdate()'
              if (
                !didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)
              ) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName)
                error(
                  'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles',
                  _componentName,
                  newApiName,
                  foundWillMountName !== null
                    ? '\n  ' + foundWillMountName
                    : '',
                  foundWillReceivePropsName !== null
                    ? '\n  ' + foundWillReceivePropsName
                    : '',
                  foundWillUpdateName !== null
                    ? '\n  ' + foundWillUpdateName
                    : '',
                )
              }
            }
          }
        }
        return instance
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || 'Component'
          var renderPresent = instance.render
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === 'function') {
              error(
                '%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?',
                name,
              )
            } else {
              error(
                '%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.',
                name,
              )
            }
          }
          if (
            instance.getInitialState &&
            !instance.getInitialState.isReactClassApproved &&
            !instance.state
          ) {
            error(
              'getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?',
              name,
            )
          }
          if (
            instance.getDefaultProps &&
            !instance.getDefaultProps.isReactClassApproved
          ) {
            error(
              'getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.',
              name,
            )
          }
          if (instance.propTypes) {
            error(
              'propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.',
              name,
            )
          }
          if (instance.contextType) {
            error(
              'contextType was defined as an instance property on %s. Use a static property to define contextType instead.',
              name,
            )
          }
          {
            if (instance.contextTypes) {
              error(
                'contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.',
                name,
              )
            }
            if (
              ctor.contextType &&
              ctor.contextTypes &&
              !didWarnAboutContextTypeAndContextTypes.has(ctor)
            ) {
              didWarnAboutContextTypeAndContextTypes.add(ctor)
              error(
                '%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.',
                name,
              )
            }
          }
          if (typeof instance.componentShouldUpdate === 'function') {
            error(
              '%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.',
              name,
            )
          }
          if (
            ctor.prototype &&
            ctor.prototype.isPureReactComponent &&
            typeof instance.shouldComponentUpdate !== 'undefined'
          ) {
            error(
              '%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.',
              getComponentNameFromType(ctor) || 'A pure component',
            )
          }
          if (typeof instance.componentDidUnmount === 'function') {
            error(
              '%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?',
              name,
            )
          }
          if (typeof instance.componentDidReceiveProps === 'function') {
            error(
              '%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
              name,
            )
          }
          if (typeof instance.componentWillRecieveProps === 'function') {
            error(
              '%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
              name,
            )
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
            error(
              '%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',
              name,
            )
          }
          var hasMutatedProps = instance.props !== newProps
          if (instance.props !== void 0 && hasMutatedProps) {
            error(
              "%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              name,
              name,
            )
          }
          if (instance.defaultProps) {
            error(
              'Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.',
              name,
              name,
            )
          }
          if (
            typeof instance.getSnapshotBeforeUpdate === 'function' &&
            typeof instance.componentDidUpdate !== 'function' &&
            !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)
          ) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor)
            error(
              '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.',
              getComponentNameFromType(ctor),
            )
          }
          if (typeof instance.getDerivedStateFromProps === 'function') {
            error(
              '%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
              name,
            )
          }
          if (typeof instance.getDerivedStateFromError === 'function') {
            error(
              '%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
              name,
            )
          }
          if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
            error(
              '%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.',
              name,
            )
          }
          var _state = instance.state
          if (_state && (typeof _state !== 'object' || isArray2(_state))) {
            error('%s.state: must be set to an object or null', name)
          }
          if (
            typeof instance.getChildContext === 'function' &&
            typeof ctor.childContextTypes !== 'object'
          ) {
            error(
              '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().',
              name,
            )
          }
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state
        if (typeof instance.componentWillMount === 'function') {
          {
            if (
              instance.componentWillMount.__suppressDeprecationWarning !== true
            ) {
              var componentName = getComponentNameFromType(type) || 'Unknown'
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn(
                  // keep this warning in sync with ReactStrictModeWarning.js
                  'componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s',
                  componentName,
                )
                didWarnAboutDeprecatedWillMount[componentName] = true
              }
            }
          }
          instance.componentWillMount()
        }
        if (typeof instance.UNSAFE_componentWillMount === 'function') {
          instance.UNSAFE_componentWillMount()
        }
        if (oldState !== instance.state) {
          {
            error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromType(type) || 'Component',
            )
          }
          classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null,
          )
        }
      }
      function processUpdateQueue(
        internalInstance,
        inst,
        props,
        maskedLegacyContext,
      ) {
        if (
          internalInstance.queue !== null &&
          internalInstance.queue.length > 0
        ) {
          var oldQueue = internalInstance.queue
          var oldReplace = internalInstance.replace
          internalInstance.queue = null
          internalInstance.replace = false
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0]
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state
            var dontMutate = true
            for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
              var partial = oldQueue[i]
              var partialState =
                typeof partial === 'function'
                  ? partial.call(inst, nextState, props, maskedLegacyContext)
                  : partial
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false
                  nextState = assign2({}, nextState, partialState)
                } else {
                  assign2(nextState, partialState)
                }
              }
            }
            inst.state = nextState
          }
        } else {
          internalInstance.queue = null
        }
      }
      function mountClassInstance(
        instance,
        ctor,
        newProps,
        maskedLegacyContext,
      ) {
        {
          checkClassInstance(instance, ctor, newProps)
        }
        var initialState = instance.state !== void 0 ? instance.state : null
        instance.updater = classComponentUpdater
        instance.props = newProps
        instance.state = initialState
        var internalInstance = {
          queue: [],
          replace: false,
        }
        set(instance, internalInstance)
        var contextType = ctor.contextType
        if (typeof contextType === 'object' && contextType !== null) {
          instance.context = readContext(contextType)
        } else {
          instance.context = maskedLegacyContext
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || 'Component'
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName)
              error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName,
              )
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps
        if (typeof getDerivedStateFromProps === 'function') {
          instance.state = applyDerivedStateFromProps(
            instance,
            ctor,
            getDerivedStateFromProps,
            initialState,
            newProps,
          )
        }
        if (
          typeof ctor.getDerivedStateFromProps !== 'function' &&
          typeof instance.getSnapshotBeforeUpdate !== 'function' &&
          (typeof instance.UNSAFE_componentWillMount === 'function' ||
            typeof instance.componentWillMount === 'function')
        ) {
          callComponentWillMount(ctor, instance)
          processUpdateQueue(
            internalInstance,
            instance,
            newProps,
            maskedLegacyContext,
          )
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: '',
      }
      function getTreeId(context) {
        var overflow = context.overflow
        var idWithLeadingBit = context.id
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit)
        return id.toString(32) + overflow
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id
        var baseOverflow = baseContext.overflow
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength)
        var slot = index + 1
        var length = getBitLength(totalChildren) + baseLength
        if (length > 30) {
          var numberOfOverflowBits = baseLength - (baseLength % 5)
          var newOverflowBits = (1 << numberOfOverflowBits) - 1
          var newOverflow = (baseId & newOverflowBits).toString(32)
          var restOfBaseId = baseId >> numberOfOverflowBits
          var restOfBaseLength = baseLength - numberOfOverflowBits
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength
          var restOfNewBits = slot << restOfBaseLength
          var id = restOfNewBits | restOfBaseId
          var overflow = newOverflow + baseOverflow
          return {
            id: (1 << restOfLength) | id,
            overflow,
          }
        } else {
          var newBits = slot << baseLength
          var _id = newBits | baseId
          var _overflow = baseOverflow
          return {
            id: (1 << length) | _id,
            overflow: _overflow,
          }
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number)
      }
      function getLeadingBit(id) {
        return 1 << (getBitLength(id) - 1)
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback
      var log = Math.log
      var LN2 = Math.LN2
      function clz32Fallback(x) {
        var asUint = x >>> 0
        if (asUint === 0) {
          return 32
        }
        return (31 - ((log(asUint) / LN2) | 0)) | 0
      }
      function is(x, y) {
        return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)
      }
      var objectIs = typeof Object.is === 'function' ? Object.is : is
      var currentlyRenderingComponent = null
      var currentlyRenderingTask = null
      var firstWorkInProgressHook = null
      var workInProgressHook = null
      var isReRender = false
      var didScheduleRenderPhaseUpdate = false
      var localIdCounter = 0
      var renderPhaseUpdates = null
      var numberOfReRenders = 0
      var RE_RENDER_LIMIT = 25
      var isInHookUserCodeInDev = false
      var currentHookNameInDev
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error(
            'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
          )
        }
        {
          if (isInHookUserCodeInDev) {
            error(
              'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks',
            )
          }
        }
        return currentlyRenderingComponent
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error(
              '%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.',
              currentHookNameInDev,
            )
          }
          return false
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error(
              'The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s',
              currentHookNameInDev,
              '[' + nextDeps.join(', ') + ']',
              '[' + prevDeps.join(', ') + ']',
            )
          }
        }
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue
          }
          return false
        }
        return true
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error('Rendered more hooks than during the previous render')
        }
        return {
          memoizedState: null,
          queue: null,
          next: null,
        }
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false
            firstWorkInProgressHook = workInProgressHook = createHook()
          } else {
            isReRender = true
            workInProgressHook = firstWorkInProgressHook
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false
            workInProgressHook = workInProgressHook.next = createHook()
          } else {
            isReRender = true
            workInProgressHook = workInProgressHook.next
          }
        }
        return workInProgressHook
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity
        currentlyRenderingTask = task
        {
          isInHookUserCodeInDev = false
        }
        localIdCounter = 0
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false
          localIdCounter = 0
          numberOfReRenders += 1
          workInProgressHook = null
          children = Component(props, refOrContext)
        }
        resetHooksState()
        return children
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0
        return didRenderIdHook
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false
        }
        currentlyRenderingComponent = null
        currentlyRenderingTask = null
        didScheduleRenderPhaseUpdate = false
        firstWorkInProgressHook = null
        numberOfReRenders = 0
        renderPhaseUpdates = null
        workInProgressHook = null
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error(
              'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().',
            )
          }
        }
        return readContext(context)
      }
      function useContext(context) {
        {
          currentHookNameInDev = 'useContext'
        }
        resolveCurrentlyRenderingComponent()
        return readContext(context)
      }
      function basicStateReducer(state, action) {
        return typeof action === 'function' ? action(state) : action
      }
      function useState(initialState) {
        {
          currentHookNameInDev = 'useState'
        }
        return useReducer(
          basicStateReducer,
          // useReducer has a special case to support lazy useState initializers
          initialState,
        )
      }
      function useReducer(reducer, initialArg, init) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = 'useReducer'
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent()
        workInProgressHook = createWorkInProgressHook()
        if (isReRender) {
          var queue = workInProgressHook.queue
          var dispatch = queue.dispatch
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue)
              var newState = workInProgressHook.memoizedState
              var update = firstRenderPhaseUpdate
              do {
                var action = update.action
                {
                  isInHookUserCodeInDev = true
                }
                newState = reducer(newState, action)
                {
                  isInHookUserCodeInDev = false
                }
                update = update.next
              } while (update !== null)
              workInProgressHook.memoizedState = newState
              return [newState, dispatch]
            }
          }
          return [workInProgressHook.memoizedState, dispatch]
        } else {
          {
            isInHookUserCodeInDev = true
          }
          var initialState
          if (reducer === basicStateReducer) {
            initialState =
              typeof initialArg === 'function' ? initialArg() : initialArg
          } else {
            initialState = init !== void 0 ? init(initialArg) : initialArg
          }
          {
            isInHookUserCodeInDev = false
          }
          workInProgressHook.memoizedState = initialState
          var _queue = (workInProgressHook.queue = {
            last: null,
            dispatch: null,
          })
          var _dispatch = (_queue.dispatch = dispatchAction.bind(
            null,
            currentlyRenderingComponent,
            _queue,
          ))
          return [workInProgressHook.memoizedState, _dispatch]
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent()
        workInProgressHook = createWorkInProgressHook()
        var nextDeps = deps === void 0 ? null : deps
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1]
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0]
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true
        }
        var nextValue = nextCreate()
        {
          isInHookUserCodeInDev = false
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps]
        return nextValue
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent()
        workInProgressHook = createWorkInProgressHook()
        var previousRef = workInProgressHook.memoizedState
        if (previousRef === null) {
          var ref = {
            current: initialValue,
          }
          {
            Object.seal(ref)
          }
          workInProgressHook.memoizedState = ref
          return ref
        } else {
          return previousRef
        }
      }
      function useLayoutEffect(create, inputs) {
        {
          currentHookNameInDev = 'useLayoutEffect'
          error(
            "useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.",
          )
        }
      }
      function dispatchAction(componentIdentity, queue, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error(
            'Too many re-renders. React limits the number of renders to prevent an infinite loop.',
          )
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true
          var update = {
            action,
            next: null,
          }
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = /* @__PURE__ */ new Map()
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)
          if (firstRenderPhaseUpdate === void 0) {
            renderPhaseUpdates.set(queue, update)
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next
            }
            lastRenderPhaseUpdate.next = update
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function () {
          return callback
        }, deps)
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        resolveCurrentlyRenderingComponent()
        return getSnapshot(source._source)
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === void 0) {
          throw new Error(
            'Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.',
          )
        }
        return getServerSnapshot()
      }
      function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent()
        return value
      }
      function unsupportedStartTransition() {
        throw new Error(
          'startTransition cannot be called during server rendering.',
        )
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent()
        return [false, unsupportedStartTransition]
      }
      function useId() {
        var task = currentlyRenderingTask
        var treeId = getTreeId(task.treeContext)
        var responseState = currentResponseState
        if (responseState === null) {
          throw new Error(
            'Invalid hook call. Hooks can only be called inside of the body of a function component.',
          )
        }
        var localId = localIdCounter++
        return makeId(responseState, treeId, localId)
      }
      function noop2() {}
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop2,
        useLayoutEffect,
        useCallback,
        // useImperativeHandle is not run in the server environment
        useImperativeHandle: noop2,
        // Effects are not run in the server environment.
        useEffect: noop2,
        // Debugging effect
        useDebugValue: noop2,
        useDeferredValue,
        useTransition,
        useId,
        // Subscriptions are not setup in a server environment.
        useMutableSource,
        useSyncExternalStore,
      }
      var currentResponseState = null
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = ''
          var node = componentStack
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null)
                break
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null)
                break
              case 2:
                info += describeClassComponentFrame(node.type, null, null)
                break
            }
            node = node.parent
          } while (node)
          return info
        } catch (x) {
          return '\nError generating stack: ' + x.message + '\n' + x.stack
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame
      var PENDING = 0
      var COMPLETED = 1
      var FLUSHED = 2
      var ABORTED = 3
      var ERRORED = 4
      var OPEN = 0
      var CLOSING = 1
      var CLOSED = 2
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800
      function defaultErrorHandler(error2) {
        console['error'](error2)
        return null
      }
      function noop$1() {}
      function createRequest(
        children,
        responseState,
        rootFormatContext,
        progressiveChunkSize,
        onError,
        onAllReady,
        onShellReady,
        onShellError,
        onFatalError,
      ) {
        var pingedTasks = []
        var abortSet = /* @__PURE__ */ new Set()
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize:
            progressiveChunkSize === void 0
              ? DEFAULT_PROGRESSIVE_CHUNK_SIZE
              : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError === void 0 ? defaultErrorHandler : onError,
          onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
          onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
          onShellError: onShellError === void 0 ? noop$1 : onShellError,
          onFatalError: onFatalError === void 0 ? noop$1 : onFatalError,
        }
        var rootSegment = createPendingSegment(
          request,
          0,
          null,
          rootFormatContext,
          // Root segments are never embedded in Text on either edge
          false,
          false,
        )
        rootSegment.parentFlushed = true
        var rootTask = createTask(
          request,
          children,
          null,
          rootSegment,
          abortSet,
          emptyContextObject,
          rootContextSnapshot,
          emptyTreeContext,
        )
        pingedTasks.push(rootTask)
        return request
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks
        pingedTasks.push(task)
        if (pingedTasks.length === 1) {
          scheduleWork(function () {
            return performWork(request)
          })
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null,
        }
      }
      function createTask(
        request,
        node,
        blockedBoundary,
        blockedSegment,
        abortSet,
        legacyContext,
        context,
        treeContext,
      ) {
        request.allPendingTasks++
        if (blockedBoundary === null) {
          request.pendingRootTasks++
        } else {
          blockedBoundary.pendingTasks++
        }
        var task = {
          node,
          ping: function () {
            return pingTask(request, task)
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext,
        }
        {
          task.componentStack = null
        }
        abortSet.add(task)
        return task
      }
      function createPendingSegment(
        request,
        index,
        boundary,
        formatContext,
        lastPushedText,
        textEmbedded,
      ) {
        return {
          status: PENDING,
          id: -1,
          // lazily assigned later
          index,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded,
        }
      }
      var currentTaskInDEV = null
      function getCurrentStackInDEV() {
        {
          if (
            currentTaskInDEV === null ||
            currentTaskInDEV.componentStack === null
          ) {
            return ''
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack)
        }
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type,
          }
        }
      }
      function pushFunctionComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type,
          }
        }
      }
      function pushClassComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type,
          }
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error(
              'Unexpectedly popped too many stack frames. This is a bug in React.',
            )
          } else {
            task.componentStack = task.componentStack.parent
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage
          if (typeof error2 === 'string') {
            errorMessage = error2
          } else if (error2 && typeof error2.message === 'string') {
            errorMessage = error2.message
          } else {
            errorMessage = String(error2)
          }
          var errorComponentStack =
            lastBoundaryErrorComponentStackDev || getCurrentStackInDEV()
          lastBoundaryErrorComponentStackDev = null
          boundary.errorMessage = errorMessage
          boundary.errorComponentStack = errorComponentStack
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2)
        if (errorDigest != null && typeof errorDigest !== 'string') {
          throw new Error(
            'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
              typeof errorDigest +
              '" instead',
          )
        }
        return errorDigest
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError
        onShellError(error2)
        var onFatalError = request.onFatalError
        onFatalError(error2)
        if (request.destination !== null) {
          request.status = CLOSED
          closeWithError(request.destination, error2)
        } else {
          request.status = CLOSING
          request.fatalError = error2
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, 'Suspense')
        var parentBoundary = task.blockedBoundary
        var parentSegment = task.blockedSegment
        var fallback = props.fallback
        var content = props.children
        var fallbackAbortSet = /* @__PURE__ */ new Set()
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet)
        var insertionIndex = parentSegment.chunks.length
        var boundarySegment = createPendingSegment(
          request,
          insertionIndex,
          newBoundary,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          false,
          false,
        )
        parentSegment.children.push(boundarySegment)
        parentSegment.lastPushedText = false
        var contentRootSegment = createPendingSegment(
          request,
          0,
          null,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          false,
          false,
        )
        contentRootSegment.parentFlushed = true
        task.blockedBoundary = newBoundary
        task.blockedSegment = contentRootSegment
        try {
          renderNode(request, task, content)
          pushSegmentFinale(
            contentRootSegment.chunks,
            request.responseState,
            contentRootSegment.lastPushedText,
            contentRootSegment.textEmbedded,
          )
          contentRootSegment.status = COMPLETED
          queueCompletedSegment(newBoundary, contentRootSegment)
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task)
            return
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED
          newBoundary.forceClientRender = true
          newBoundary.errorDigest = logRecoverableError(request, error2)
          {
            captureBoundaryErrorDetailsDev(newBoundary, error2)
          }
        } finally {
          task.blockedBoundary = parentBoundary
          task.blockedSegment = parentSegment
        }
        var suspendedFallbackTask = createTask(
          request,
          fallback,
          parentBoundary,
          boundarySegment,
          fallbackAbortSet,
          task.legacyContext,
          task.context,
          task.treeContext,
        )
        {
          suspendedFallbackTask.componentStack = task.componentStack
        }
        request.pingedTasks.push(suspendedFallbackTask)
        popComponentStackInDEV(task)
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type)
        var segment = task.blockedSegment
        var children = pushStartInstance(
          segment.chunks,
          type,
          props,
          request.responseState,
          segment.formatContext,
        )
        segment.lastPushedText = false
        var prevContext = segment.formatContext
        segment.formatContext = getChildFormatContext(prevContext, type, props)
        renderNode(request, task, children)
        segment.formatContext = prevContext
        pushEndInstance(segment.chunks, type)
        segment.lastPushedText = false
        popComponentStackInDEV(task)
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {}
        prepareToUseHooks(task, componentIdentity)
        var result = Component(props, secondArg)
        return finishHooks(Component, props, result, secondArg)
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render()
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error(
                'It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.',
                getComponentNameFromType(Component) || 'a component',
              )
            }
            didWarnAboutReassigningProps = true
          }
        }
        {
          var childContextTypes = Component.childContextTypes
          if (childContextTypes !== null && childContextTypes !== void 0) {
            var previousContext = task.legacyContext
            var mergedContext = processChildContext(
              instance,
              Component,
              previousContext,
              childContextTypes,
            )
            task.legacyContext = mergedContext
            renderNodeDestructive(request, task, nextChildren)
            task.legacyContext = previousContext
            return
          }
        }
        renderNodeDestructive(request, task, nextChildren)
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component)
        var maskedContext = getMaskedContext(Component, task.legacyContext)
        var instance = constructClassInstance(Component, props, maskedContext)
        mountClassInstance(instance, Component, props, maskedContext)
        finishClassComponent(request, task, instance, Component, props)
        popComponentStackInDEV(task)
      }
      var didWarnAboutBadClass = {}
      var didWarnAboutModulePatternComponent = {}
      var didWarnAboutContextTypeOnFunctionComponent = {}
      var didWarnAboutGetDerivedStateOnFunctionComponent = {}
      var didWarnAboutReassigningProps = false
      var didWarnAboutGenerators = false
      var didWarnAboutMaps = false
      var hasWarnedAboutUsingContextAsConsumer = false
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext
        {
          legacyContext = getMaskedContext(Component, task.legacyContext)
        }
        pushFunctionComponentStackInDEV(task, Component)
        {
          if (
            Component.prototype &&
            typeof Component.prototype.render === 'function'
          ) {
            var componentName = getComponentNameFromType(Component) || 'Unknown'
            if (!didWarnAboutBadClass[componentName]) {
              error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName,
                componentName,
              )
              didWarnAboutBadClass[componentName] = true
            }
          }
        }
        var value = renderWithHooks(
          request,
          task,
          Component,
          props,
          legacyContext,
        )
        var hasId = checkDidRenderIdHook()
        {
          if (
            typeof value === 'object' &&
            value !== null &&
            typeof value.render === 'function' &&
            value.$$typeof === void 0
          ) {
            var _componentName =
              getComponentNameFromType(Component) || 'Unknown'
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error(
                "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
                _componentName,
                _componentName,
                _componentName,
              )
              didWarnAboutModulePatternComponent[_componentName] = true
            }
          }
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value === 'object' &&
          value !== null &&
          typeof value.render === 'function' &&
          value.$$typeof === void 0
        ) {
          {
            var _componentName2 =
              getComponentNameFromType(Component) || 'Unknown'
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error(
                "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
                _componentName2,
                _componentName2,
                _componentName2,
              )
              didWarnAboutModulePatternComponent[_componentName2] = true
            }
          }
          mountClassInstance(value, Component, props, legacyContext)
          finishClassComponent(request, task, value, Component, props)
        } else {
          {
            validateFunctionComponentInDev(Component)
          }
          if (hasId) {
            var prevTreeContext = task.treeContext
            var totalChildren = 1
            var index = 0
            task.treeContext = pushTreeContext(
              prevTreeContext,
              totalChildren,
              index,
            )
            try {
              renderNodeDestructive(request, task, value)
            } finally {
              task.treeContext = prevTreeContext
            }
          } else {
            renderNodeDestructive(request, task, value)
          }
        }
        popComponentStackInDEV(task)
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error(
                '%s(...): childContextTypes cannot be defined on a function component.',
                Component.displayName || Component.name || 'Component',
              )
            }
          }
          if (typeof Component.getDerivedStateFromProps === 'function') {
            var _componentName3 =
              getComponentNameFromType(Component) || 'Unknown'
            if (
              !didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]
            ) {
              error(
                '%s: Function components do not support getDerivedStateFromProps.',
                _componentName3,
              )
              didWarnAboutGetDerivedStateOnFunctionComponent[
                _componentName3
              ] = true
            }
          }
          if (
            typeof Component.contextType === 'object' &&
            Component.contextType !== null
          ) {
            var _componentName4 =
              getComponentNameFromType(Component) || 'Unknown'
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error(
                '%s: Function components do not support contextType.',
                _componentName4,
              )
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign2({}, baseProps)
          var defaultProps = Component.defaultProps
          for (var propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName]
            }
          }
          return props
        }
        return baseProps
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render)
        var children = renderWithHooks(request, task, type.render, props, ref)
        var hasId = checkDidRenderIdHook()
        if (hasId) {
          var prevTreeContext = task.treeContext
          var totalChildren = 1
          var index = 0
          task.treeContext = pushTreeContext(
            prevTreeContext,
            totalChildren,
            index,
          )
          try {
            renderNodeDestructive(request, task, children)
          } finally {
            task.treeContext = prevTreeContext
          }
        } else {
          renderNodeDestructive(request, task, children)
        }
        popComponentStackInDEV(task)
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type
        var resolvedProps = resolveDefaultProps(innerType, props)
        renderElement(request, task, innerType, resolvedProps, ref)
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === void 0) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true
                error(
                  'Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?',
                )
              }
            }
          } else {
            context = context._context
          }
        }
        var render = props.children
        {
          if (typeof render !== 'function') {
            error(
              "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.",
            )
          }
        }
        var newValue = readContext(context)
        var newChildren = render(newValue)
        renderNodeDestructive(request, task, newChildren)
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context
        var value = props.value
        var children = props.children
        var prevSnapshot
        {
          prevSnapshot = task.context
        }
        task.context = pushProvider(context, value)
        renderNodeDestructive(request, task, children)
        task.context = popProvider(context)
        {
          if (prevSnapshot !== task.context) {
            error(
              'Popping the context provider did not return back to the original snapshot. This is a bug in React.',
            )
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, 'Lazy')
        var payload = lazyComponent._payload
        var init = lazyComponent._init
        var Component = init(payload)
        var resolvedProps = resolveDefaultProps(Component, props)
        renderElement(request, task, Component, resolvedProps, ref)
        popComponentStackInDEV(task)
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type === 'function') {
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props)
            return
          } else {
            renderIndeterminateComponent(request, task, type, props)
            return
          }
        }
        if (typeof type === 'string') {
          renderHostElement(request, task, type, props)
          return
        }
        switch (type) {
          // TODO: LegacyHidden acts the same as a fragment. This only works
          // because we currently assume that every instance of LegacyHidden is
          // accompanied by a host component wrapper. In the hidden mode, the host
          // component is given a `hidden` attribute, which ensures that the
          // initial HTML is not visible. To support the use of LegacyHidden as a
          // true fragment, without an extra DOM node, we would have to hide the
          // initial HTML in some other way.
          // TODO: Add REACT_OFFSCREEN_TYPE here too with the same capability.
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children)
            return
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, 'SuspenseList')
            renderNodeDestructive(request, task, props.children)
            popComponentStackInDEV(task)
            return
          }
          case REACT_SCOPE_TYPE: {
            throw new Error(
              'ReactDOMServer does not yet support scope components.',
            )
          }
          // eslint-disable-next-line-no-fallthrough
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props)
            }
            return
          }
        }
        if (typeof type === 'object' && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref)
              return
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref)
              return
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props)
              return
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props)
              return
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props)
              return
            }
          }
        }
        var info = ''
        {
          if (
            type === void 0 ||
            (typeof type === 'object' &&
              type !== null &&
              Object.keys(type).length === 0)
          ) {
            info +=
              " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."
          }
        }
        throw new Error(
          'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) ' +
            ('but got: ' + (type == null ? type : typeof type) + '.' + info),
        )
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (
            typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === 'Generator'
          ) {
            if (!didWarnAboutGenerators) {
              error(
                'Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.',
              )
            }
            didWarnAboutGenerators = true
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error(
                'Using Maps as children is not supported. Use an array of keyed ReactElements instead.',
              )
            }
            didWarnAboutMaps = true
          }
        }
      }
      function renderNodeDestructive(request, task, node) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node)
          } catch (x) {
            if (
              typeof x === 'object' &&
              x !== null &&
              typeof x.then === 'function'
            );
            else {
              lastBoundaryErrorComponentStackDev =
                lastBoundaryErrorComponentStackDev !== null
                  ? lastBoundaryErrorComponentStackDev
                  : getCurrentStackInDEV()
            }
            throw x
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        task.node = node
        if (typeof node === 'object' && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node
              var type = element.type
              var props = element.props
              var ref = element.ref
              renderElement(request, task, type, props, ref)
              return
            }
            case REACT_PORTAL_TYPE:
              throw new Error(
                'Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.',
              )
            // eslint-disable-next-line-no-fallthrough
            case REACT_LAZY_TYPE: {
              var lazyNode = node
              var payload = lazyNode._payload
              var init = lazyNode._init
              var resolvedNode
              {
                try {
                  resolvedNode = init(payload)
                } catch (x) {
                  if (
                    typeof x === 'object' &&
                    x !== null &&
                    typeof x.then === 'function'
                  ) {
                    pushBuiltInComponentStackInDEV(task, 'Lazy')
                  }
                  throw x
                }
              }
              renderNodeDestructive(request, task, resolvedNode)
              return
            }
          }
          if (isArray2(node)) {
            renderChildrenArray(request, task, node)
            return
          }
          var iteratorFn = getIteratorFn(node)
          if (iteratorFn) {
            {
              validateIterable(node, iteratorFn)
            }
            var iterator = iteratorFn.call(node)
            if (iterator) {
              var step = iterator.next()
              if (!step.done) {
                var children = []
                do {
                  children.push(step.value)
                  step = iterator.next()
                } while (!step.done)
                renderChildrenArray(request, task, children)
                return
              }
              return
            }
          }
          var childString = Object.prototype.toString.call(node)
          throw new Error(
            'Objects are not valid as a React child (found: ' +
              (childString === '[object Object]'
                ? 'object with keys {' + Object.keys(node).join(', ') + '}'
                : childString) +
              '). If you meant to render a collection of children, use an array instead.',
          )
        }
        if (typeof node === 'string') {
          var segment = task.blockedSegment
          segment.lastPushedText = pushTextInstance(
            task.blockedSegment.chunks,
            node,
            request.responseState,
            segment.lastPushedText,
          )
          return
        }
        if (typeof node === 'number') {
          var _segment = task.blockedSegment
          _segment.lastPushedText = pushTextInstance(
            task.blockedSegment.chunks,
            '' + node,
            request.responseState,
            _segment.lastPushedText,
          )
          return
        }
        {
          if (typeof node === 'function') {
            error(
              'Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.',
            )
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length
        for (var i = 0; i < totalChildren; i++) {
          var prevTreeContext = task.treeContext
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i)
          try {
            renderNode(request, task, children[i])
          } finally {
            task.treeContext = prevTreeContext
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment
        var insertionIndex = segment.chunks.length
        var newSegment = createPendingSegment(
          request,
          insertionIndex,
          null,
          segment.formatContext,
          // Adopt the parent segment's leading text embed
          segment.lastPushedText,
          // Assume we are text embedded at the trailing edge
          true,
        )
        segment.children.push(newSegment)
        segment.lastPushedText = false
        var newTask = createTask(
          request,
          task.node,
          task.blockedBoundary,
          newSegment,
          task.abortSet,
          task.legacyContext,
          task.context,
          task.treeContext,
        )
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent
          }
        }
        var ping = newTask.ping
        x.then(ping, ping)
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext
        var previousLegacyContext = task.legacyContext
        var previousContext = task.context
        var previousComponentStack = null
        {
          previousComponentStack = task.componentStack
        }
        try {
          return renderNodeDestructive(request, task, node)
        } catch (x) {
          resetHooksState()
          if (
            typeof x === 'object' &&
            x !== null &&
            typeof x.then === 'function'
          ) {
            spawnNewSuspendedTask(request, task, x)
            task.blockedSegment.formatContext = previousFormatContext
            task.legacyContext = previousLegacyContext
            task.context = previousContext
            switchContext(previousContext)
            {
              task.componentStack = previousComponentStack
            }
            return
          } else {
            task.blockedSegment.formatContext = previousFormatContext
            task.legacyContext = previousLegacyContext
            task.context = previousContext
            switchContext(previousContext)
            {
              task.componentStack = previousComponentStack
            }
            throw x
          }
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2)
        if (boundary === null) {
          fatalError(request, error2)
        } else {
          boundary.pendingTasks--
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true
            boundary.errorDigest = errorDigest
            {
              captureBoundaryErrorDetailsDev(boundary, error2)
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary)
            }
          }
        }
        request.allPendingTasks--
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady
          onAllReady()
        }
      }
      function abortTaskSoft(task) {
        var request = this
        var boundary = task.blockedBoundary
        var segment = task.blockedSegment
        segment.status = ABORTED
        finishedTask(request, boundary, segment)
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary
        var segment = task.blockedSegment
        segment.status = ABORTED
        if (boundary === null) {
          request.allPendingTasks--
          if (request.status !== CLOSED) {
            request.status = CLOSED
            if (request.destination !== null) {
              close(request.destination)
            }
          }
        } else {
          boundary.pendingTasks--
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true
            var _error =
              reason === void 0
                ? new Error(
                    'The render was aborted by the server without a reason.',
                  )
                : reason
            boundary.errorDigest = request.onError(_error)
            {
              var errorPrefix =
                'The server did not finish this Suspense boundary: '
              if (_error && typeof _error.message === 'string') {
                _error = errorPrefix + _error.message
              } else {
                _error = errorPrefix + String(_error)
              }
              var previousTaskInDev = currentTaskInDEV
              currentTaskInDEV = task
              try {
                captureBoundaryErrorDetailsDev(boundary, _error)
              } finally {
                currentTaskInDEV = previousTaskInDev
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary)
            }
          }
          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {
            return abortTask(fallbackTask, request, reason)
          })
          boundary.fallbackAbortableTasks.clear()
          request.allPendingTasks--
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady
            onAllReady()
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (
          segment.chunks.length === 0 &&
          segment.children.length === 1 &&
          segment.children[0].boundary === null
        ) {
          var childSegment = segment.children[0]
          childSegment.id = segment.id
          childSegment.parentFlushed = true
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment)
          }
        } else {
          var completedSegments = boundary.completedSegments
          completedSegments.push(segment)
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error(
                'There can only be one root segment. This is a bug in React.',
              )
            }
            request.completedRootSegment = segment
          }
          request.pendingRootTasks--
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1
            var onShellReady = request.onShellReady
            onShellReady()
          }
        } else {
          boundary.pendingTasks--
          if (boundary.forceClientRender);
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment)
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary)
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request)
            boundary.fallbackAbortableTasks.clear()
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment)
                var completedSegments = boundary.completedSegments
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary)
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady
          onAllReady()
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment
        if (segment.status !== PENDING) {
          return
        }
        switchContext(task.context)
        var prevTaskInDEV = null
        {
          prevTaskInDEV = currentTaskInDEV
          currentTaskInDEV = task
        }
        try {
          renderNodeDestructive(request, task, task.node)
          pushSegmentFinale(
            segment.chunks,
            request.responseState,
            segment.lastPushedText,
            segment.textEmbedded,
          )
          task.abortSet.delete(task)
          segment.status = COMPLETED
          finishedTask(request, task.blockedBoundary, segment)
        } catch (x) {
          resetHooksState()
          if (
            typeof x === 'object' &&
            x !== null &&
            typeof x.then === 'function'
          ) {
            var ping = task.ping
            x.then(ping, ping)
          } else {
            task.abortSet.delete(task)
            segment.status = ERRORED
            erroredTask(request, task.blockedBoundary, segment, x)
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return
        }
        var prevContext = getActiveContext()
        var prevDispatcher = ReactCurrentDispatcher$1.current
        ReactCurrentDispatcher$1.current = Dispatcher
        var prevGetCurrentStackImpl
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV
        }
        var prevResponseState = currentResponseState
        setCurrentResponseState(request.responseState)
        try {
          var pingedTasks = request.pingedTasks
          var i
          for (i = 0; i < pingedTasks.length; i++) {
            var task = pingedTasks[i]
            retryTask(request, task)
          }
          pingedTasks.splice(0, i)
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination)
          }
        } catch (error2) {
          logRecoverableError(request, error2)
          fatalError(request, error2)
        } finally {
          setCurrentResponseState(prevResponseState)
          ReactCurrentDispatcher$1.current = prevDispatcher
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext)
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true
        switch (segment.status) {
          case PENDING: {
            var segmentID = (segment.id = request.nextSegmentId++)
            segment.lastPushedText = false
            segment.textEmbedded = false
            return writePlaceholder(
              destination,
              request.responseState,
              segmentID,
            )
          }
          case COMPLETED: {
            segment.status = FLUSHED
            var r = true
            var chunks = segment.chunks
            var chunkIdx = 0
            var children = segment.children
            for (var childIdx = 0; childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx]
              for (; chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx])
              }
              r = flushSegment(request, destination, nextChild)
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx])
            }
            if (chunkIdx < chunks.length) {
              r = writeChunkAndReturn(destination, chunks[chunkIdx])
            }
            return r
          }
          default: {
            throw new Error(
              'Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.',
            )
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary
        if (boundary === null) {
          return flushSubtree(request, destination, segment)
        }
        boundary.parentFlushed = true
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary(
            destination,
            request.responseState,
            boundary.errorDigest,
            boundary.errorMessage,
            boundary.errorComponentStack,
          )
          flushSubtree(request, destination, segment)
          return writeEndClientRenderedSuspenseBoundary(
            destination,
            request.responseState,
          )
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary)
          }
          var id = (boundary.id = assignSuspenseBoundaryID(
            request.responseState,
          ))
          writeStartPendingSuspenseBoundary(
            destination,
            request.responseState,
            id,
          )
          flushSubtree(request, destination, segment)
          return writeEndPendingSuspenseBoundary(
            destination,
            request.responseState,
          )
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++
          request.completedBoundaries.push(boundary)
          writeStartPendingSuspenseBoundary(
            destination,
            request.responseState,
            boundary.id,
          )
          flushSubtree(request, destination, segment)
          return writeEndPendingSuspenseBoundary(
            destination,
            request.responseState,
          )
        } else {
          writeStartCompletedSuspenseBoundary(
            destination,
            request.responseState,
          )
          var completedSegments = boundary.completedSegments
          if (completedSegments.length !== 1) {
            throw new Error(
              'A previously unvisited boundary must have exactly one root segment. This is a bug in React.',
            )
          }
          var contentSegment = completedSegments[0]
          flushSegment(request, destination, contentSegment)
          return writeEndCompletedSuspenseBoundary(
            destination,
            request.responseState,
          )
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(
          destination,
          request.responseState,
          boundary.id,
          boundary.errorDigest,
          boundary.errorMessage,
          boundary.errorComponentStack,
        )
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(
          destination,
          request.responseState,
          segment.formatContext,
          segment.id,
        )
        flushSegment(request, destination, segment)
        return writeEndSegment(destination, segment.formatContext)
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments
        var i = 0
        for (; i < completedSegments.length; i++) {
          var segment = completedSegments[i]
          flushPartiallyCompletedSegment(
            request,
            destination,
            boundary,
            segment,
          )
        }
        completedSegments.length = 0
        return writeCompletedBoundaryInstruction(
          destination,
          request.responseState,
          boundary.id,
          boundary.rootSegmentID,
        )
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments
        var i = 0
        for (; i < completedSegments.length; i++) {
          var segment = completedSegments[i]
          if (
            !flushPartiallyCompletedSegment(
              request,
              destination,
              boundary,
              segment,
            )
          ) {
            i++
            completedSegments.splice(0, i)
            return false
          }
        }
        completedSegments.splice(0, i)
        return true
      }
      function flushPartiallyCompletedSegment(
        request,
        destination,
        boundary,
        segment,
      ) {
        if (segment.status === FLUSHED) {
          return true
        }
        var segmentID = segment.id
        if (segmentID === -1) {
          var rootSegmentID = (segment.id = boundary.rootSegmentID)
          if (rootSegmentID === -1) {
            throw new Error(
              'A root segment ID must have been assigned by now. This is a bug in React.',
            )
          }
          return flushSegmentContainer(request, destination, segment)
        } else {
          flushSegmentContainer(request, destination, segment)
          return writeCompletedSegmentInstruction(
            destination,
            request.responseState,
            segmentID,
          )
        }
      }
      function flushCompletedQueues(request, destination) {
        beginWriting()
        try {
          var completedRootSegment = request.completedRootSegment
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment)
            request.completedRootSegment = null
            writeCompletedRoot(destination, request.responseState)
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries
          var i
          for (i = 0; i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i]
            if (!flushClientRenderedBoundary(request, destination, boundary));
          }
          clientRenderedBoundaries.splice(0, i)
          var completedBoundaries = request.completedBoundaries
          for (i = 0; i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i]
            if (!flushCompletedBoundary(request, destination, _boundary));
          }
          completedBoundaries.splice(0, i)
          completeWriting(destination)
          beginWriting(destination)
          var partialBoundaries = request.partialBoundaries
          for (i = 0; i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i]
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null
              i++
              partialBoundaries.splice(0, i)
              return
            }
          }
          partialBoundaries.splice(0, i)
          var largeBoundaries = request.completedBoundaries
          for (i = 0; i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i]
            if (!flushCompletedBoundary(request, destination, _boundary3));
          }
          largeBoundaries.splice(0, i)
        } finally {
          completeWriting(destination)
          if (
            request.allPendingTasks === 0 &&
            request.pingedTasks.length === 0 &&
            request.clientRenderedBoundaries.length === 0 &&
            request.completedBoundaries.length === 0
          ) {
            {
              if (request.abortableTasks.size !== 0) {
                error(
                  'There was still abortable task at the root when we closed. This is a bug in React.',
                )
              }
            }
            close(destination)
          }
        }
      }
      function startWork(request) {
        scheduleWork(function () {
          return performWork(request)
        })
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED
          closeWithError(destination, request.fatalError)
          return
        }
        if (request.status === CLOSED) {
          return
        }
        if (request.destination !== null) {
          return
        }
        request.destination = destination
        try {
          flushCompletedQueues(request, destination)
        } catch (error2) {
          logRecoverableError(request, error2)
          fatalError(request, error2)
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks
          abortableTasks.forEach(function (task) {
            return abortTask(task, request, reason)
          })
          abortableTasks.clear()
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination)
          }
        } catch (error2) {
          logRecoverableError(request, error2)
          fatalError(request, error2)
        }
      }
      function renderToReadableStream(children, options) {
        return new Promise(function (resolve, reject) {
          var onFatalError
          var onAllReady
          var allReady = new Promise(function (res, rej) {
            onAllReady = res
            onFatalError = rej
          })
          function onShellReady() {
            var stream = new ReadableStream(
              {
                type: 'bytes',
                pull: function (controller) {
                  startFlowing(request, controller)
                },
                cancel: function (reason) {
                  abort(request)
                },
              },
              // $FlowFixMe size() methods are not allowed on byte streams.
              {
                highWaterMark: 0,
              },
            )
            stream.allReady = allReady
            resolve(stream)
          }
          function onShellError(error2) {
            allReady.catch(function () {})
            reject(error2)
          }
          var request = createRequest(
            children,
            createResponseState(
              options ? options.identifierPrefix : void 0,
              options ? options.nonce : void 0,
              options ? options.bootstrapScriptContent : void 0,
              options ? options.bootstrapScripts : void 0,
              options ? options.bootstrapModules : void 0,
            ),
            createRootFormatContext(options ? options.namespaceURI : void 0),
            options ? options.progressiveChunkSize : void 0,
            options ? options.onError : void 0,
            onAllReady,
            onShellReady,
            onShellError,
            onFatalError,
          )
          if (options && options.signal) {
            var signal = options.signal
            var listener = function () {
              abort(request, signal.reason)
              signal.removeEventListener('abort', listener)
            }
            signal.addEventListener('abort', listener)
          }
          startWork(request)
        })
      }
      reactDomServer_browser_development.renderToReadableStream =
        renderToReadableStream
      reactDomServer_browser_development.version = ReactVersion
    })()
  }
  return reactDomServer_browser_development
}
var hasRequiredServer_browser
function requireServer_browser() {
  if (hasRequiredServer_browser) return server_browser
  hasRequiredServer_browser = 1
  var l, s
  if (process.env.NODE_ENV === 'production') {
    l = requireReactDomServerLegacy_browser_production_min()
    s = requireReactDomServer_browser_production_min()
  } else {
    l = requireReactDomServerLegacy_browser_development()
    s = requireReactDomServer_browser_development()
  }
  server_browser.version = l.version
  server_browser.renderToString = l.renderToString
  server_browser.renderToStaticMarkup = l.renderToStaticMarkup
  server_browser.renderToNodeStream = l.renderToNodeStream
  server_browser.renderToStaticNodeStream = l.renderToStaticNodeStream
  server_browser.renderToReadableStream = s.renderToReadableStream
  return server_browser
}
var hasRequiredRenderToMjml
function requireRenderToMjml() {
  if (hasRequiredRenderToMjml) return renderToMjml
  hasRequiredRenderToMjml = 1
  var __importDefault =
    (renderToMjml && renderToMjml.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : {default: mod}
    }
  Object.defineProperty(renderToMjml, '__esModule', {value: true})
  renderToMjml.renderToMjml = void 0
  const server_1 = __importDefault(requireServer_browser())
  function renderToMjml$1(email) {
    return server_1.default.renderToStaticMarkup(email)
  }
  renderToMjml.renderToMjml = renderToMjml$1
  return renderToMjml
}
var renderToMjmlExports = requireRenderToMjml()
const __vite_import_meta_env__ = {
  BASE_URL: '/',
  DEV: false,
  MODE: 'production',
  PROD: true,
  SSR: false,
  VITE_AVOID_UPDATES: 'true',
  VITE_COMMIT_HASH:
    'LOCAL_abcdefghijklmnopqrst0123456789qwertyuiopasdfghjklzxcvbnm',
  VITE_DESKTOP_APPDATA: 'Seed-local',
  VITE_DESKTOP_GRPC_PORT: '58002',
  VITE_DESKTOP_HOSTNAME: 'http://localhost',
  VITE_DESKTOP_HTTP_PORT: '58001',
  VITE_DESKTOP_P2P_PORT: '58000',
  VITE_DESKTOP_SENTRY_DSN:
    'https://8d3089ffb71045dc911bc66efbd3463a@o4504088793841664.ingest.sentry.io/4505527460429824',
  VITE_GATEWAY_URL: 'https://dev.hyper.media',
  VITE_LIGHTNING_API_URL: 'https://ln.testnet.seed.hyper.media',
  VITE_METRIC_SERVER_HTTP_PORT: '58003',
  VITE_SEED_HOST_URL: 'https://host-dev.seed.hyper.media',
  VITE_VERSION: '0.0.0.local',
}
const IME = (() => {
  try {
    if (typeof globalThis !== 'undefined' && 'importMeta' in globalThis) {
      return globalThis.importMeta?.env ?? {}
    }
    if (typeof import.meta !== 'undefined' && __vite_import_meta_env__) {
      return __vite_import_meta_env__
    }
    return {}
  } catch {
    return {}
  }
})()
const WEB_ENV = (() => {
  try {
    return window.ENV || {}
  } catch (e) {
    return {}
  }
})()
const HYPERMEDIA_SCHEME = 'hm'
const DEFAULT_GATEWAY_URL =
  IME.VITE_GATEWAY_URL || process.env.VITE_GATEWAY_URL || 'https://hyper.media'
IME.VITE_DESKTOP_P2P_PORT || process.env.VITE_DESKTOP_P2P_PORT || 56e3
const DAEMON_HTTP_PORT =
  process.env.DAEMON_HTTP_PORT ||
  IME.VITE_DESKTOP_HTTP_PORT ||
  process.env.VITE_DESKTOP_HTTP_PORT ||
  56001
IME.VITE_DESKTOP_GRPC_PORT || process.env.VITE_DESKTOP_GRPC_PORT || 56002
IME.VITE_METRIC_SERVER_HTTP_PORT ||
  process.env.VITE_METRIC_SERVER_HTTP_PORT ||
  56003
const DAEMON_HOSTNAME =
  IME.VITE_DESKTOP_HOSTNAME || process.env.VITE_DESKTOP_HOSTNAME
IME.VITE_DESKTOP_APPDATA || process.env.VITE_DESKTOP_APPDATA || 'Seed'
const VERSION = IME.VITE_VERSION || process.env.VITE_VERSION || '0.0.100-dev'
IME.VITE_COMMIT_HASH ||
  process.env.VITE_COMMIT_HASH ||
  'LOCAL_abcdefghijklmnopqrst0123456789qwertyuiopasdfghjklzxcvbnm'
const IS_PROD_DESKTOP = !!IME.PROD || process.env.NODE_ENV === 'production'
!!IME.VITE_AVOID_UPDATES || process.env.VITE_AVOID_UPDATES == 'true' || false
IS_PROD_DESKTOP && VERSION?.includes('-dev')
process.env.NODE_ENV == 'test'
const DAEMON_HTTP_URL =
  IME.DAEMON_HTTP_URL ||
  process.env.DAEMON_HTTP_URL ||
  `${DAEMON_HOSTNAME || 'http://localhost'}:${DAEMON_HTTP_PORT}`
const DAEMON_FILE_URL = `${DAEMON_HTTP_URL}/ipfs`
const SITE_BASE_URL = WEB_ENV.SITE_BASE_URL || process.env.SEED_BASE_URL
WEB_ENV.LIGHTNING_API_URL ||
  process.env.LIGHTNING_API_URL ||
  IME.VITE_LIGHTNING_API_URL ||
  'https://ln.seed.hyper.media'
IME.VITE_DESKTOP_SENTRY_DSN || process.env.VITE_DESKTOP_SENTRY_DSN
process.env.VITE_SEED_HOST_URL ||
  IME.VITE_SEED_HOST_URL ||
  'http://localhost:5555'
WEB_ENV.SEED_ASSET_HOST || process.env.SEED_ASSET_HOST || IME.SEED_ASSET_HOST
WEB_ENV.WEB_IDENTITY_ORIGIN ||
  process.env.SEED_IDENTITY_DEFAULT_ORIGIN ||
  'https://hyper.media'
WEB_ENV.WEB_IDENTITY_ENABLED || process.env.SEED_IDENTITY_ENABLED !== 'false'
const NOTIFY_SMTP_HOST = process.env.NOTIFY_SMTP_HOST
const NOTIFY_SMTP_PORT = process.env.NOTIFY_SMTP_PORT
const NOTIFY_SMTP_USER = process.env.NOTIFY_SMTP_USER
const NOTIFY_SMTP_PASSWORD = process.env.NOTIFY_SMTP_PASSWORD
const NOTIFY_SENDER = process.env.NOTIFY_SENDER
process.env.SEED_IS_GATEWAY === 'true'
process.env.SEED_API_ENABLED === 'false'
const ENABLE_EMAIL_NOTIFICATIONS =
  WEB_ENV.ENABLE_EMAIL_NOTIFICATIONS ||
  !!(
    NOTIFY_SMTP_HOST &&
    NOTIFY_SMTP_PORT &&
    NOTIFY_SMTP_USER &&
    NOTIFY_SMTP_PASSWORD &&
    NOTIFY_SENDER
  )
WEB_ENV.EMAIL_NOTIFY_HOST ||
  process.env.EMAIL_NOTIFY_HOST ||
  'http://localhost:3060'
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument)
  if (
    argument instanceof Date ||
    (typeof argument === 'object' && argStr === '[object Date]')
  ) {
    return new argument.constructor(+argument)
  } else if (
    typeof argument === 'number' ||
    argStr === '[object Number]' ||
    typeof argument === 'string' ||
    argStr === '[object String]'
  ) {
    return new Date(argument)
  } else {
    return /* @__PURE__ */ new Date(NaN)
  }
}
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value)
  } else {
    return new Date(value)
  }
}
const millisecondsInWeek = 6048e5
const millisecondsInDay = 864e5
let defaultOptions$1 = {}
function getDefaultOptions() {
  return defaultOptions$1
}
function startOfWeek(date, options) {
  const defaultOptions2 = getDefaultOptions()
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions2.weekStartsOn ??
    defaultOptions2.locale?.options?.weekStartsOn ??
    0
  const _date = toDate(date)
  const day = _date.getDay()
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn
  _date.setDate(_date.getDate() - diff)
  _date.setHours(0, 0, 0, 0)
  return _date
}
function startOfISOWeek(date) {
  return startOfWeek(date, {weekStartsOn: 1})
}
function getISOWeekYear(date) {
  const _date = toDate(date)
  const year = _date.getFullYear()
  const fourthOfJanuaryOfNextYear = constructFrom(date, 0)
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4)
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0)
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear)
  const fourthOfJanuaryOfThisYear = constructFrom(date, 0)
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4)
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0)
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear)
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year
  } else {
    return year - 1
  }
}
function startOfDay(date) {
  const _date = toDate(date)
  _date.setHours(0, 0, 0, 0)
  return _date
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date)
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds(),
    ),
  )
  utcDate.setUTCFullYear(_date.getFullYear())
  return +date - +utcDate
}
function differenceInCalendarDays(dateLeft, dateRight) {
  const startOfDayLeft = startOfDay(dateLeft)
  const startOfDayRight = startOfDay(dateRight)
  const timestampLeft =
    +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft)
  const timestampRight =
    +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight)
  return Math.round((timestampLeft - timestampRight) / millisecondsInDay)
}
function startOfISOWeekYear(date) {
  const year = getISOWeekYear(date)
  const fourthOfJanuary = constructFrom(date, 0)
  fourthOfJanuary.setFullYear(year, 0, 4)
  fourthOfJanuary.setHours(0, 0, 0, 0)
  return startOfISOWeek(fourthOfJanuary)
}
function isDate(value) {
  return (
    value instanceof Date ||
    (typeof value === 'object' &&
      Object.prototype.toString.call(value) === '[object Date]')
  )
}
function isValid(date) {
  if (!isDate(date) && typeof date !== 'number') {
    return false
  }
  const _date = toDate(date)
  return !isNaN(Number(_date))
}
function startOfYear(date) {
  const cleanDate = toDate(date)
  const _date = constructFrom(date, 0)
  _date.setFullYear(cleanDate.getFullYear(), 0, 1)
  _date.setHours(0, 0, 0, 0)
  return _date
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds',
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds',
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes',
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes',
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours',
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours',
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days',
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks',
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks',
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months',
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months',
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years',
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years',
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years',
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years',
  },
}
const formatDistance = (token, count, options) => {
  let result
  const tokenValue = formatDistanceLocale[token]
  if (typeof tokenValue === 'string') {
    result = tokenValue
  } else if (count === 1) {
    result = tokenValue.one
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString())
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result
    } else {
      return result + ' ago'
    }
  }
  return result
}
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth
    const format2 = args.formats[width] || args.formats[args.defaultWidth]
    return format2
  }
}
const dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy',
}
const timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a',
}
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}',
}
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full',
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full',
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full',
  }),
}
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P',
}
const formatRelative = (token, _date, _baseDate, _options) =>
  formatRelativeLocale[token]
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : 'standalone'
    let valuesArray
    if (context === 'formatting' && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth
      const width = options?.width ? String(options.width) : defaultWidth
      valuesArray =
        args.formattingValues[width] || args.formattingValues[defaultWidth]
    } else {
      const defaultWidth = args.defaultWidth
      const width = options?.width ? String(options.width) : args.defaultWidth
      valuesArray = args.values[width] || args.values[defaultWidth]
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value
    return valuesArray[index]
  }
}
const eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini'],
}
const quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
}
const monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ],
  wide: [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
  ],
}
const dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: [
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday',
  ],
}
const dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night',
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night',
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night',
  },
}
const formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night',
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night',
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night',
  },
}
const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber)
  const rem100 = number % 100
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st'
      case 2:
        return number + 'nd'
      case 3:
        return number + 'rd'
    }
  }
  return number + 'th'
}
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide',
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: (quarter) => quarter - 1,
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide',
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide',
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide',
  }),
}
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width
    const matchPattern =
      (width && args.matchPatterns[width]) ||
      args.matchPatterns[args.defaultMatchWidth]
    const matchResult = string.match(matchPattern)
    if (!matchResult) {
      return null
    }
    const matchedString = matchResult[0]
    const parsePatterns =
      (width && args.parsePatterns[width]) ||
      args.parsePatterns[args.defaultParseWidth]
    const key = Array.isArray(parsePatterns)
      ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString))
      : // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    let value
    value = args.valueCallback ? args.valueCallback(key) : key
    value = options.valueCallback
      ? // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        options.valueCallback(value)
      : value
    const rest = string.slice(matchedString.length)
    return {value, rest}
  }
}
function findKey(object, predicate) {
  for (const key in object) {
    if (
      Object.prototype.hasOwnProperty.call(object, key) &&
      predicate(object[key])
    ) {
      return key
    }
  }
  return void 0
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key
    }
  }
  return void 0
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern)
    if (!matchResult) return null
    const matchedString = matchResult[0]
    const parseResult = string.match(args.parsePattern)
    if (!parseResult) return null
    let value = args.valueCallback
      ? args.valueCallback(parseResult[0])
      : parseResult[0]
    value = options.valueCallback ? options.valueCallback(value) : value
    const rest = string.slice(matchedString.length)
    return {value, rest}
  }
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i
const parseOrdinalNumberPattern = /\d+/i
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i,
}
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i],
}
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i,
}
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i],
}
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
}
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i,
  ],
}
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
}
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
}
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
}
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i,
  },
}
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10),
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any',
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: (index) => index + 1,
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any',
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any',
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any',
  }),
}
const enUS = {
  code: 'en-US',
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1,
  },
}
function getDayOfYear(date) {
  const _date = toDate(date)
  const diff = differenceInCalendarDays(_date, startOfYear(_date))
  const dayOfYear = diff + 1
  return dayOfYear
}
function getISOWeek(date) {
  const _date = toDate(date)
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date)
  return Math.round(diff / millisecondsInWeek) + 1
}
function getWeekYear(date, options) {
  const _date = toDate(date)
  const year = _date.getFullYear()
  const defaultOptions2 = getDefaultOptions()
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions2.firstWeekContainsDate ??
    defaultOptions2.locale?.options?.firstWeekContainsDate ??
    1
  const firstWeekOfNextYear = constructFrom(date, 0)
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate)
  firstWeekOfNextYear.setHours(0, 0, 0, 0)
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options)
  const firstWeekOfThisYear = constructFrom(date, 0)
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate)
  firstWeekOfThisYear.setHours(0, 0, 0, 0)
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options)
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year
  } else {
    return year - 1
  }
}
function startOfWeekYear(date, options) {
  const defaultOptions2 = getDefaultOptions()
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions2.firstWeekContainsDate ??
    defaultOptions2.locale?.options?.firstWeekContainsDate ??
    1
  const year = getWeekYear(date, options)
  const firstWeek = constructFrom(date, 0)
  firstWeek.setFullYear(year, 0, firstWeekContainsDate)
  firstWeek.setHours(0, 0, 0, 0)
  const _date = startOfWeek(firstWeek, options)
  return _date
}
function getWeek(date, options) {
  const _date = toDate(date)
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options)
  return Math.round(diff / millisecondsInWeek) + 1
}
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? '-' : ''
  const output = Math.abs(number).toString().padStart(targetLength, '0')
  return sign + output
}
const lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear()
    const year = signedYear > 0 ? signedYear : 1 - signedYear
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length)
  },
  // Month
  M(date, token) {
    const month = date.getMonth()
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2)
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length)
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? 'pm' : 'am'
    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase()
      case 'aaa':
        return dayPeriodEnumValue
      case 'aaaaa':
        return dayPeriodEnumValue[0]
      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.'
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length)
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length)
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length)
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length)
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length
    const milliseconds = date.getMilliseconds()
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3),
    )
    return addLeadingZeros(fractionalSeconds, token.length)
  },
}
const dayPeriodEnum = {
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night',
}
const formatters = {
  // Era
  G: function (date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0
    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize2.era(era, {width: 'abbreviated'})
      // A, B
      case 'GGGGG':
        return localize2.era(era, {width: 'narrow'})
      // Anno Domini, Before Christ
      case 'GGGG':
      default:
        return localize2.era(era, {width: 'wide'})
    }
  },
  // Year
  y: function (date, token, localize2) {
    if (token === 'yo') {
      const signedYear = date.getFullYear()
      const year = signedYear > 0 ? signedYear : 1 - signedYear
      return localize2.ordinalNumber(year, {unit: 'year'})
    }
    return lightFormatters.y(date, token)
  },
  // Local week-numbering year
  Y: function (date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options)
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear
    if (token === 'YY') {
      const twoDigitYear = weekYear % 100
      return addLeadingZeros(twoDigitYear, 2)
    }
    if (token === 'Yo') {
      return localize2.ordinalNumber(weekYear, {unit: 'year'})
    }
    return addLeadingZeros(weekYear, token.length)
  },
  // ISO week-numbering year
  R: function (date, token) {
    const isoWeekYear = getISOWeekYear(date)
    return addLeadingZeros(isoWeekYear, token.length)
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    const year = date.getFullYear()
    return addLeadingZeros(year, token.length)
  },
  // Quarter
  Q: function (date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3)
    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter)
      // 01, 02, 03, 04
      case 'QQ':
        return addLeadingZeros(quarter, 2)
      // 1st, 2nd, 3rd, 4th
      case 'Qo':
        return localize2.ordinalNumber(quarter, {unit: 'quarter'})
      // Q1, Q2, Q3, Q4
      case 'QQQ':
        return localize2.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting',
        })
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case 'QQQQQ':
        return localize2.quarter(quarter, {
          width: 'narrow',
          context: 'formatting',
        })
      // 1st quarter, 2nd quarter, ...
      case 'QQQQ':
      default:
        return localize2.quarter(quarter, {
          width: 'wide',
          context: 'formatting',
        })
    }
  },
  // Stand-alone quarter
  q: function (date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3)
    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter)
      // 01, 02, 03, 04
      case 'qq':
        return addLeadingZeros(quarter, 2)
      // 1st, 2nd, 3rd, 4th
      case 'qo':
        return localize2.ordinalNumber(quarter, {unit: 'quarter'})
      // Q1, Q2, Q3, Q4
      case 'qqq':
        return localize2.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone',
        })
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case 'qqqqq':
        return localize2.quarter(quarter, {
          width: 'narrow',
          context: 'standalone',
        })
      // 1st quarter, 2nd quarter, ...
      case 'qqqq':
      default:
        return localize2.quarter(quarter, {
          width: 'wide',
          context: 'standalone',
        })
    }
  },
  // Month
  M: function (date, token, localize2) {
    const month = date.getMonth()
    switch (token) {
      case 'M':
      case 'MM':
        return lightFormatters.M(date, token)
      // 1st, 2nd, ..., 12th
      case 'Mo':
        return localize2.ordinalNumber(month + 1, {unit: 'month'})
      // Jan, Feb, ..., Dec
      case 'MMM':
        return localize2.month(month, {
          width: 'abbreviated',
          context: 'formatting',
        })
      // J, F, ..., D
      case 'MMMMM':
        return localize2.month(month, {
          width: 'narrow',
          context: 'formatting',
        })
      // January, February, ..., December
      case 'MMMM':
      default:
        return localize2.month(month, {width: 'wide', context: 'formatting'})
    }
  },
  // Stand-alone month
  L: function (date, token, localize2) {
    const month = date.getMonth()
    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1)
      // 01, 02, ..., 12
      case 'LL':
        return addLeadingZeros(month + 1, 2)
      // 1st, 2nd, ..., 12th
      case 'Lo':
        return localize2.ordinalNumber(month + 1, {unit: 'month'})
      // Jan, Feb, ..., Dec
      case 'LLL':
        return localize2.month(month, {
          width: 'abbreviated',
          context: 'standalone',
        })
      // J, F, ..., D
      case 'LLLLL':
        return localize2.month(month, {
          width: 'narrow',
          context: 'standalone',
        })
      // January, February, ..., December
      case 'LLLL':
      default:
        return localize2.month(month, {width: 'wide', context: 'standalone'})
    }
  },
  // Local week of year
  w: function (date, token, localize2, options) {
    const week = getWeek(date, options)
    if (token === 'wo') {
      return localize2.ordinalNumber(week, {unit: 'week'})
    }
    return addLeadingZeros(week, token.length)
  },
  // ISO week of year
  I: function (date, token, localize2) {
    const isoWeek = getISOWeek(date)
    if (token === 'Io') {
      return localize2.ordinalNumber(isoWeek, {unit: 'week'})
    }
    return addLeadingZeros(isoWeek, token.length)
  },
  // Day of the month
  d: function (date, token, localize2) {
    if (token === 'do') {
      return localize2.ordinalNumber(date.getDate(), {unit: 'date'})
    }
    return lightFormatters.d(date, token)
  },
  // Day of year
  D: function (date, token, localize2) {
    const dayOfYear = getDayOfYear(date)
    if (token === 'Do') {
      return localize2.ordinalNumber(dayOfYear, {unit: 'dayOfYear'})
    }
    return addLeadingZeros(dayOfYear, token.length)
  },
  // Day of week
  E: function (date, token, localize2) {
    const dayOfWeek = date.getDay()
    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize2.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting',
        })
      // T
      case 'EEEEE':
        return localize2.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting',
        })
      // Tu
      case 'EEEEEE':
        return localize2.day(dayOfWeek, {
          width: 'short',
          context: 'formatting',
        })
      // Tuesday
      case 'EEEE':
      default:
        return localize2.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting',
        })
    }
  },
  // Local day of week
  e: function (date, token, localize2, options) {
    const dayOfWeek = date.getDay()
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek)
      // Padded numerical value
      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2)
      // 1st, 2nd, ..., 7th
      case 'eo':
        return localize2.ordinalNumber(localDayOfWeek, {unit: 'day'})
      case 'eee':
        return localize2.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting',
        })
      // T
      case 'eeeee':
        return localize2.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting',
        })
      // Tu
      case 'eeeeee':
        return localize2.day(dayOfWeek, {
          width: 'short',
          context: 'formatting',
        })
      // Tuesday
      case 'eeee':
      default:
        return localize2.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting',
        })
    }
  },
  // Stand-alone local day of week
  c: function (date, token, localize2, options) {
    const dayOfWeek = date.getDay()
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7
    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek)
      // Padded numerical value
      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length)
      // 1st, 2nd, ..., 7th
      case 'co':
        return localize2.ordinalNumber(localDayOfWeek, {unit: 'day'})
      case 'ccc':
        return localize2.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone',
        })
      // T
      case 'ccccc':
        return localize2.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone',
        })
      // Tu
      case 'cccccc':
        return localize2.day(dayOfWeek, {
          width: 'short',
          context: 'standalone',
        })
      // Tuesday
      case 'cccc':
      default:
        return localize2.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone',
        })
    }
  },
  // ISO day of week
  i: function (date, token, localize2) {
    const dayOfWeek = date.getDay()
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek
    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek)
      // 02
      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length)
      // 2nd
      case 'io':
        return localize2.ordinalNumber(isoDayOfWeek, {unit: 'day'})
      // Tue
      case 'iii':
        return localize2.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting',
        })
      // T
      case 'iiiii':
        return localize2.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting',
        })
      // Tu
      case 'iiiiii':
        return localize2.day(dayOfWeek, {
          width: 'short',
          context: 'formatting',
        })
      // Tuesday
      case 'iiii':
      default:
        return localize2.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting',
        })
    }
  },
  // AM or PM
  a: function (date, token, localize2) {
    const hours = date.getHours()
    const dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am'
    switch (token) {
      case 'a':
      case 'aa':
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting',
        })
      case 'aaa':
        return localize2
          .dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting',
          })
          .toLowerCase()
      case 'aaaaa':
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting',
        })
      case 'aaaa':
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting',
        })
    }
  },
  // AM, PM, midnight, noon
  b: function (date, token, localize2) {
    const hours = date.getHours()
    let dayPeriodEnumValue
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am'
    }
    switch (token) {
      case 'b':
      case 'bb':
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting',
        })
      case 'bbb':
        return localize2
          .dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting',
          })
          .toLowerCase()
      case 'bbbbb':
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting',
        })
      case 'bbbb':
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting',
        })
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize2) {
    const hours = date.getHours()
    let dayPeriodEnumValue
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night
    }
    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting',
        })
      case 'BBBBB':
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting',
        })
      case 'BBBB':
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting',
        })
    }
  },
  // Hour [1-12]
  h: function (date, token, localize2) {
    if (token === 'ho') {
      let hours = date.getHours() % 12
      if (hours === 0) hours = 12
      return localize2.ordinalNumber(hours, {unit: 'hour'})
    }
    return lightFormatters.h(date, token)
  },
  // Hour [0-23]
  H: function (date, token, localize2) {
    if (token === 'Ho') {
      return localize2.ordinalNumber(date.getHours(), {unit: 'hour'})
    }
    return lightFormatters.H(date, token)
  },
  // Hour [0-11]
  K: function (date, token, localize2) {
    const hours = date.getHours() % 12
    if (token === 'Ko') {
      return localize2.ordinalNumber(hours, {unit: 'hour'})
    }
    return addLeadingZeros(hours, token.length)
  },
  // Hour [1-24]
  k: function (date, token, localize2) {
    let hours = date.getHours()
    if (hours === 0) hours = 24
    if (token === 'ko') {
      return localize2.ordinalNumber(hours, {unit: 'hour'})
    }
    return addLeadingZeros(hours, token.length)
  },
  // Minute
  m: function (date, token, localize2) {
    if (token === 'mo') {
      return localize2.ordinalNumber(date.getMinutes(), {unit: 'minute'})
    }
    return lightFormatters.m(date, token)
  },
  // Second
  s: function (date, token, localize2) {
    if (token === 'so') {
      return localize2.ordinalNumber(date.getSeconds(), {unit: 'second'})
    }
    return lightFormatters.s(date, token)
  },
  // Fraction of second
  S: function (date, token) {
    return lightFormatters.S(date, token)
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset()
    if (timezoneOffset === 0) {
      return 'Z'
    }
    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset)
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case 'XXXX':
      case 'XX':
        return formatTimezone(timezoneOffset)
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case 'XXXXX':
      case 'XXX':
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ':')
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset()
    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset)
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case 'xxxx':
      case 'xx':
        return formatTimezone(timezoneOffset)
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case 'xxxxx':
      case 'xxx':
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ':')
    }
  },
  // Timezone (GMT)
  O: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset()
    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':')
      // Long
      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':')
    }
  },
  // Timezone (specific non-location)
  z: function (date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset()
    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':')
      // Long
      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':')
    }
  },
  // Seconds timestamp
  t: function (date, token, _localize) {
    const timestamp = Math.trunc(date.getTime() / 1e3)
    return addLeadingZeros(timestamp, token.length)
  },
  // Milliseconds timestamp
  T: function (date, token, _localize) {
    const timestamp = date.getTime()
    return addLeadingZeros(timestamp, token.length)
  },
}
function formatTimezoneShort(offset, delimiter = '') {
  const sign = offset > 0 ? '-' : '+'
  const absOffset = Math.abs(offset)
  const hours = Math.trunc(absOffset / 60)
  const minutes = absOffset % 60
  if (minutes === 0) {
    return sign + String(hours)
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2)
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? '-' : '+'
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2)
  }
  return formatTimezone(offset, delimiter)
}
function formatTimezone(offset, delimiter = '') {
  const sign = offset > 0 ? '-' : '+'
  const absOffset = Math.abs(offset)
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2)
  const minutes = addLeadingZeros(absOffset % 60, 2)
  return sign + hours + delimiter + minutes
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case 'P':
      return formatLong2.date({width: 'short'})
    case 'PP':
      return formatLong2.date({width: 'medium'})
    case 'PPP':
      return formatLong2.date({width: 'long'})
    case 'PPPP':
    default:
      return formatLong2.date({width: 'full'})
  }
}
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case 'p':
      return formatLong2.time({width: 'short'})
    case 'pp':
      return formatLong2.time({width: 'medium'})
    case 'ppp':
      return formatLong2.time({width: 'long'})
    case 'pppp':
    default:
      return formatLong2.time({width: 'full'})
  }
}
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || []
  const datePattern = matchResult[1]
  const timePattern = matchResult[2]
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2)
  }
  let dateTimeFormat
  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong2.dateTime({width: 'short'})
      break
    case 'PP':
      dateTimeFormat = formatLong2.dateTime({width: 'medium'})
      break
    case 'PPP':
      dateTimeFormat = formatLong2.dateTime({width: 'long'})
      break
    case 'PPPP':
    default:
      dateTimeFormat = formatLong2.dateTime({width: 'full'})
      break
  }
  return dateTimeFormat
    .replace('{{date}}', dateLongFormatter(datePattern, formatLong2))
    .replace('{{time}}', timeLongFormatter(timePattern, formatLong2))
}
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter,
}
const dayOfYearTokenRE = /^D+$/
const weekYearTokenRE = /^Y+$/
const throwTokens = ['D', 'DD', 'YY', 'YYYY']
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token)
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token)
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input)
  console.warn(_message)
  if (throwTokens.includes(token)) throw new RangeError(_message)
}
function message(token, format2, input) {
  const subject = token[0] === 'Y' ? 'years' : 'days of the month'
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const formattingTokensRegExp =
  /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
const escapedStringRegExp = /^'([^]*?)'?$/
const doubleQuoteRegExp = /''/g
const unescapedLatinCharacterRegExp = /[a-zA-Z]/
function format(date, formatStr, options) {
  const defaultOptions2 = getDefaultOptions()
  const locale = defaultOptions2.locale ?? enUS
  const firstWeekContainsDate =
    defaultOptions2.firstWeekContainsDate ??
    defaultOptions2.locale?.options?.firstWeekContainsDate ??
    1
  const weekStartsOn =
    defaultOptions2.weekStartsOn ??
    defaultOptions2.locale?.options?.weekStartsOn ??
    0
  const originalDate = toDate(date)
  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value')
  }
  let parts = formatStr
    .match(longFormattingTokensRegExp)
    .map((substring) => {
      const firstCharacter = substring[0]
      if (firstCharacter === 'p' || firstCharacter === 'P') {
        const longFormatter = longFormatters[firstCharacter]
        return longFormatter(substring, locale.formatLong)
      }
      return substring
    })
    .join('')
    .match(formattingTokensRegExp)
    .map((substring) => {
      if (substring === "''") {
        return {isToken: false, value: "'"}
      }
      const firstCharacter = substring[0]
      if (firstCharacter === "'") {
        return {isToken: false, value: cleanEscapedString(substring)}
      }
      if (formatters[firstCharacter]) {
        return {isToken: true, value: substring}
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          'Format string contains an unescaped latin alphabet character `' +
            firstCharacter +
            '`',
        )
      }
      return {isToken: false, value: substring}
    })
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts)
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale,
  }
  return parts
    .map((part) => {
      if (!part.isToken) return part.value
      const token = part.value
      if (isProtectedWeekYearToken(token) || isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, String(date))
      }
      const formatter = formatters[token[0]]
      return formatter(originalDate, token, locale.localize, formatterOptions)
    })
    .join('')
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp)
  if (!matched) {
    return input
  }
  return matched[1].replace(doubleQuoteRegExp, "'")
}
const ExactBlockRangeSchema = z.object({
  start: z.number(),
  end: z.number(),
})
const ExpandedBlockRangeSchema = z.object({
  expanded: z.boolean(),
})
const BlockRangeSchema = z.union([
  ExactBlockRangeSchema,
  ExpandedBlockRangeSchema,
])
const unpackedHmIdSchema = z.object({
  id: z.string(),
  uid: z.string(),
  path: z.array(z.string()).nullable(),
  version: z.string().nullable(),
  blockRef: z.string().nullable(),
  blockRange: BlockRangeSchema.nullable(),
  hostname: z.string().nullable(),
  scheme: z.string().nullable(),
  latest: z.boolean().nullable().optional(),
  // deprecated:
  targetDocUid: z.string().nullable().optional(),
  targetDocPath: z.array(z.string()).nullable().optional(),
})
const HMBlockChildrenTypeSchema = z
  .union([
    z.literal('Group'),
    z.literal('Ordered'),
    z.literal('Unordered'),
    z.literal('Blockquote'),
  ])
  .nullable()
const HMEmbedViewSchema = z.union([
  z.literal('Content'),
  z.literal('Card'),
  z.literal('Comments'),
])
const HMQueryStyleSchema = z.union([z.literal('Card'), z.literal('List')])
const baseAnnotationProperties = {
  starts: z.array(z.number()),
  ends: z.array(z.number()),
  attributes: z.object({}).optional(),
  link: z.literal('').optional(),
}
const BoldAnnotationSchema = z
  .object({
    type: z.literal('Bold'),
    ...baseAnnotationProperties,
  })
  .strict()
const ItalicAnnotationSchema = z
  .object({
    type: z.literal('Italic'),
    ...baseAnnotationProperties,
  })
  .strict()
const UnderlineAnnotationSchema = z
  .object({
    type: z.literal('Underline'),
    ...baseAnnotationProperties,
  })
  .strict()
const StrikeAnnotationSchema = z
  .object({
    type: z.literal('Strike'),
    ...baseAnnotationProperties,
  })
  .strict()
const CodeAnnotationSchema = z
  .object({
    type: z.literal('Code'),
    ...baseAnnotationProperties,
  })
  .strict()
const LinkAnnotationSchema = z
  .object({
    type: z.literal('Link'),
    ...baseAnnotationProperties,
    link: z.string().optional(),
    // this should be required but we have seen some data that is missing it
  })
  .strict()
const InlineEmbedAnnotationSchema = z
  .object({
    type: z.literal('Embed'),
    ...baseAnnotationProperties,
    link: z.string(),
  })
  .strict()
const HighlightAnnotationSchema = z
  .object({
    type: z.literal('Range'),
    ...baseAnnotationProperties,
  })
  .strict()
const HMAnnotationSchema = z.discriminatedUnion('type', [
  BoldAnnotationSchema,
  ItalicAnnotationSchema,
  UnderlineAnnotationSchema,
  StrikeAnnotationSchema,
  CodeAnnotationSchema,
  LinkAnnotationSchema,
  InlineEmbedAnnotationSchema,
  HighlightAnnotationSchema,
])
const HMAnnotationsSchema = z.array(HMAnnotationSchema).optional()
const blockBaseProperties = {
  id: z.string(),
  revision: z.string().optional(),
  attributes: z.object({}).optional().default({}),
  // EMPTY ATTRIBUTES, override in specific block schemas
  annotations: z.array(z.never()).optional(),
  // EMPTY ANNOTATIONS, override in specific block schemas
  text: z.literal('').optional(),
  // EMPTY TEXT, override in specific block schemas
  link: z.literal('').optional(),
  // EMPTY LINK, override in specific block schemas
}
const textBlockProperties = {
  text: z.string().default(''),
  annotations: HMAnnotationsSchema,
}
const parentBlockAttributes = {
  childrenType: HMBlockChildrenTypeSchema.optional(),
}
const HMBlockParagraphSchema = z
  .object({
    type: z.literal('Paragraph'),
    ...blockBaseProperties,
    ...textBlockProperties,
    attributes: z.object(parentBlockAttributes).optional().default({}),
  })
  .strict()
const HMBlockHeadingSchema = z
  .object({
    type: z.literal('Heading'),
    ...blockBaseProperties,
    ...textBlockProperties,
    attributes: z.object(parentBlockAttributes).optional().default({}),
  })
  .strict()
const HMBlockCodeSchema = z
  .object({
    type: z.literal('Code'),
    ...blockBaseProperties,
    attributes: z
      .object({
        ...parentBlockAttributes,
        language: z.string().optional(),
      })
      .optional()
      .default({}),
    text: z.string().default(''),
  })
  .strict()
const HMBlockMathSchema = z
  .object({
    type: z.literal('Math'),
    ...blockBaseProperties,
    attributes: z.object(parentBlockAttributes).optional().default({}),
    text: z.string().default(''),
  })
  .strict()
function toNumber(value) {
  if (typeof value == 'number' && !isNaN(value)) {
    return value
  }
  if (typeof value == 'string') {
    const converted = Number(value)
    if (!isNaN(converted)) {
      return converted
    }
  }
  console.warn(
    'Value must be a number or a string that can be converted to a number',
    value,
  )
  return null
}
const HMBlockImageSchema = z
  .object({
    type: z.literal('Image'),
    ...blockBaseProperties,
    ...textBlockProperties,
    attributes: z
      .object({
        ...parentBlockAttributes,
        width: z.number().optional(),
        name: z.string().optional(),
      })
      .optional()
      .default({}),
    link: z.string(),
  })
  .strict()
const HMBlockVideoSchema = z
  .object({
    type: z.literal('Video'),
    ...blockBaseProperties,
    attributes: z
      .object({
        ...parentBlockAttributes,
        width: z.number().optional(),
        name: z.string().optional(),
      })
      .optional()
      .default({}),
    link: z.string(),
  })
  .strict()
const HMBlockFileSchema = z
  .object({
    type: z.literal('File'),
    ...blockBaseProperties,
    attributes: z
      .object({
        ...parentBlockAttributes,
        size: z.number().optional().transform(toNumber),
        // number of bytes, as a string
        name: z.string().optional(),
      })
      .optional()
      .default({}),
    link: z.string(),
  })
  .strict()
const HMBlockButtonAlignmentSchema = z
  .union([z.literal('flex-start'), z.literal('center'), z.literal('flex-end')])
  .optional()
const HMBlockButtonSchema = z
  .object({
    type: z.literal('Button'),
    ...blockBaseProperties,
    attributes: z
      .object({
        ...parentBlockAttributes,
        name: z.string().optional(),
        alignment: HMBlockButtonAlignmentSchema,
      })
      .optional()
      .default({}),
    text: z.string().optional(),
    link: z.string(),
  })
  .strict()
const HMBlockEmbedSchema = z
  .object({
    type: z.literal('Embed'),
    ...blockBaseProperties,
    link: z.string(),
    // should be a hm:// URL
    attributes: z
      .object({
        ...parentBlockAttributes,
        view: HMEmbedViewSchema.optional(),
      })
      .optional()
      .default({}),
  })
  .strict()
const HMBlockWebEmbedSchema = z
  .object({
    type: z.literal('WebEmbed'),
    ...blockBaseProperties,
    link: z.string(),
    // should be a HTTP(S) URL
  })
  .strict()
const HMBlockNostrSchema = z
  .object({
    type: z.literal('Nostr'),
    ...blockBaseProperties,
    link: z.string(),
    // should be a nostr:// URL
  })
  .strict()
const HMTimestampSchema = z
  .object({
    seconds: z.bigint().or(z.number()),
    nanos: z.number(),
  })
  .strict()
  .or(z.string())
const HMBlockNodeSchema = z.lazy(() =>
  z.object({
    children: z.array(HMBlockNodeSchema).optional(),
    block: HMBlockSchema,
  }),
)
const HMDocumentMetadataSchema = z.object({
  name: z.string().optional(),
  summary: z.string().optional(),
  icon: z.string().optional(),
  thumbnail: z.string().optional(),
  // DEPRECATED
  cover: z.string().optional(),
  siteUrl: z.string().optional(),
  layout: z
    .union([z.literal('Seed/Experimental/Newspaper'), z.literal('')])
    .optional(),
  displayPublishTime: z.string().optional(),
  seedExperimentalLogo: z.string().optional(),
  seedExperimentalHomeOrder: z
    .union([z.literal('UpdatedFirst'), z.literal('CreatedFirst')])
    .optional(),
  showOutline: z.boolean().optional(),
  showActivity: z.boolean().optional(),
  contentWidth: z
    .union([z.literal('S'), z.literal('M'), z.literal('L')])
    .optional(),
  theme: z
    .object({
      headerLayout: z.union([z.literal('Center'), z.literal('')]).optional(),
    })
    .optional(),
})
z.object({
  blocks: z.array(HMBlockNodeSchema),
})
const HMNavigationItemSchema = z.object({
  type: z.literal('Link'),
  id: z.string(),
  text: z.string(),
  link: z.string(),
})
z.object({
  content: z.array(z.any()),
  // EditorBlock validation is handled elsewhere
  deps: z.array(z.string().min(1)).default([]),
  navigation: z.array(HMNavigationItemSchema).optional(),
})
const HMCommentSchema = z.object({
  id: z.string(),
  version: z.string(),
  author: z.string(),
  targetAccount: z.string(),
  targetPath: z.string().optional(),
  targetVersion: z.string(),
  replyParent: z.string().optional(),
  threadRoot: z.string().optional(),
  threadRootVersion: z.string().optional(),
  capability: z.string().optional(),
  content: z.array(HMBlockNodeSchema),
  createTime: HMTimestampSchema,
  updateTime: HMTimestampSchema,
})
const HMDraftMetaSchema = z.object({
  id: z.string(),
  locationUid: z.string().optional(),
  locationPath: z.array(z.string()).optional(),
  editUid: z.string().optional(),
  editPath: z.array(z.string()).optional(),
  metadata: HMDocumentMetadataSchema,
})
HMDraftMetaSchema.extend({
  lastUpdateTime: z.number(),
})
const HMMetadataPayloadSchema = z
  .object({
    id: unpackedHmIdSchema,
    metadata: HMDocumentMetadataSchema.or(z.null()),
  })
  .strict()
const HMAccountsMetadataSchema = z.record(
  z.string(),
  // account uid
  HMMetadataPayloadSchema,
)
const HMLoadedTextContentNodeSchema = z
  .object({
    type: z.literal('Text'),
    text: z.string(),
    bold: z.boolean().optional(),
    italic: z.boolean().optional(),
    underline: z.boolean().optional(),
    strike: z.boolean().optional(),
    code: z.boolean().optional(),
  })
  .strict()
const HMLoadedLinkNodeSchema = z
  .object({
    type: z.literal('Link'),
    link: z.string(),
    content: z.array(HMLoadedTextContentNodeSchema),
  })
  .strict()
const HMLoadedInlineEmbedNodeSchema = z
  .object({
    type: z.literal('InlineEmbed'),
    ref: z.string(),
    id: z.union([z.custom(), z.null()]),
    text: z.string().nullable(),
  })
  .strict()
const HMLoadedTextSchema = z.array(
  z.discriminatedUnion('type', [
    HMLoadedTextContentNodeSchema,
    HMLoadedInlineEmbedNodeSchema,
    HMLoadedLinkNodeSchema,
  ]),
)
const HMLoadedParagraphSchema = z
  .object({
    type: z.literal('Paragraph'),
    id: z.string(),
    content: HMLoadedTextSchema,
  })
  .strict()
const HMLoadedHeadingSchema = z
  .object({
    type: z.literal('Heading'),
    id: z.string(),
    content: HMLoadedTextSchema,
  })
  .strict()
const HMLoadedVideoSchema = z
  .object({
    type: z.literal('Video'),
    id: z.string(),
    link: z.string(),
    name: z.string().optional(),
    width: z.number().optional(),
  })
  .strict()
const HMLoadedFileSchema = z
  .object({
    type: z.literal('File'),
    id: z.string(),
    link: z.string(),
    name: z.string().optional(),
    size: z.number().nullable(),
  })
  .strict()
const HMLoadedImageSchema = z
  .object({
    type: z.literal('Image'),
    id: z.string(),
    link: z.string(),
    name: z.string().optional(),
    width: z.number().optional(),
  })
  .strict()
const HMLoadedEmbedSchema = z
  .object({
    type: z.literal('Embed'),
    id: z.string(),
    link: z.string(),
    view: z.union([z.literal('Content'), z.literal('Card')]).optional(),
    authors: HMAccountsMetadataSchema,
    updateTime: HMTimestampSchema.nullable(),
    metadata: HMDocumentMetadataSchema.nullable(),
    content: z.array(z.lazy(() => HMLoadedBlockNodeSchema)).nullable(),
  })
  .strict()
const HMQueryInclusionSchema = z.object({
  space: z.string(),
  path: z.string().optional(),
  mode: z.union([z.literal('Children'), z.literal('AllDescendants')]),
})
const HMQuerySortSchema = z.object({
  reverse: z.boolean().default(false),
  term: z.union([
    z.literal('Path'),
    z.literal('Title'),
    z.literal('CreateTime'),
    z.literal('UpdateTime'),
    z.literal('DisplayTime'),
  ]),
})
const HMQuerySchema = z.object({
  includes: z.array(HMQueryInclusionSchema),
  sort: z.array(HMQuerySortSchema).optional(),
  limit: z.number().optional(),
})
const HMLoadedQueryBlockResultSchema = z.object({
  type: z.literal('document'),
  path: z.array(z.string()),
  metadata: HMDocumentMetadataSchema.nullable(),
  account: z.string(),
  version: z.string(),
  createTime: HMTimestampSchema.optional(),
  updateTime: HMTimestampSchema.optional(),
  genesis: z.string(),
  authors: HMAccountsMetadataSchema,
  breadcrumbs: z.any(),
  // todo
  activitySummary: z.any(),
})
const HMLoadedQuerySchema = z.object({
  type: z.literal('Query'),
  id: z.string(),
  query: HMQuerySchema,
  results: z.array(HMLoadedQueryBlockResultSchema).nullable(),
})
const HMLoadedBlockSchema = z.discriminatedUnion('type', [
  HMLoadedParagraphSchema,
  HMLoadedHeadingSchema,
  HMLoadedEmbedSchema,
  HMLoadedVideoSchema,
  HMLoadedFileSchema,
  HMLoadedImageSchema,
  HMLoadedQuerySchema,
  z.object({type: z.literal('Unsupported'), id: z.string()}).strict(),
])
const HMLoadedBlockNodeSchema = z.lazy(() =>
  z
    .object({
      block: HMLoadedBlockSchema,
      children: z.array(z.lazy(() => HMLoadedBlockNodeSchema)),
      childrenType: HMBlockChildrenTypeSchema.optional(),
    })
    .strict(),
)
z.object({
  id: z.custom(),
  version: z.string(),
  content: z.array(HMLoadedBlockNodeSchema),
  metadata: HMDocumentMetadataSchema,
  authors: HMAccountsMetadataSchema,
}).strict()
const HMBlockQuerySchema = z
  .object({
    type: z.literal('Query'),
    ...blockBaseProperties,
    attributes: z.object({
      ...parentBlockAttributes,
      style: HMQueryStyleSchema.optional().default('Card'),
      columnCount: z.number().optional().default(3),
      query: HMQuerySchema,
      banner: z.boolean().optional().default(false),
    }),
  })
  .strict()
const HMBlockGroupSchema = z.object({
  type: z.literal('Group'),
  id: z.string(),
})
const HMBlockLinkSchema = z.object({
  type: z.literal('Link'),
  id: z.string(),
  link: z.string().optional(),
  text: z.string(),
})
const HMBlockSchema = z.discriminatedUnion('type', [
  HMBlockParagraphSchema,
  HMBlockHeadingSchema,
  HMBlockCodeSchema,
  HMBlockMathSchema,
  HMBlockImageSchema,
  HMBlockVideoSchema,
  HMBlockFileSchema,
  HMBlockButtonSchema,
  HMBlockEmbedSchema,
  HMBlockWebEmbedSchema,
  HMBlockNostrSchema,
  HMBlockQuerySchema,
  HMBlockGroupSchema,
  HMBlockLinkSchema,
])
const HMDocumentSchema = z.object({
  content: z.array(HMBlockNodeSchema).default([]),
  version: z.string().default(''),
  account: z.string().default(''),
  authors: z.array(z.string()),
  path: z.string().default(''),
  createTime: z.union([HMTimestampSchema, z.string()]).default(''),
  updateTime: z.union([HMTimestampSchema, z.string()]).default(''),
  metadata: HMDocumentMetadataSchema,
  detachedBlocks: z.record(z.string(), HMBlockNodeSchema).optional(),
  genesis: z.string(),
})
const HMResourceDocumentSchema = z.object({
  type: z.literal('document'),
  document: HMDocumentSchema,
  id: unpackedHmIdSchema,
})
const HMResourceCommentSchema = z.object({
  type: z.literal('comment'),
  comment: HMCommentSchema,
  id: unpackedHmIdSchema,
})
const HMResourceRedirectSchema = z.object({
  type: z.literal('redirect'),
  id: unpackedHmIdSchema,
  redirectTarget: unpackedHmIdSchema,
})
const HMResourceNotFoundSchema = z.object({
  type: z.literal('not-found'),
  id: unpackedHmIdSchema,
})
z.discriminatedUnion('type', [
  HMResourceDocumentSchema,
  HMResourceCommentSchema,
  HMResourceRedirectSchema,
  HMResourceNotFoundSchema,
])
z.discriminatedUnion('type', [
  HMResourceDocumentSchema,
  HMResourceCommentSchema,
])
z.object({
  accountId: z.string(),
  secretToken: z.string(),
  addrInfo: z.object({
    peerId: z.string(),
    addrs: z.array(z.string()),
  }),
})
const ParsedFragmentSchema = z.discriminatedUnion('type', [
  ExpandedBlockRangeSchema.extend({
    type: z.literal('block'),
    blockId: z.string(),
  }),
  ExactBlockRangeSchema.extend({
    type: z.literal('block-range'),
    blockId: z.string(),
  }),
])
const HMCitationCommentSourceSchema = z.object({
  type: z.literal('c'),
  id: unpackedHmIdSchema,
  author: z.string().optional(),
  time: HMTimestampSchema.optional(),
})
const HMCitationDocumentSourceSchema = z.object({
  type: z.literal('d'),
  id: unpackedHmIdSchema,
  author: z.string().optional(),
  time: HMTimestampSchema.optional(),
})
z.object({
  source: z.discriminatedUnion('type', [
    HMCitationCommentSourceSchema,
    HMCitationDocumentSourceSchema,
  ]),
  isExactVersion: z.boolean(),
  targetFragment: ParsedFragmentSchema.nullable(),
  targetId: unpackedHmIdSchema,
})
z.object({
  a: z.array(z.string()),
  // addrs
  d: z.string(),
  // peer/device ID
})
z.object({
  uid: z.string(),
  path: z.array(z.string()),
  version: z.string().optional(),
  media: z.boolean().optional(),
})
var SortAttribute = /* @__PURE__ */ ((SortAttribute2) => {
  SortAttribute2[(SortAttribute2['ACTIVITY_TIME'] = 0)] = 'ACTIVITY_TIME'
  SortAttribute2[(SortAttribute2['NAME'] = 1)] = 'NAME'
  SortAttribute2[(SortAttribute2['PATH'] = 2)] = 'PATH'
  return SortAttribute2
})(SortAttribute || {})
proto3.util.setEnumType(
  SortAttribute,
  'com.seed.documents.v3alpha.SortAttribute',
  [
    {no: 0, name: 'ACTIVITY_TIME'},
    {no: 1, name: 'NAME'},
    {no: 2, name: 'PATH'},
  ],
)
class GetDocumentRequest extends Message {
  /**
   * Required. The ID of the account where the document is located.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the document.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Optional. Exact version of the document to retrieve.
   * Empty version means "latest".
   *
   * @generated from field: string version = 3;
   */
  version = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetDocumentRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetDocumentRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetDocumentRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetDocumentRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetDocumentRequest, a, b)
  }
}
class RedirectErrorDetails extends Message {
  /**
   * Account ID where the redirect points to.
   *
   * @generated from field: string target_account = 1;
   */
  targetAccount = ''
  /**
   * Path of the target document within the target account.
   *
   * @generated from field: string target_path = 2;
   */
  targetPath = ''
  /**
   * Optional. If true, the redirect is a republishing redirect.
   *
   * @generated from field: bool republish = 3;
   */
  republish = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.RedirectErrorDetails'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'target_account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'target_path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'republish',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new RedirectErrorDetails().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new RedirectErrorDetails().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new RedirectErrorDetails().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(RedirectErrorDetails, a, b)
  }
}
class GetDocumentInfoRequest extends Message {
  /**
   * Required. Account ID where the document is located.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the document.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetDocumentInfoRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetDocumentInfoRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetDocumentInfoRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetDocumentInfoRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetDocumentInfoRequest, a, b)
  }
}
class BatchGetDocumentInfoRequest extends Message {
  /**
   * @generated from field: repeated com.seed.documents.v3alpha.GetDocumentInfoRequest requests = 1;
   */
  requests = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.BatchGetDocumentInfoRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'requests',
      kind: 'message',
      T: GetDocumentInfoRequest,
      repeated: true,
    },
  ])
  static fromBinary(bytes, options) {
    return new BatchGetDocumentInfoRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new BatchGetDocumentInfoRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new BatchGetDocumentInfoRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(BatchGetDocumentInfoRequest, a, b)
  }
}
class BatchGetDocumentInfoResponse extends Message {
  /**
   * @generated from field: repeated com.seed.documents.v3alpha.DocumentInfo documents = 1;
   */
  documents = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.BatchGetDocumentInfoResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'documents',
      kind: 'message',
      T: DocumentInfo,
      repeated: true,
    },
  ])
  static fromBinary(bytes, options) {
    return new BatchGetDocumentInfoResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new BatchGetDocumentInfoResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new BatchGetDocumentInfoResponse().fromJsonString(
      jsonString,
      options,
    )
  }
  static equals(a, b) {
    return proto3.util.equals(BatchGetDocumentInfoResponse, a, b)
  }
}
class CreateDocumentChangeRequest extends Message {
  /**
   * Required. The ID of the account where the document is located.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the document to create change for.
   * If document doesn't exist it will be created.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Required. Version of the document to apply changes to.
   * Can be empty when creating a new document.
   *
   * @generated from field: string base_version = 3;
   */
  baseVersion = ''
  /**
   * Required. Changes to be applied to the document.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.DocumentChange changes = 4;
   */
  changes = []
  /**
   * Required. Name of the key to use for signing.
   * Use the Daemon API to list and manage keys.
   *
   * @generated from field: string signing_key_name = 5;
   */
  signingKeyName = ''
  /**
   * Optional. ID of the capability that allows signing key to write on behalf of the account
   * for this particular path.
   *
   * @generated from field: string capability = 6;
   */
  capability = ''
  /**
   * Optional. Timestamp that the change should have.
   * By default current time is used.
   * The timestamp must be strictly greater than the timestamp of any other Change in the dependency chain.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 7;
   */
  timestamp
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.CreateDocumentChangeRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'base_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'changes',
      kind: 'message',
      T: DocumentChange,
      repeated: true,
    },
    {
      no: 5,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'capability',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 7, name: 'timestamp', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new CreateDocumentChangeRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateDocumentChangeRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateDocumentChangeRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(CreateDocumentChangeRequest, a, b)
  }
}
class DeleteDocumentRequest extends Message {
  /**
   * Required. ID of the account to delete the document from.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the document to delete.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DeleteDocumentRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DeleteDocumentRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DeleteDocumentRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DeleteDocumentRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DeleteDocumentRequest, a, b)
  }
}
class ListRootDocumentsRequest extends Message {
  /**
   * Optional. Number of results per page. Default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0
  /**
   * Optional. Value from next_page_token obtained from a previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListRootDocumentsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListRootDocumentsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListRootDocumentsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListRootDocumentsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListRootDocumentsRequest, a, b)
  }
}
class ListRootDocumentsResponse extends Message {
  /**
   * List of root documents.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.DocumentInfo documents = 1;
   */
  documents = []
  /**
   * Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListRootDocumentsResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'documents',
      kind: 'message',
      T: DocumentInfo,
      repeated: true,
    },
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListRootDocumentsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListRootDocumentsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListRootDocumentsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListRootDocumentsResponse, a, b)
  }
}
class ListAccountsRequest extends Message {
  /**
   * Optional. Number of results to return per page.
   * If not set, the server will pick some default number.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0
  /**
   * Optional. Token of the page to request, obtained from
   * a previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = ''
  /**
   * Optional. If set to true, only accounts that the user is subscribed to will be returned.
   * If at least one document in the account has a subscription, then the account is considered subscribed.
   *
   * @generated from field: bool subscribed_only = 3;
   */
  subscribedOnly = false
  /**
   * Optional. Configuration for sorting the response.
   * If not specified, the default sorting is by activity time in descending order.
   *
   * @generated from field: com.seed.documents.v3alpha.SortOptions sort_options = 4;
   */
  sortOptions
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListAccountsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'subscribed_only',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {no: 4, name: 'sort_options', kind: 'message', T: SortOptions},
  ])
  static fromBinary(bytes, options) {
    return new ListAccountsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListAccountsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListAccountsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListAccountsRequest, a, b)
  }
}
class ListAccountsResponse extends Message {
  /**
   * List of accounts.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.Account accounts = 1;
   */
  accounts = []
  /**
   * Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListAccountsResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'accounts', kind: 'message', T: Account, repeated: true},
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListAccountsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListAccountsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListAccountsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListAccountsResponse, a, b)
  }
}
class GetAccountRequest extends Message {
  /**
   * Required. ID of the account to retrieve.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetAccountRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetAccountRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetAccountRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetAccountRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetAccountRequest, a, b)
  }
}
class BatchGetAccountsRequest extends Message {
  /**
   * Required. List of account IDs to retrieve.
   *
   * @generated from field: repeated string ids = 1;
   */
  ids = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.BatchGetAccountsRequest'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'ids', kind: 'scalar', T: 9, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new BatchGetAccountsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new BatchGetAccountsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new BatchGetAccountsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(BatchGetAccountsRequest, a, b)
  }
}
class BatchGetAccountsResponse extends Message {
  /**
   * Accounts that were successfully retrieved,
   * keyed by account ID.
   *
   * @generated from field: map<string, com.seed.documents.v3alpha.Account> accounts = 1;
   */
  accounts = {}
  /**
   * Errors (if any) that occurred while retrieving accounts,
   * keyed by account ID.
   * The value of the map is a serialized gRPC Status message.
   * It's not used as a concrete type here because it's exposed in a very accessible way,
   * but every gRPC client library has a defined type for the Status message.
   * See https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto,
   * and https://grpc.io/docs/guides/status-codes.
   *
   * @generated from field: map<string, bytes> errors = 2;
   */
  errors = {}
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.BatchGetAccountsResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'accounts',
      kind: 'map',
      K: 9,
      V: {kind: 'message', T: Account},
    },
    {
      no: 2,
      name: 'errors',
      kind: 'map',
      K: 9,
      V: {
        kind: 'scalar',
        T: 12,
        /* ScalarType.BYTES */
      },
    },
  ])
  static fromBinary(bytes, options) {
    return new BatchGetAccountsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new BatchGetAccountsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new BatchGetAccountsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(BatchGetAccountsResponse, a, b)
  }
}
class UpdateProfileRequest extends Message {
  /**
   * Required. ID of the account to update the profile for.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. The updated profile data.
   *
   * @generated from field: com.seed.documents.v3alpha.Profile profile = 2;
   */
  profile
  /**
   * Required. Name of the key to use for signing the profile.
   *
   * @generated from field: string signing_key_name = 3;
   */
  signingKeyName = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.UpdateProfileRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 2, name: 'profile', kind: 'message', T: Profile},
    {
      no: 3,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new UpdateProfileRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UpdateProfileRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UpdateProfileRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(UpdateProfileRequest, a, b)
  }
}
class Account extends Message {
  /**
   * ID of the account.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Metadata attributes from the root document of this account's Space.
   *
   * @generated from field: google.protobuf.Struct metadata = 2;
   */
  metadata
  /**
   * Summary of the activity in the entire account.
   *
   * @generated from field: com.seed.documents.v3alpha.ActivitySummary activity_summary = 3;
   */
  activitySummary
  /**
   * Whether the user is subscribed to this account.
   * If at least one document in the account has a subscription, then the account is considered subscribed.
   *
   * @generated from field: bool is_subscribed = 4;
   */
  isSubscribed = false
  /**
   * Optional. ID of another Account this account claims to act on behalf of.
   * If this is present all the other fields should be ignored.
   * It's up to the caller to follow the alias and get the actual account data.
   *
   * @generated from field: string alias_account = 5;
   */
  aliasAccount = ''
  /**
   * Optional. Profile information about the account.
   * Can be missing if there's no Profile blob for this account.
   *
   * @generated from field: com.seed.documents.v3alpha.Profile profile = 6;
   */
  profile
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Account'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 2, name: 'metadata', kind: 'message', T: Struct},
    {no: 3, name: 'activity_summary', kind: 'message', T: ActivitySummary},
    {
      no: 4,
      name: 'is_subscribed',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 5,
      name: 'alias_account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 6, name: 'profile', kind: 'message', T: Profile},
  ])
  static fromBinary(bytes, options) {
    return new Account().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Account().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Account().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Account, a, b)
  }
}
class Profile extends Message {
  /**
   * Display name of the account.
   *
   * @generated from field: string name = 1;
   */
  name = ''
  /**
   * URI for the icon/avatar.
   *
   * @generated from field: string icon = 2;
   */
  icon = ''
  /**
   * Optional short description text.
   *
   * @generated from field: string description = 3;
   */
  description = ''
  /**
   * Output only. Time when the profile was updated.
   * This field is set by the server, and is ignored in update requests from the client.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 4;
   */
  updateTime
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Profile'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'icon',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'description',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 4, name: 'update_time', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new Profile().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Profile().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Profile().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Profile, a, b)
  }
}
class CreateAliasRequest extends Message {
  /**
   * Required. Key to use for signing the alias.
   *
   * @generated from field: string signing_key_name = 1;
   */
  signingKeyName = ''
  /**
   * Required. ID of the target (alias) account.
   *
   * @generated from field: string alias_account = 2;
   */
  aliasAccount = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.CreateAliasRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'alias_account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new CreateAliasRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateAliasRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateAliasRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(CreateAliasRequest, a, b)
  }
}
class CreateContactRequest extends Message {
  /**
   * Required. ID of the account to create the contact for.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Name of the key to use for signing.
   *
   * @generated from field: string signing_key_name = 2;
   */
  signingKeyName = ''
  /**
   * Required. Account ID about which we are issuing the contact record.
   *
   * @generated from field: string subject = 3;
   */
  subject = ''
  /**
   * Required. Name that we know the subject by.
   *
   * @generated from field: string name = 4;
   */
  name = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.CreateContactRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'subject',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new CreateContactRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateContactRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateContactRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(CreateContactRequest, a, b)
  }
}
class GetContactRequest extends Message {
  /**
   * Required. ID of the contact to retrieve.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetContactRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetContactRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetContactRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetContactRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetContactRequest, a, b)
  }
}
class UpdateContactRequest extends Message {
  /**
   * Required. Full snapshot of the updated contact record.
   * Clients should update objects received from GetContact or CreateContact calls.
   * The server will ignore output-only fields like timestamps.
   *
   * @generated from field: com.seed.documents.v3alpha.Contact contact = 1;
   */
  contact
  /**
   * Required. Name of the key to use for signing the contact update.
   *
   * @generated from field: string signing_key_name = 2;
   */
  signingKeyName = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.UpdateContactRequest'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'contact', kind: 'message', T: Contact},
    {
      no: 2,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new UpdateContactRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UpdateContactRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UpdateContactRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(UpdateContactRequest, a, b)
  }
}
class DeleteContactRequest extends Message {
  /**
   * Required. ID of the contact within the account.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Required. Name of the key to use for signing the contact deletion.
   *
   * @generated from field: string signing_key_name = 2;
   */
  signingKeyName = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DeleteContactRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DeleteContactRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DeleteContactRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DeleteContactRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DeleteContactRequest, a, b)
  }
}
class ListContactsRequest extends Message {
  /**
   * Optional. Number of results per page. Default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0
  /**
   * Optional. Value from next_page_token obtained from a previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = ''
  /**
   * Required. Filter for listing contacts.
   *
   * @generated from oneof com.seed.documents.v3alpha.ListContactsRequest.filter
   */
  filter = {case: void 0}
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListContactsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'account', kind: 'scalar', T: 9, oneof: 'filter'},
    {no: 4, name: 'subject', kind: 'scalar', T: 9, oneof: 'filter'},
  ])
  static fromBinary(bytes, options) {
    return new ListContactsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListContactsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListContactsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListContactsRequest, a, b)
  }
}
class ListContactsResponse extends Message {
  /**
   * List of contacts.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.Contact contacts = 1;
   */
  contacts = []
  /**
   * Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListContactsResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'contacts', kind: 'message', T: Contact, repeated: true},
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListContactsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListContactsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListContactsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListContactsResponse, a, b)
  }
}
class Contact extends Message {
  /**
   * ID of the contact.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Subject is the account that's being described by the contact record.
   *
   * @generated from field: string subject = 2;
   */
  subject = ''
  /**
   * Name is the public name of the contact that we know them by.
   *
   * @generated from field: string name = 3;
   */
  name = ''
  /**
   * Time when the contact was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime
  /**
   * Time when the contact was updated.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 5;
   */
  updateTime
  /**
   * Account ID that issued this contact.
   *
   * @generated from field: string account = 6;
   */
  account = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Contact'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'subject',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 4, name: 'create_time', kind: 'message', T: Timestamp},
    {no: 5, name: 'update_time', kind: 'message', T: Timestamp},
    {
      no: 6,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new Contact().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Contact().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Contact().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Contact, a, b)
  }
}
class ListDirectoryRequest extends Message {
  /**
   * Optional. Size of the page.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0
  /**
   * Optional. Pagination token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = ''
  /**
   * Required. ID of the account to list the directory for.
   *
   * @generated from field: string account = 3;
   */
  account = ''
  /**
   * Required. Path of the directory to list documents for.
   * Empty string means root directory.
   *
   * @generated from field: string directory_path = 4;
   */
  directoryPath = ''
  /**
   * Optional. If true, list documents recursively.
   *
   * @generated from field: bool recursive = 5;
   */
  recursive = false
  /**
   * Optional. If set to true, only documents that the user is subscribed to will be returned.
   *
   * @generated from field: bool subscribed_only = 6;
   */
  subscribedOnly = false
  /**
   * Optional. Configuration for sorting.
   * If not specified, the default sorting is by activity time in descending order.
   *
   * @generated from field: com.seed.documents.v3alpha.SortOptions sort_options = 7;
   */
  sortOptions
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListDirectoryRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'directory_path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'recursive',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: 'subscribed_only',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {no: 7, name: 'sort_options', kind: 'message', T: SortOptions},
  ])
  static fromBinary(bytes, options) {
    return new ListDirectoryRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListDirectoryRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListDirectoryRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListDirectoryRequest, a, b)
  }
}
class SortOptions extends Message {
  /**
   * Attributes by which the list can be sorted.
   *
   * @generated from field: com.seed.documents.v3alpha.SortAttribute attribute = 1;
   */
  attribute = 0
  /**
   * By default sort is ascending (smaller values first).
   * This field can be specified to choose the opposing sorting.
   *
   * @generated from field: bool descending = 2;
   */
  descending = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.SortOptions'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'attribute',
      kind: 'enum',
      T: proto3.getEnumType(SortAttribute),
    },
    {
      no: 2,
      name: 'descending',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new SortOptions().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new SortOptions().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new SortOptions().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(SortOptions, a, b)
  }
}
class ListDirectoryResponse extends Message {
  /**
   * List of documents.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.DocumentInfo documents = 1;
   */
  documents = []
  /**
   * Optional. Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListDirectoryResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'documents',
      kind: 'message',
      T: DocumentInfo,
      repeated: true,
    },
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListDirectoryResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListDirectoryResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListDirectoryResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListDirectoryResponse, a, b)
  }
}
class ListDocumentsRequest extends Message {
  /**
   * Optional. ID of the account to list documents for.
   * If not specified, all documents are listed.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Optional. Number of results per page. Default is defined by the server.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0
  /**
   * Optional. Value from next_page_token obtained from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListDocumentsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListDocumentsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListDocumentsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListDocumentsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListDocumentsRequest, a, b)
  }
}
class ListDocumentsResponse extends Message {
  /**
   * List of documents.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.DocumentInfo documents = 1;
   */
  documents = []
  /**
   * Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListDocumentsResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'documents',
      kind: 'message',
      T: DocumentInfo,
      repeated: true,
    },
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListDocumentsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListDocumentsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListDocumentsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListDocumentsResponse, a, b)
  }
}
class ListDocumentChangesRequest extends Message {
  /**
   * Required. ID of the account to list versions for.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the document to list versions for.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Required. Version of the document to list changes for.
   *
   * @generated from field: string version = 3;
   */
  version = ''
  /**
   * Optional. Number of results per page. Default is defined by the server.
   *
   * @generated from field: int32 page_size = 4;
   */
  pageSize = 0
  /**
   * Optional. Value from next_page_token obtained from a previous response.
   *
   * @generated from field: string page_token = 5;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListDocumentChangesRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 5,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListDocumentChangesRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListDocumentChangesRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListDocumentChangesRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListDocumentChangesRequest, a, b)
  }
}
class ListDocumentChangesResponse extends Message {
  /**
   * List of document versions.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.DocumentChangeInfo changes = 1;
   */
  changes = []
  /**
   * Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListDocumentChangesResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'changes',
      kind: 'message',
      T: DocumentChangeInfo,
      repeated: true,
    },
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListDocumentChangesResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListDocumentChangesResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListDocumentChangesResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListDocumentChangesResponse, a, b)
  }
}
class GetDocumentChangeRequest extends Message {
  /**
   * Required. ID of the change to retrieve.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetDocumentChangeRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetDocumentChangeRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetDocumentChangeRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetDocumentChangeRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetDocumentChangeRequest, a, b)
  }
}
class UpdateDocumentReadStatusRequest extends Message {
  /**
   * Required. ID of the account to update the document in.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the document to update.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Required. New read status of the document.
   *
   * @generated from field: bool is_read = 3;
   */
  isRead = false
  /**
   * Optional. Whether the status should be updated recursively for children of the path.
   *
   * @generated from field: bool is_recursive = 4;
   */
  isRecursive = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.UpdateDocumentReadStatusRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'is_read',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 4,
      name: 'is_recursive',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new UpdateDocumentReadStatusRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UpdateDocumentReadStatusRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UpdateDocumentReadStatusRequest().fromJsonString(
      jsonString,
      options,
    )
  }
  static equals(a, b) {
    return proto3.util.equals(UpdateDocumentReadStatusRequest, a, b)
  }
}
class CreateRefRequest extends Message {
  /**
   * Required. The ID of the account/space in which to create the Ref.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the new Ref.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Required. Target for the new Ref.
   *
   * @generated from field: com.seed.documents.v3alpha.RefTarget target = 3;
   */
  target
  /**
   * Required. Name of the signing key to use for signing the Ref.
   *
   * @generated from field: string signing_key_name = 4;
   */
  signingKeyName = ''
  /**
   * Optional. ID of the Capability blob that grants the necessary rights to the signin key
   * to write Refs for the requested account + path.
   *
   * @generated from field: string capability = 5;
   */
  capability = ''
  /**
   * Optional. A timestamp of the Ref blob.
   * If not specified the server will use the current time.
   * The provided timestamp will be rounded to the nearest millisecond,
   * so the final timestamp in the resulting Ref blob may not be exactly as provided.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 6;
   */
  timestamp
  /**
   * Optional. The generation number for the Ref.
   * If not specified, the server will use the generation number of the most recent generation,
   * or will create a fresh generation number if there are no existing Refs for this path.
   *
   * @generated from field: int64 generation = 7;
   */
  generation = protoInt64.zero
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.CreateRefRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'target', kind: 'message', T: RefTarget},
    {
      no: 4,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'capability',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 6, name: 'timestamp', kind: 'message', T: Timestamp},
    {
      no: 7,
      name: 'generation',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
  ])
  static fromBinary(bytes, options) {
    return new CreateRefRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateRefRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateRefRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(CreateRefRequest, a, b)
  }
}
class GetRefRequest extends Message {
  /**
   * Required. ID of the Ref blob to retrieve.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetRefRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetRefRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetRefRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetRefRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetRefRequest, a, b)
  }
}
class DocumentChangeInfo extends Message {
  /**
   * CID of the change.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Author of the change.
   *
   * @generated from field: string author = 2;
   */
  author = ''
  /**
   * List of change IDs that this change depends on.
   *
   * @generated from field: repeated string deps = 3;
   */
  deps = []
  /**
   * Time when the change was created (as claimed by the author).
   *
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DocumentChangeInfo'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'author',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'deps', kind: 'scalar', T: 9, repeated: true},
    {no: 4, name: 'create_time', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new DocumentChangeInfo().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DocumentChangeInfo().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DocumentChangeInfo().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DocumentChangeInfo, a, b)
  }
}
class DocumentInfo extends Message {
  /**
   * Account to which the document belongs.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Path of the document within the account.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * User-defined metadata attributes of the document.
   *
   * @generated from field: google.protobuf.Struct metadata = 3;
   */
  metadata
  /**
   * Every author ID who has ever made changes to this document.
   *
   * @generated from field: repeated string authors = 4;
   */
  authors = []
  /**
   * Time when the document was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 5;
   */
  createTime
  /**
   * Time when the document was updated.
   * I.e. timestamp of the most recent change.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 6;
   */
  updateTime
  /**
   * ID of the genesis change of this document.
   *
   * @generated from field: string genesis = 8;
   */
  genesis = ''
  /**
   * Current version of the document.
   *
   * @generated from field: string version = 9;
   */
  version = ''
  /**
   * Breadcrumbs of this document.
   * The number of items in this list corresponds to the number of segments
   * in the path of the document minus 1 (the document itself).
   *
   * E.g. for a document "/cars/jp/honda" there will be 2 breadcrumbs: "cars" and "jp".
   *
   * If we don't have a document for some of the path segements for whatever reason,
   * the corresponding breadcrumb segment will be null.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.Breadcrumb breadcrumbs = 10;
   */
  breadcrumbs = []
  /**
   * Summary of the activity on the document.
   *
   * @generated from field: com.seed.documents.v3alpha.ActivitySummary activity_summary = 11;
   */
  activitySummary
  /**
   * Information about the generation of the document.
   *
   * @generated from field: com.seed.documents.v3alpha.GenerationInfo generation_info = 12;
   */
  generationInfo
  /**
   * Output only. Redirect information if the document is a republish or a redirect.
   *
   * @generated from field: com.seed.documents.v3alpha.RefTarget.Redirect redirect_info = 13;
   */
  redirectInfo
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DocumentInfo'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'metadata', kind: 'message', T: Struct},
    {no: 4, name: 'authors', kind: 'scalar', T: 9, repeated: true},
    {no: 5, name: 'create_time', kind: 'message', T: Timestamp},
    {no: 6, name: 'update_time', kind: 'message', T: Timestamp},
    {
      no: 8,
      name: 'genesis',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: 'breadcrumbs',
      kind: 'message',
      T: Breadcrumb,
      repeated: true,
    },
    {no: 11, name: 'activity_summary', kind: 'message', T: ActivitySummary},
    {no: 12, name: 'generation_info', kind: 'message', T: GenerationInfo},
    {no: 13, name: 'redirect_info', kind: 'message', T: RefTarget_Redirect},
  ])
  static fromBinary(bytes, options) {
    return new DocumentInfo().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DocumentInfo().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DocumentInfo().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DocumentInfo, a, b)
  }
}
class GenerationInfo extends Message {
  /**
   * CID of the genesis change.
   *
   * @generated from field: string genesis = 1;
   */
  genesis = ''
  /**
   * A generation number of the document.
   * Usually it's a timestamp of the first time the generation is created,
   * but it shouldn't be used as such, and should instead be treated as an opaque value.
   *
   * @generated from field: int64 generation = 2;
   */
  generation = protoInt64.zero
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GenerationInfo'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'genesis',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'generation',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
  ])
  static fromBinary(bytes, options) {
    return new GenerationInfo().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GenerationInfo().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GenerationInfo().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GenerationInfo, a, b)
  }
}
class ActivitySummary extends Message {
  /**
   * Timestamp of the most recent comment.
   *
   * @generated from field: google.protobuf.Timestamp latest_comment_time = 1;
   */
  latestCommentTime
  /**
   * ID of the most recent comment.
   *
   * @generated from field: string latest_comment_id = 4;
   */
  latestCommentId = ''
  /**
   * Total number of comments.
   *
   * @generated from field: int32 comment_count = 2;
   */
  commentCount = 0
  /**
   * Timestamp of the most recent change.
   *
   * @generated from field: google.protobuf.Timestamp latest_change_time = 3;
   */
  latestChangeTime
  /**
   * Whether there's any unread activity on this document/account.
   *
   * @generated from field: bool is_unread = 5;
   */
  isUnread = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ActivitySummary'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'latest_comment_time', kind: 'message', T: Timestamp},
    {
      no: 4,
      name: 'latest_comment_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'comment_count',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {no: 3, name: 'latest_change_time', kind: 'message', T: Timestamp},
    {
      no: 5,
      name: 'is_unread',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new ActivitySummary().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ActivitySummary().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ActivitySummary().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ActivitySummary, a, b)
  }
}
class Breadcrumb extends Message {
  /**
   * Title of the document.
   *
   * @generated from field: string name = 1;
   */
  name = ''
  /**
   * Path of the document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Will be true if we don't have any indexed information about this document.
   *
   * @generated from field: bool is_missing = 3;
   */
  isMissing = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Breadcrumb'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'is_missing',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new Breadcrumb().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Breadcrumb().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Breadcrumb().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Breadcrumb, a, b)
  }
}
class Document extends Message {
  /**
   * Account to which the document belongs.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Path of the document within the account.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Metadata values for a document.
   *
   * @generated from field: google.protobuf.Struct metadata = 3;
   */
  metadata
  /**
   * Output only. Every account ID who has modified the document.
   * Includes the original author as well.
   *
   * @generated from field: repeated string authors = 5;
   */
  authors = []
  /**
   * Blocks content of the document.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.BlockNode content = 6;
   */
  content = []
  /**
   * Output only. Blocks that were created but not moved into the document content.
   *
   * @generated from field: map<string, com.seed.documents.v3alpha.BlockNode> detached_blocks = 14;
   */
  detachedBlocks = {}
  /**
   * Output only. Time when document was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 7;
   */
  createTime
  /**
   * Output only. Time when document was updated.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 8;
   */
  updateTime
  /**
   * Output only. ID of the genesis change of this document.
   *
   * @generated from field: string genesis = 9;
   */
  genesis = ''
  /**
   * Output only. Current version of the document.
   *
   * @generated from field: string version = 10;
   */
  version = ''
  /**
   * Output only. Information about the generation of the document.
   *
   * @generated from field: com.seed.documents.v3alpha.GenerationInfo generation_info = 13;
   */
  generationInfo
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Document'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'metadata', kind: 'message', T: Struct},
    {no: 5, name: 'authors', kind: 'scalar', T: 9, repeated: true},
    {no: 6, name: 'content', kind: 'message', T: BlockNode, repeated: true},
    {
      no: 14,
      name: 'detached_blocks',
      kind: 'map',
      K: 9,
      V: {kind: 'message', T: BlockNode},
    },
    {no: 7, name: 'create_time', kind: 'message', T: Timestamp},
    {no: 8, name: 'update_time', kind: 'message', T: Timestamp},
    {
      no: 9,
      name: 'genesis',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 13, name: 'generation_info', kind: 'message', T: GenerationInfo},
  ])
  static fromBinary(bytes, options) {
    return new Document().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Document().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Document().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Document, a, b)
  }
}
class BlockNode extends Message {
  /**
   * Content block.
   *
   * @generated from field: com.seed.documents.v3alpha.Block block = 1;
   */
  block
  /**
   * Child blocks.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.BlockNode children = 2;
   */
  children = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.BlockNode'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'block', kind: 'message', T: Block},
    {no: 2, name: 'children', kind: 'message', T: BlockNode, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new BlockNode().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new BlockNode().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new BlockNode().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(BlockNode, a, b)
  }
}
class Block extends Message {
  /**
   * Block ID. Must be unique within the document.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Type of the block. Specific to the renderer.
   *
   * @generated from field: string type = 2;
   */
  type = ''
  /**
   * Text of the content block.
   *
   * @generated from field: string text = 3;
   */
  text = ''
  /**
   * Optional. The hyperlink to an external resource.
   * Must be a valid URL.
   *
   * @generated from field: string link = 7;
   */
  link = ''
  /**
   * Remaining type-specific attribtues of the block.
   * Logically, these attributes are on the same level as the other fields,
   * i.e. the field `attributes` should not exist,
   * but because protobuf doesn't support arbitrary fields, and we don't want/need
   * to specify the types of all the possible fields, we use this approach of storing
   * the rest of the fields in this open-ended attributes map.
   * The side-effect of this is that `attributes` map must not have any keys
   * that conflict with the names of the top-level fields.
   *
   * @generated from field: google.protobuf.Struct attributes = 4;
   */
  attributes
  /**
   * Annotation "layers" of the block.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.Annotation annotations = 5;
   */
  annotations = []
  /**
   * Output only. Current revision of the block. It's the ID of the last Change that modified this block.
   * Additional information about the Change can be obtained using the Changes service.
   *
   * @generated from field: string revision = 6;
   */
  revision = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Block'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'text',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'link',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 4, name: 'attributes', kind: 'message', T: Struct},
    {
      no: 5,
      name: 'annotations',
      kind: 'message',
      T: Annotation,
      repeated: true,
    },
    {
      no: 6,
      name: 'revision',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new Block().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Block().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Block().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Block, a, b)
  }
}
class Annotation extends Message {
  /**
   * Type of the annotation.
   *
   * @generated from field: string type = 1;
   */
  type = ''
  /**
   * Optional. A hyperlink to an external resource.
   * Must be a valid URL.
   *
   * @generated from field: string link = 5;
   */
  link = ''
  /**
   * Arbitrary key-value attributes of the annotation.
   *
   * @generated from field: google.protobuf.Struct attributes = 2;
   */
  attributes
  /**
   * Start offsets of possibly disjoint spans of text for which this annotation is applied.
   * Must be sorted and have the same number of items as `ends` list.
   *
   * @generated from field: repeated int32 starts = 3;
   */
  starts = []
  /**
   * End offsets of possibly disjoint spans of text for which this annotation is applied.
   * Must be sorted and have the same number of items as `starts` list.
   *
   * @generated from field: repeated int32 ends = 4;
   */
  ends = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Annotation'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'link',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 2, name: 'attributes', kind: 'message', T: Struct},
    {no: 3, name: 'starts', kind: 'scalar', T: 5, repeated: true},
    {no: 4, name: 'ends', kind: 'scalar', T: 5, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new Annotation().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Annotation().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Annotation().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Annotation, a, b)
  }
}
class DocumentChange extends Message {
  /**
   * @generated from oneof com.seed.documents.v3alpha.DocumentChange.op
   */
  op = {case: void 0}
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DocumentChange'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'set_metadata',
      kind: 'message',
      T: DocumentChange_SetMetadata,
      oneof: 'op',
    },
    {
      no: 2,
      name: 'move_block',
      kind: 'message',
      T: DocumentChange_MoveBlock,
      oneof: 'op',
    },
    {no: 3, name: 'replace_block', kind: 'message', T: Block, oneof: 'op'},
    {no: 4, name: 'delete_block', kind: 'scalar', T: 9, oneof: 'op'},
    {
      no: 5,
      name: 'set_attribute',
      kind: 'message',
      T: DocumentChange_SetAttribute,
      oneof: 'op',
    },
  ])
  static fromBinary(bytes, options) {
    return new DocumentChange().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DocumentChange().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DocumentChange().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DocumentChange, a, b)
  }
}
class DocumentChange_MoveBlock extends Message {
  /**
   * ID of the block to move.
   *
   * @generated from field: string block_id = 1;
   */
  blockId = ''
  /**
   * ID of the new parent for the block being moved.
   *
   * @generated from field: string parent = 2;
   */
  parent = ''
  /**
   * ID of the new left sibling for the block being moved.
   *
   * @generated from field: string left_sibling = 3;
   */
  leftSibling = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DocumentChange.MoveBlock'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'block_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'parent',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'left_sibling',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DocumentChange_MoveBlock().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DocumentChange_MoveBlock().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DocumentChange_MoveBlock().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DocumentChange_MoveBlock, a, b)
  }
}
class DocumentChange_SetMetadata extends Message {
  /**
   * Metadata key to set.
   *
   * @generated from field: string key = 1;
   */
  key = ''
  /**
   * Metadata value to set.
   *
   * @generated from field: string value = 2;
   */
  value = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DocumentChange.SetMetadata'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'key',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'value',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DocumentChange_SetMetadata().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DocumentChange_SetMetadata().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DocumentChange_SetMetadata().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DocumentChange_SetMetadata, a, b)
  }
}
class DocumentChange_SetAttribute extends Message {
  /**
   * ID of the block to set the attribute on.
   *
   * Empty string means the document itself.
   * Special strings "footer" and "header" can be used to set attributes on the document footer and header blocks.
   *
   * @generated from field: string block_id = 1;
   */
  blockId = ''
  /**
   * A path of keys to set the value for.
   * It's a list to support nested attributes.
   *
   * @generated from field: repeated string key = 2;
   */
  key = []
  /**
   * Value to set.
   *
   * @generated from oneof com.seed.documents.v3alpha.DocumentChange.SetAttribute.value
   */
  value = {case: void 0}
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DocumentChange.SetAttribute'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'block_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 2, name: 'key', kind: 'scalar', T: 9, repeated: true},
    {no: 3, name: 'string_value', kind: 'scalar', T: 9, oneof: 'value'},
    {no: 4, name: 'int_value', kind: 'scalar', T: 3, oneof: 'value'},
    {no: 5, name: 'bool_value', kind: 'scalar', T: 8, oneof: 'value'},
    {no: 6, name: 'null_value', kind: 'message', T: Empty, oneof: 'value'},
  ])
  static fromBinary(bytes, options) {
    return new DocumentChange_SetAttribute().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DocumentChange_SetAttribute().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DocumentChange_SetAttribute().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DocumentChange_SetAttribute, a, b)
  }
}
class Ref extends Message {
  /**
   * CID of the Ref blob.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Account (space) in which the Ref blob exists.
   *
   * @generated from field: string account = 2;
   */
  account = ''
  /**
   * Path in the account Ref creates an entry for.
   *
   * @generated from field: string path = 3;
   */
  path = ''
  /**
   * Description of where the Ref points to.
   *
   * @generated from field: com.seed.documents.v3alpha.RefTarget target = 4;
   */
  target
  /**
   * Public key used to sign the Ref blob.
   *
   * @generated from field: string signer = 5;
   */
  signer = ''
  /**
   * Optional. ID of the Capability attached to this Ref.
   *
   * @generated from field: string capability = 6;
   */
  capability = ''
  /**
   * Timestamp of the Ref.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 7;
   */
  timestamp
  /**
   * Information about the generation of the Ref.
   *
   * @generated from field: com.seed.documents.v3alpha.GenerationInfo generation_info = 8;
   */
  generationInfo
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Ref'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 4, name: 'target', kind: 'message', T: RefTarget},
    {
      no: 5,
      name: 'signer',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'capability',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 7, name: 'timestamp', kind: 'message', T: Timestamp},
    {no: 8, name: 'generation_info', kind: 'message', T: GenerationInfo},
  ])
  static fromBinary(bytes, options) {
    return new Ref().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Ref().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Ref().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Ref, a, b)
  }
}
class RefTarget extends Message {
  /**
   * A Ref can point to one of the following targets.
   *
   * @generated from oneof com.seed.documents.v3alpha.RefTarget.target
   */
  target = {case: void 0}
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.RefTarget'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'version',
      kind: 'message',
      T: RefTarget_Version,
      oneof: 'target',
    },
    {
      no: 2,
      name: 'redirect',
      kind: 'message',
      T: RefTarget_Redirect,
      oneof: 'target',
    },
    {
      no: 3,
      name: 'tombstone',
      kind: 'message',
      T: RefTarget_Tombstone,
      oneof: 'target',
    },
  ])
  static fromBinary(bytes, options) {
    return new RefTarget().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new RefTarget().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new RefTarget().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(RefTarget, a, b)
  }
}
class RefTarget_Version extends Message {
  /**
   * Required. ID of the genesis Change.
   *
   * @generated from field: string genesis = 1;
   */
  genesis = ''
  /**
   * Required. Version ID (possibly compount).
   * Each change in the version ID must have the same genesis.
   *
   * @generated from field: string version = 2;
   */
  version = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.RefTarget.Version'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'genesis',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new RefTarget_Version().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new RefTarget_Version().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new RefTarget_Version().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(RefTarget_Version, a, b)
  }
}
class RefTarget_Redirect extends Message {
  /**
   * Required. Account ID to which the Ref should redirect.
   * Can be the same as the account in the Ref itself,
   * when we redirect to a different path in the same account/space.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path to which the Ref should redirect.
   * Empty string means root document.
   * Must not be the same as the Ref itself.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Optional. If true, the Ref becomes a republishing Ref,
   * in which case instead of explicitly redirecting to the target resource
   * it will display the target document right away, using the most recent version available.
   *
   * @generated from field: bool republish = 3;
   */
  republish = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.RefTarget.Redirect'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'republish',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new RefTarget_Redirect().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new RefTarget_Redirect().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new RefTarget_Redirect().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(RefTarget_Redirect, a, b)
  }
}
class RefTarget_Tombstone extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.RefTarget.Tombstone'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new RefTarget_Tombstone().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new RefTarget_Tombstone().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new RefTarget_Tombstone().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(RefTarget_Tombstone, a, b)
  }
}
class ListEventsRequest extends Message {
  /**
   * Optional. The size of the page. The default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0
  /**
   * Optional. The page token for requesting next pages.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = ''
  /**
   * Optional. If we want events from trusted peers only. All peers by default.
   *
   * @generated from field: bool trusted_only = 3;
   */
  trustedOnly = false
  /**
   * Optional. If we want events only from specific user accounts. Multiple
   * authors are filtered following OR logic.
   *
   * @generated from field: repeated string filter_authors = 4;
   */
  filterAuthors = []
  /**
   * Optional. If we want certain types of events.
   * Currently supported event types are:
   *   - Capability
   *   - Ref
   *   - Comment
   *   - DagPB
   *   - Profile
   * Multiple types are filtered following OR logic.
   *
   * @generated from field: repeated string filter_event_type = 5;
   */
  filterEventType = []
  /**
   * Optional. If we want events only from specific resource IDs.
   * It admits wildards, i.e. we can filter by path prefixes.
   *
   * @generated from field: string filter_resource = 6;
   */
  filterResource = ''
  /**
   * Optional. If we want to include link events. These blobs (usually documents
   * or comments), link (mention) to another resource (currently only account
   * mentions supported). We can add these blobs to the feed result by providing a
   * list of resources iris we want links to aggregated as a logical OR.
   * These link events are also treated as logical OR when grouped with other filters,
   * unlike other filters (authors, event_types) that are grouped under a logic AND.
   * Example: filter_authors(u+a1 OR a2 ...) AND filter_event_type(et1 OR et2 ...) OR
   * add_linked_resource(lr1 OR lr2 ...)
   *
   * @generated from field: repeated string add_linked_resource = 7;
   */
  addLinkedResource = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.ListEventsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'trusted_only',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {no: 4, name: 'filter_authors', kind: 'scalar', T: 9, repeated: true},
    {no: 5, name: 'filter_event_type', kind: 'scalar', T: 9, repeated: true},
    {
      no: 6,
      name: 'filter_resource',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 7, name: 'add_linked_resource', kind: 'scalar', T: 9, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new ListEventsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListEventsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListEventsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListEventsRequest, a, b)
  }
}
class ListEventsResponse extends Message {
  /**
   * The list of events.
   *
   * @generated from field: repeated com.seed.activity.v1alpha.Event events = 1;
   */
  events = []
  /**
   * The token to request the next page.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.ListEventsResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'events', kind: 'message', T: Event, repeated: true},
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListEventsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListEventsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListEventsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListEventsResponse, a, b)
  }
}
class Event extends Message {
  /**
   * Union type of different event types.
   * Eventually we'll have more event types.
   *
   * @generated from oneof com.seed.activity.v1alpha.Event.data
   */
  data = {case: void 0}
  /**
   * The ID of the user account that has caused the event.
   *
   * @generated from field: string account = 2;
   */
  account = ''
  /**
   * Timestamp of the event as per the event itself.
   *
   * @generated from field: google.protobuf.Timestamp event_time = 3;
   */
  eventTime
  /**
   * Locally perceived time of the event.
   * I.e. time when we have received the event on our machine.
   *
   * @generated from field: google.protobuf.Timestamp observe_time = 4;
   */
  observeTime
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.Event'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'new_blob', kind: 'message', T: NewBlobEvent, oneof: 'data'},
    {
      no: 2,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'event_time', kind: 'message', T: Timestamp},
    {no: 4, name: 'observe_time', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new Event().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Event().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Event().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Event, a, b)
  }
}
class NewBlobEvent extends Message {
  /**
   * The CID of the blob that was created.
   *
   * @generated from field: string cid = 1;
   */
  cid = ''
  /**
   * The type of the blob that was created.
   * Defined as string for extensibility.
   * Some of the currently supported blob types are:
   *   - KeyDelegation
   *   - Change
   *   - Comment
   *   - DagPB
   *
   * @generated from field: string blob_type = 2;
   */
  blobType = ''
  /**
   * The user account ID that has created the blob.
   *
   * @generated from field: string author = 3;
   */
  author = ''
  /**
   * The resource ID that the blob is related to.
   *
   * @generated from field: string resource = 4;
   */
  resource = ''
  /**
   * Extra attributes of the blob.
   *
   * @generated from field: string extra_attrs = 5;
   */
  extraAttrs = ''
  /**
   * @generated from field: int64 blob_id = 6;
   */
  blobId = protoInt64.zero
  /**
   * Only relevant for ling events
   *
   * @generated from field: bool is_pinned = 7;
   */
  isPinned = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.NewBlobEvent'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'cid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'blob_type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'author',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'resource',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'extra_attrs',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'blob_id',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 7,
      name: 'is_pinned',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new NewBlobEvent().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new NewBlobEvent().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new NewBlobEvent().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(NewBlobEvent, a, b)
  }
}
const ActivityFeed = {
  typeName: 'com.seed.activity.v1alpha.ActivityFeed',
  methods: {
    /**
     * Lists the recent activity events,
     * sorted by locally observed time (newest first).
     *
     * @generated from rpc com.seed.activity.v1alpha.ActivityFeed.ListEvents
     */
    listEvents: {
      name: 'ListEvents',
      I: ListEventsRequest,
      O: ListEventsResponse,
      kind: MethodKind.Unary,
    },
  },
}
class SubscribeRequest extends Message {
  /**
   * Required. The ID of the account where the subscribed document is located.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the document.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Optional. Indicate if we not only subscribe to the resource
   * ID above but also to all documents on its directory.
   *
   * @generated from field: bool recursive = 3;
   */
  recursive = false
  /**
   * Optional. If true, the server will not wait for the subscription
   * to be synced for the first time before returning.
   *
   * @generated from field: optional bool async = 4;
   */
  async
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.SubscribeRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'recursive',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {no: 4, name: 'async', kind: 'scalar', T: 8, opt: true},
  ])
  static fromBinary(bytes, options) {
    return new SubscribeRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new SubscribeRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new SubscribeRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(SubscribeRequest, a, b)
  }
}
class UnsubscribeRequest extends Message {
  /**
   * Required. The ID of the account where the subscribed document is located.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path of the document.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.UnsubscribeRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new UnsubscribeRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UnsubscribeRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UnsubscribeRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(UnsubscribeRequest, a, b)
  }
}
class ListSubscriptionsRequest extends Message {
  /**
   * Optional. The size of the page. The default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0
  /**
   * Optional. The page token for requesting next pages.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.ListSubscriptionsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListSubscriptionsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListSubscriptionsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListSubscriptionsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListSubscriptionsRequest, a, b)
  }
}
class ListSubscriptionsResponse extends Message {
  /**
   * The list of subscriptions.
   *
   * @generated from field: repeated com.seed.activity.v1alpha.Subscription subscriptions = 1;
   */
  subscriptions = []
  /**
   * The token to request the next page.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.ListSubscriptionsResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'subscriptions',
      kind: 'message',
      T: Subscription,
      repeated: true,
    },
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListSubscriptionsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListSubscriptionsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListSubscriptionsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListSubscriptionsResponse, a, b)
  }
}
class Subscription extends Message {
  /**
   * Account to which the document belongs.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Path of the document within the account.
   * Empty string means root document.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Whether this subscription also subscribes to
   * all documents in the document's directory.
   *
   * @generated from field: bool recursive = 3;
   */
  recursive = false
  /**
   * Timestamp when the user started the subscrition.
   *
   * @generated from field: google.protobuf.Timestamp since = 4;
   */
  since
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.activity.v1alpha.Subscription'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'recursive',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {no: 4, name: 'since', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new Subscription().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Subscription().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Subscription().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Subscription, a, b)
  }
}
const Subscriptions = {
  typeName: 'com.seed.activity.v1alpha.Subscriptions',
  methods: {
    /**
     * Subscribe to a document or space.
     *
     * @generated from rpc com.seed.activity.v1alpha.Subscriptions.Subscribe
     */
    subscribe: {
      name: 'Subscribe',
      I: SubscribeRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Remove a subscription.
     *
     * @generated from rpc com.seed.activity.v1alpha.Subscriptions.Unsubscribe
     */
    unsubscribe: {
      name: 'Unsubscribe',
      I: UnsubscribeRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Lists active subscriptions.
     *
     * @generated from rpc com.seed.activity.v1alpha.Subscriptions.ListSubscriptions
     */
    listSubscriptions: {
      name: 'ListSubscriptions',
      I: ListSubscriptionsRequest,
      O: ListSubscriptionsResponse,
      kind: MethodKind.Unary,
    },
  },
}
var State = /* @__PURE__ */ ((State2) => {
  State2[(State2['STARTING'] = 0)] = 'STARTING'
  State2[(State2['MIGRATING'] = 1)] = 'MIGRATING'
  State2[(State2['ACTIVE'] = 3)] = 'ACTIVE'
  return State2
})(State || {})
proto3.util.setEnumType(State, 'com.seed.daemon.v1alpha.State', [
  {no: 0, name: 'STARTING'},
  {no: 1, name: 'MIGRATING'},
  {no: 3, name: 'ACTIVE'},
])
class GenMnemonicRequest extends Message {
  /**
   * Optional. Number of mnemonic words to encode the seed.
   * Usually 12 or 24 words.
   * By default 12 words are generated.
   *
   * @generated from field: int32 word_count = 1;
   */
  wordCount = 0
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.GenMnemonicRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'word_count',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
  ])
  static fromBinary(bytes, options) {
    return new GenMnemonicRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GenMnemonicRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GenMnemonicRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GenMnemonicRequest, a, b)
  }
}
class GenMnemonicResponse extends Message {
  /**
   * The list of human-friendly words that can be used to backup the seed. These
   * words must be stored in a secret place by the user.
   *
   * @generated from field: repeated string mnemonic = 1;
   */
  mnemonic = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.GenMnemonicResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'mnemonic', kind: 'scalar', T: 9, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new GenMnemonicResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GenMnemonicResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GenMnemonicResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GenMnemonicResponse, a, b)
  }
}
class RegisterKeyRequest extends Message {
  /**
   * Required. The list of BIP-39 mnemonic words.
   *
   * @generated from field: repeated string mnemonic = 1;
   */
  mnemonic = []
  /**
   * Optional. Passphrase for the seed.
   *
   * @generated from field: string passphrase = 2;
   */
  passphrase = ''
  /**
   * Required. Private name/label for the signing key, to easily identify keys when they are more than one.
   * Name must be unique across all the registered keys.
   *
   * @generated from field: string name = 3;
   */
  name = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.RegisterKeyRequest'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'mnemonic', kind: 'scalar', T: 9, repeated: true},
    {
      no: 2,
      name: 'passphrase',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new RegisterKeyRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new RegisterKeyRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new RegisterKeyRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(RegisterKeyRequest, a, b)
  }
}
class GetInfoRequest extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.GetInfoRequest'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new GetInfoRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetInfoRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetInfoRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetInfoRequest, a, b)
  }
}
class ForceSyncRequest extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.ForceSyncRequest'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new ForceSyncRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ForceSyncRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ForceSyncRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ForceSyncRequest, a, b)
  }
}
class ForceReindexRequest extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.ForceReindexRequest'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new ForceReindexRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ForceReindexRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ForceReindexRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ForceReindexRequest, a, b)
  }
}
class ForceReindexResponse extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.ForceReindexResponse'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new ForceReindexResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ForceReindexResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ForceReindexResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ForceReindexResponse, a, b)
  }
}
class DeleteAllKeysRequest extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.DeleteAllKeysRequest'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new DeleteAllKeysRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DeleteAllKeysRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DeleteAllKeysRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DeleteAllKeysRequest, a, b)
  }
}
class ListKeysRequest extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.ListKeysRequest'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new ListKeysRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListKeysRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListKeysRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListKeysRequest, a, b)
  }
}
class ListKeysResponse extends Message {
  /**
   * List of registered keys.
   *
   * @generated from field: repeated com.seed.daemon.v1alpha.NamedKey keys = 1;
   */
  keys = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.ListKeysResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'keys', kind: 'message', T: NamedKey, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new ListKeysResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListKeysResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListKeysResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListKeysResponse, a, b)
  }
}
class UpdateKeyRequest extends Message {
  /**
   * Current name of the key.
   *
   * @generated from field: string current_name = 1;
   */
  currentName = ''
  /**
   * New name for the key.
   *
   * @generated from field: string new_name = 2;
   */
  newName = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.UpdateKeyRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'current_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'new_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new UpdateKeyRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UpdateKeyRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UpdateKeyRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(UpdateKeyRequest, a, b)
  }
}
class DeleteKeyRequest extends Message {
  /**
   * Name of the key to delete.
   *
   * @generated from field: string name = 1;
   */
  name = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.DeleteKeyRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DeleteKeyRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DeleteKeyRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DeleteKeyRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DeleteKeyRequest, a, b)
  }
}
class StoreBlobsRequest extends Message {
  /**
   * Required. List of blobs to be stored.
   * The request is atomic: either all blobs are stored or none of them.
   *
   * @generated from field: repeated com.seed.daemon.v1alpha.Blob blobs = 1;
   */
  blobs = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.StoreBlobsRequest'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'blobs', kind: 'message', T: Blob, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new StoreBlobsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new StoreBlobsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new StoreBlobsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(StoreBlobsRequest, a, b)
  }
}
class StoreBlobsResponse extends Message {
  /**
   * List of CIDs for the stored blobs.
   * The order is the same as in the request.
   *
   * @generated from field: repeated string cids = 1;
   */
  cids = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.StoreBlobsResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'cids', kind: 'scalar', T: 9, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new StoreBlobsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new StoreBlobsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new StoreBlobsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(StoreBlobsResponse, a, b)
  }
}
class CreateDeviceLinkSessionRequest extends Message {
  /**
   * Required. Name of the signing key for which to create the delegation.
   *
   * @generated from field: string signing_key_name = 1;
   */
  signingKeyName = ''
  /**
   * Optional. Label that will be used for the newly created capability.
   * The label is publicly visible.
   *
   * @generated from field: string label = 2;
   */
  label = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.CreateDeviceLinkSessionRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'label',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new CreateDeviceLinkSessionRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateDeviceLinkSessionRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateDeviceLinkSessionRequest().fromJsonString(
      jsonString,
      options,
    )
  }
  static equals(a, b) {
    return proto3.util.equals(CreateDeviceLinkSessionRequest, a, b)
  }
}
class GetDeviceLinkSessionRequest extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.GetDeviceLinkSessionRequest'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new GetDeviceLinkSessionRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetDeviceLinkSessionRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetDeviceLinkSessionRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetDeviceLinkSessionRequest, a, b)
  }
}
class SignDataRequest extends Message {
  /**
   * Required. Name of the signing key to use for signing.
   *
   * @generated from field: string signing_key_name = 1;
   */
  signingKeyName = ''
  /**
   * Required. Data to be signed.
   *
   * @generated from field: bytes data = 2;
   */
  data = new Uint8Array(0)
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.SignDataRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'data',
      kind: 'scalar',
      T: 12,
      /* ScalarType.BYTES */
    },
  ])
  static fromBinary(bytes, options) {
    return new SignDataRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new SignDataRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new SignDataRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(SignDataRequest, a, b)
  }
}
class SignDataResponse extends Message {
  /**
   * Signature over the data.
   *
   * @generated from field: bytes signature = 1;
   */
  signature = new Uint8Array(0)
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.SignDataResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'signature',
      kind: 'scalar',
      T: 12,
      /* ScalarType.BYTES */
    },
  ])
  static fromBinary(bytes, options) {
    return new SignDataResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new SignDataResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new SignDataResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(SignDataResponse, a, b)
  }
}
class DeviceLinkSession extends Message {
  /**
   * Dial information for the node.
   *
   * @generated from field: com.seed.daemon.v1alpha.AddrInfo addr_info = 1;
   */
  addrInfo
  /**
   * Secret token for the linking session.
   *
   * @generated from field: string secret_token = 2;
   */
  secretToken = ''
  /**
   * Account ID that wants to link the new device.
   *
   * @generated from field: string account_id = 3;
   */
  accountId = ''
  /**
   * Label for the future capability as defined by the user.
   *
   * @generated from field: string label = 4;
   */
  label = ''
  /**
   * Expiration time of the session.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 5;
   */
  expireTime
  /**
   * Optional. Time when the session was redeemed,
   * i.e. when the device link exchange was completed successfully.
   *
   * @generated from field: google.protobuf.Timestamp redeem_time = 6;
   */
  redeemTime
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.DeviceLinkSession'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'addr_info', kind: 'message', T: AddrInfo},
    {
      no: 2,
      name: 'secret_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'account_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'label',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 5, name: 'expire_time', kind: 'message', T: Timestamp},
    {no: 6, name: 'redeem_time', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new DeviceLinkSession().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DeviceLinkSession().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DeviceLinkSession().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DeviceLinkSession, a, b)
  }
}
class AddrInfo extends Message {
  /**
   * @generated from field: string peer_id = 1;
   */
  peerId = ''
  /**
   * @generated from field: repeated string addrs = 2;
   */
  addrs = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.AddrInfo'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'peer_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 2, name: 'addrs', kind: 'scalar', T: 9, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new AddrInfo().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new AddrInfo().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new AddrInfo().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(AddrInfo, a, b)
  }
}
class Blob extends Message {
  /**
   * Optional. The client can provide a CID for the blob (the server will verify it).
   * If not provided, the data is assumed to be DAG-CBOR encoded, and the server will generate a CID
   * using its default hash function.
   *
   * @generated from field: string cid = 1;
   */
  cid = ''
  /**
   * Required. Raw data of the blob.
   *
   * @generated from field: bytes data = 2;
   */
  data = new Uint8Array(0)
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.Blob'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'cid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'data',
      kind: 'scalar',
      T: 12,
      /* ScalarType.BYTES */
    },
  ])
  static fromBinary(bytes, options) {
    return new Blob().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Blob().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Blob().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Blob, a, b)
  }
}
class Info extends Message {
  /**
   * Current state of the daemon.
   *
   * @generated from field: com.seed.daemon.v1alpha.State state = 1;
   */
  state = 0
  /**
   * Libp2p Peer ID of this node.
   *
   * @generated from field: string peer_id = 2;
   */
  peerId = ''
  /**
   * Start time of the node.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime
  /**
   * The libp2p protocol ID that the daemon is using.
   *
   * @generated from field: string protocol_id = 4;
   */
  protocolId = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.Info'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'state', kind: 'enum', T: proto3.getEnumType(State)},
    {
      no: 2,
      name: 'peer_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'start_time', kind: 'message', T: Timestamp},
    {
      no: 4,
      name: 'protocol_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new Info().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Info().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Info().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Info, a, b)
  }
}
class NamedKey extends Message {
  /**
   * Public key in Multikey format.
   * https://www.w3.org/TR/vc-data-integrity/#multikey.
   *
   * @generated from field: string public_key = 1;
   */
  publicKey = ''
  /**
   * Private name for the key. Useful to identify the keys when there're more than one.
   *
   * @generated from field: string name = 2;
   */
  name = ''
  /**
   * Account ID representation of this key.
   *
   * @generated from field: string account_id = 3;
   */
  accountId = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.daemon.v1alpha.NamedKey'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'public_key',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'account_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new NamedKey().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new NamedKey().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new NamedKey().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(NamedKey, a, b)
  }
}
const Daemon = {
  typeName: 'com.seed.daemon.v1alpha.Daemon',
  methods: {
    /**
     * Generates a set of BIP-39-compatible mnemonic words encoding a cryptographic seed.
     * This is a stateless call, and the generated mnemonic is not stored anywhere.
     * Subsequent call to RegisterKey can be used to register a new signing key derived from the mnemonic.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.GenMnemonic
     */
    genMnemonic: {
      name: 'GenMnemonic',
      I: GenMnemonicRequest,
      O: GenMnemonicResponse,
      kind: MethodKind.Unary,
    },
    /**
     * After generating the seed, this call is used to commit the seed and
     * create an account binding between the device and account.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.RegisterKey
     */
    registerKey: {
      name: 'RegisterKey',
      I: RegisterKeyRequest,
      O: NamedKey,
      kind: MethodKind.Unary,
    },
    /**
     * Get generic information about the running node.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.GetInfo
     */
    getInfo: {
      name: 'GetInfo',
      I: GetInfoRequest,
      O: Info,
      kind: MethodKind.Unary,
    },
    /**
     * Force-trigger periodic background sync of Seed objects.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.ForceSync
     */
    forceSync: {
      name: 'ForceSync',
      I: ForceSyncRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Forces the daemon to reindex the entire database.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.ForceReindex
     */
    forceReindex: {
      name: 'ForceReindex',
      I: ForceReindexRequest,
      O: ForceReindexResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Lists all the signing keys registered on this Daemon.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.ListKeys
     */
    listKeys: {
      name: 'ListKeys',
      I: ListKeysRequest,
      O: ListKeysResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Updates the existing key.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.UpdateKey
     */
    updateKey: {
      name: 'UpdateKey',
      I: UpdateKeyRequest,
      O: NamedKey,
      kind: MethodKind.Unary,
    },
    /**
     * Deletes a key from the underlying key store.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.DeleteKey
     */
    deleteKey: {
      name: 'DeleteKey',
      I: DeleteKeyRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Deletes all Seed keys from the underlying key store.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.DeleteAllKeys
     */
    deleteAllKeys: {
      name: 'DeleteAllKeys',
      I: DeleteAllKeysRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Receives raw blobs to be stored.
     * The request may fail if blobs can't be recognized by the daemon.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.StoreBlobs
     */
    storeBlobs: {
      name: 'StoreBlobs',
      I: StoreBlobsRequest,
      O: StoreBlobsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Creates a new device link session.
     * The session information has to be transferred to the other device,
     * to establish a direct P2P connection between the devices, and complete the linking process.
     *
     * There can only be one active session at a time, and creating a new one will invalidate the previous one.
     *
     * After the session is redeemed, it becomes invalid.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.CreateDeviceLinkSession
     */
    createDeviceLinkSession: {
      name: 'CreateDeviceLinkSession',
      I: CreateDeviceLinkSessionRequest,
      O: DeviceLinkSession,
      kind: MethodKind.Unary,
    },
    /**
     * Get the current device link session (if it exists).
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.GetDeviceLinkSession
     */
    getDeviceLinkSession: {
      name: 'GetDeviceLinkSession',
      I: GetDeviceLinkSessionRequest,
      O: DeviceLinkSession,
      kind: MethodKind.Unary,
    },
    /**
     * Sign arbitrary data with an existing signing key.
     *
     * @generated from rpc com.seed.daemon.v1alpha.Daemon.SignData
     */
    signData: {
      name: 'SignData',
      I: SignDataRequest,
      O: SignDataResponse,
      kind: MethodKind.Unary,
    },
  },
}
var Role = /* @__PURE__ */ ((Role2) => {
  Role2[(Role2['ROLE_UNSPECIFIED'] = 0)] = 'ROLE_UNSPECIFIED'
  Role2[(Role2['WRITER'] = 2)] = 'WRITER'
  Role2[(Role2['AGENT'] = 3)] = 'AGENT'
  return Role2
})(Role || {})
proto3.util.setEnumType(Role, 'com.seed.documents.v3alpha.Role', [
  {no: 0, name: 'ROLE_UNSPECIFIED'},
  {no: 2, name: 'WRITER'},
  {no: 3, name: 'AGENT'},
])
class ListCapabilitiesRequest extends Message {
  /**
   * Required. Account for which to list the capabilities.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Path within the account to list the capabilities for.
   * Empty string means root document.
   * String "*" means all documents.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Optional. By default all capabilities that match the path are returned,
   * even if they were issued for some parent path.
   * If this field is true, only capabilities that match the path exactly are returned.
   *
   * @generated from field: bool ignore_inherited = 3;
   */
  ignoreInherited = false
  /**
   * Optional. Number of capabilities to return in the response.
   *
   * @generated from field: int32 page_size = 4;
   */
  pageSize = 0
  /**
   * Optional. Page token to continue listing capabilities.
   *
   * @generated from field: string page_token = 5;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListCapabilitiesRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'ignore_inherited',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 4,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 5,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListCapabilitiesRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListCapabilitiesRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListCapabilitiesRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListCapabilitiesRequest, a, b)
  }
}
class ListCapabilitiesResponse extends Message {
  /**
   * List of capabilities.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.Capability capabilities = 1;
   */
  capabilities = []
  /**
   * Token for the next page, if any.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListCapabilitiesResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'capabilities',
      kind: 'message',
      T: Capability,
      repeated: true,
    },
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListCapabilitiesResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListCapabilitiesResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListCapabilitiesResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListCapabilitiesResponse, a, b)
  }
}
class ListCapabilitiesForDelegateRequest extends Message {
  /**
   * The public key of the delegate to list capabilities for.
   *
   * @generated from field: string delegate = 1;
   */
  delegate = ''
  /**
   * Optional. Number of capabilities to return in the response.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0
  /**
   * Optional. Page token to continue listing capabilities.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName =
    'com.seed.documents.v3alpha.ListCapabilitiesForDelegateRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'delegate',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListCapabilitiesForDelegateRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListCapabilitiesForDelegateRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListCapabilitiesForDelegateRequest().fromJsonString(
      jsonString,
      options,
    )
  }
  static equals(a, b) {
    return proto3.util.equals(ListCapabilitiesForDelegateRequest, a, b)
  }
}
class CreateCapabilityRequest extends Message {
  /**
   * Required. Name of the key to use for signing the capability.
   *
   * @generated from field: string signing_key_name = 1;
   */
  signingKeyName = ''
  /**
   * Required. Account ID to which this capability is delegated.
   *
   * @generated from field: string delegate = 2;
   */
  delegate = ''
  /**
   * Required. Account ID to which this capability gives access.
   *
   * @generated from field: string account = 3;
   */
  account = ''
  /**
   * Required. Path within the account that this capability grants access to.
   * Empty string means root document.
   *
   * @generated from field: string path = 4;
   */
  path = ''
  /**
   * Required. Role that this capability grants to the delegate.
   * If capability is nested, the role cannot be higher than the role of any ancestor capability.
   *
   * @generated from field: com.seed.documents.v3alpha.Role role = 5;
   */
  role = 0
  /**
   * Optional. By default capabilities give access to the path recursively.
   * This flag can be used to restrict the capability only to specific path.
   *
   * @generated from field: bool no_recursive = 6;
   */
  noRecursive = false
  /**
   * Optional. Short, user-provided label for the capability for user's convenience to identify them later.
   * The label is public and cannot be changed.
   *
   * @generated from field: string label = 7;
   */
  label = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.CreateCapabilityRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'delegate',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 5, name: 'role', kind: 'enum', T: proto3.getEnumType(Role)},
    {
      no: 6,
      name: 'no_recursive',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: 'label',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new CreateCapabilityRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateCapabilityRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateCapabilityRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(CreateCapabilityRequest, a, b)
  }
}
class GetCapabilityRequest extends Message {
  /**
   * Required. ID of the capability to get.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetCapabilityRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetCapabilityRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetCapabilityRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetCapabilityRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetCapabilityRequest, a, b)
  }
}
class Capability extends Message {
  /**
   * ID of this capability.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * ID of the account that issued the capability.
   *
   * @generated from field: string issuer = 2;
   */
  issuer = ''
  /**
   * ID of the account that the capability is delegated to.
   *
   * @generated from field: string delegate = 3;
   */
  delegate = ''
  /**
   * Account ID that capability grants access to.
   * This is the same as issuer when it's a first-grade capability,
   * but issuer can be different if the capability is delegated further down.
   *
   * @generated from field: string account = 4;
   */
  account = ''
  /**
   * Path within the account which the capability grants access to.
   *
   * @generated from field: string path = 5;
   */
  path = ''
  /**
   * Role that the capability grants to the delegate.
   *
   * @generated from field: com.seed.documents.v3alpha.Role role = 6;
   */
  role = 0
  /**
   * Normally capabilities are applied recursively (i.e. path + all the subpaths),
   * but it can be limited to only to the exact path match.
   *
   * @generated from field: bool is_exact = 7;
   */
  isExact = false
  /**
   * Timestamp when this capability was issued.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 8;
   */
  createTime
  /**
   * Optional. Short, user-provided label for the capability for user's convenience to identify different capabilities.
   *
   * @generated from field: string label = 9;
   */
  label = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Capability'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'issuer',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'delegate',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 6, name: 'role', kind: 'enum', T: proto3.getEnumType(Role)},
    {
      no: 7,
      name: 'is_exact',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {no: 8, name: 'create_time', kind: 'message', T: Timestamp},
    {
      no: 9,
      name: 'label',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new Capability().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Capability().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Capability().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Capability, a, b)
  }
}
const AccessControl = {
  typeName: 'com.seed.documents.v3alpha.AccessControl',
  methods: {
    /**
     * Lists existing capabilities.
     *
     * @generated from rpc com.seed.documents.v3alpha.AccessControl.ListCapabilities
     */
    listCapabilities: {
      name: 'ListCapabilities',
      I: ListCapabilitiesRequest,
      O: ListCapabilitiesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * List capabilities for a specific delegate.
     *
     * @generated from rpc com.seed.documents.v3alpha.AccessControl.ListCapabilitiesForDelegate
     */
    listCapabilitiesForDelegate: {
      name: 'ListCapabilitiesForDelegate',
      I: ListCapabilitiesForDelegateRequest,
      O: ListCapabilitiesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Creates a new capability.
     *
     * @generated from rpc com.seed.documents.v3alpha.AccessControl.CreateCapability
     */
    createCapability: {
      name: 'CreateCapability',
      I: CreateCapabilityRequest,
      O: Capability,
      kind: MethodKind.Unary,
    },
    /**
     * Get a single capability by ID.
     *
     * @generated from rpc com.seed.documents.v3alpha.AccessControl.GetCapability
     */
    getCapability: {
      name: 'GetCapability',
      I: GetCapabilityRequest,
      O: Capability,
      kind: MethodKind.Unary,
    },
  },
}
class CreateCommentRequest extends Message {
  /**
   * Requred. Account ID to which the comment is applied.
   *
   * @generated from field: string target_account = 1;
   */
  targetAccount = ''
  /**
   * Required. Path within the account where the comment is applied.
   *
   * @generated from field: string target_path = 2;
   */
  targetPath = ''
  /**
   * Required. Version of the document at the time of the comment.
   *
   * @generated from field: string target_version = 3;
   */
  targetVersion = ''
  /**
   * Optional. When current comment is a reply to another comment,
   * this must be the ID of the comment being replied to.
   * Account and path of the parent comment must be the same as the current comment.
   *
   * @generated from field: string reply_parent = 4;
   */
  replyParent = ''
  /**
   * Required. Content of the comment.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.BlockNode content = 5;
   */
  content = []
  /**
   * Required. Name of the key to use for signing the comment.
   *
   * @generated from field: string signing_key_name = 6;
   */
  signingKeyName = ''
  /**
   * Optional. ID of the capability that allows publishing comments for the target account and path.
   * Anyone can create comments to anything, but having a capability to comment makes sure your comments are propagated along with the content.
   *
   * @generated from field: string capability = 7;
   */
  capability = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.CreateCommentRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'target_account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'target_path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'target_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'reply_parent',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 5, name: 'content', kind: 'message', T: BlockNode, repeated: true},
    {
      no: 6,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'capability',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new CreateCommentRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateCommentRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateCommentRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(CreateCommentRequest, a, b)
  }
}
class GetCommentRequest extends Message {
  /**
   * Required. ID of the comment to retrieve.
   * The ID must be a record ID (`{publicKey}/{tsid}`) of the comment.
   * For convenience we also accept versions (CIDs).
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetCommentRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetCommentRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetCommentRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetCommentRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetCommentRequest, a, b)
  }
}
class BatchGetCommentsRequest extends Message {
  /**
   * Required. List of comment IDs to retrieve.
   * See [GetCommentRequest] for the format of the IDs.
   *
   * @generated from field: repeated string ids = 1;
   */
  ids = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.BatchGetCommentsRequest'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'ids', kind: 'scalar', T: 9, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new BatchGetCommentsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new BatchGetCommentsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new BatchGetCommentsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(BatchGetCommentsRequest, a, b)
  }
}
class BatchGetCommentsResponse extends Message {
  /**
   * List of comments requested.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.Comment comments = 1;
   */
  comments = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.BatchGetCommentsResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'comments', kind: 'message', T: Comment, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new BatchGetCommentsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new BatchGetCommentsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new BatchGetCommentsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(BatchGetCommentsResponse, a, b)
  }
}
class ListCommentsRequest extends Message {
  /**
   * Required. Account ID to list the comments for.
   *
   * @generated from field: string target_account = 1;
   */
  targetAccount = ''
  /**
   * Required. Path within the account to list the comments for.
   *
   * @generated from field: string target_path = 2;
   */
  targetPath = ''
  /**
   * Optional. The maximum number of comments to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0
  /**
   * Optional. The page token obtained from a previous request (if any).
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListCommentsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'target_account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'target_path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListCommentsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListCommentsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListCommentsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListCommentsRequest, a, b)
  }
}
class ListCommentsByAuthorRequest extends Message {
  /**
   * Required. Account ID of the author to list comments for.
   *
   * @generated from field: string author = 1;
   */
  author = ''
  /**
   * Optional. The maximum number of comments to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0
  /**
   * Optional. The page token obtained from a previous request (if any).
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListCommentsByAuthorRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'author',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListCommentsByAuthorRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListCommentsByAuthorRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListCommentsByAuthorRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListCommentsByAuthorRequest, a, b)
  }
}
class ListCommentsResponse extends Message {
  /**
   * List of comments.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.Comment comments = 1;
   */
  comments = []
  /**
   * Token to retrieve the next page of comments (if necessary).
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.ListCommentsResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'comments', kind: 'message', T: Comment, repeated: true},
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListCommentsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListCommentsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListCommentsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListCommentsResponse, a, b)
  }
}
class Comment extends Message {
  /**
   * ID of the current comment.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Account ID that this comment targets.
   *
   * @generated from field: string target_account = 2;
   */
  targetAccount = ''
  /**
   * Path within the account this comment targets.
   *
   * @generated from field: string target_path = 3;
   */
  targetPath = ''
  /**
   * Version of the document this comment targets.
   *
   * @generated from field: string target_version = 4;
   */
  targetVersion = ''
  /**
   * Optional. The ID of the top-level non-reply comment of the conversation thread.
   *
   * @generated from field: string thread_root = 5;
   */
  threadRoot = ''
  /**
   * Optional. Version of the thread root comment (if this is a reply).
   *
   * @generated from field: string thread_root_version = 12;
   */
  threadRootVersion = ''
  /**
   * Optional. The ID of the comment to which this comment is a direct reply.
   * For initial comments this field is empty.
   *
   * @generated from field: string reply_parent = 6;
   */
  replyParent = ''
  /**
   * Optional. Version of the parent comment (if this is a reply).
   *
   * @generated from field: string reply_parent_version = 13;
   */
  replyParentVersion = ''
  /**
   * Account ID of the author of the comment.
   *
   * @generated from field: string author = 7;
   */
  author = ''
  /**
   * Content of the comment.
   *
   * @generated from field: repeated com.seed.documents.v3alpha.BlockNode content = 8;
   */
  content = []
  /**
   * Timestamp when the comment was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 9;
   */
  createTime
  /**
   * Optional. ID of the capability this comment was created with, if any.
   *
   * @generated from field: string capability = 10;
   */
  capability = ''
  /**
   * Version of this comment.
   *
   * @generated from field: string version = 11;
   */
  version = ''
  /**
   * Timestamp when the comment was last updated.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 14;
   */
  updateTime
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Comment'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'target_account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'target_path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'target_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'thread_root',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: 'thread_root_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'reply_parent',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: 'reply_parent_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'author',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 8, name: 'content', kind: 'message', T: BlockNode, repeated: true},
    {no: 9, name: 'create_time', kind: 'message', T: Timestamp},
    {
      no: 10,
      name: 'capability',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 14, name: 'update_time', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new Comment().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Comment().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Comment().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Comment, a, b)
  }
}
class UpdateCommentRequest extends Message {
  /**
   * Required. Full snapshot of the updated comment record.
   * Clients should update objects received from GetComment or CreateComment calls.
   * The server will ignore output-only fields like timestamps.
   *
   * @generated from field: com.seed.documents.v3alpha.Comment comment = 1;
   */
  comment
  /**
   * Required. Name of the key to use for signing the comment update.
   *
   * @generated from field: string signing_key_name = 2;
   */
  signingKeyName = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.UpdateCommentRequest'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'comment', kind: 'message', T: Comment},
    {
      no: 2,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new UpdateCommentRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UpdateCommentRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UpdateCommentRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(UpdateCommentRequest, a, b)
  }
}
class DeleteCommentRequest extends Message {
  /**
   * Required. ID of the comment to delete.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Required. Name of the key to use for signing the comment deletion.
   *
   * @generated from field: string signing_key_name = 2;
   */
  signingKeyName = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.DeleteCommentRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'signing_key_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DeleteCommentRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DeleteCommentRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DeleteCommentRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DeleteCommentRequest, a, b)
  }
}
const Comments = {
  typeName: 'com.seed.documents.v3alpha.Comments',
  methods: {
    /**
     * Creates a new comment.
     *
     * @generated from rpc com.seed.documents.v3alpha.Comments.CreateComment
     */
    createComment: {
      name: 'CreateComment',
      I: CreateCommentRequest,
      O: Comment,
      kind: MethodKind.Unary,
    },
    /**
     * Gets a single comment by ID.
     *
     * @generated from rpc com.seed.documents.v3alpha.Comments.GetComment
     */
    getComment: {
      name: 'GetComment',
      I: GetCommentRequest,
      O: Comment,
      kind: MethodKind.Unary,
    },
    /**
     * Get multiple comments by ID.
     *
     * @generated from rpc com.seed.documents.v3alpha.Comments.BatchGetComments
     */
    batchGetComments: {
      name: 'BatchGetComments',
      I: BatchGetCommentsRequest,
      O: BatchGetCommentsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Lists comments for a given target.
     *
     * @generated from rpc com.seed.documents.v3alpha.Comments.ListComments
     */
    listComments: {
      name: 'ListComments',
      I: ListCommentsRequest,
      O: ListCommentsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Lists comments by author.
     *
     * @generated from rpc com.seed.documents.v3alpha.Comments.ListCommentsByAuthor
     */
    listCommentsByAuthor: {
      name: 'ListCommentsByAuthor',
      I: ListCommentsByAuthorRequest,
      O: ListCommentsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Updates an existing comment.
     *
     * @generated from rpc com.seed.documents.v3alpha.Comments.UpdateComment
     */
    updateComment: {
      name: 'UpdateComment',
      I: UpdateCommentRequest,
      O: Comment,
      kind: MethodKind.Unary,
    },
    /**
     * Deletes a comment.
     *
     * @generated from rpc com.seed.documents.v3alpha.Comments.DeleteComment
     */
    deleteComment: {
      name: 'DeleteComment',
      I: DeleteCommentRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
  },
}
const Documents = {
  typeName: 'com.seed.documents.v3alpha.Documents',
  methods: {
    /**
     * Retrieves an existing document.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.GetDocument
     */
    getDocument: {
      name: 'GetDocument',
      I: GetDocumentRequest,
      O: Document,
      kind: MethodKind.Unary,
    },
    /**
     * Retrieves the lightweight metadata about the document.
     * Unlike GetDocument it also returns the information about republishes instead of failing.
     * Also, unlike GetDocument, the DocumentInfo is only returned for the latest version of the document.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.GetDocumentInfo
     */
    getDocumentInfo: {
      name: 'GetDocumentInfo',
      I: GetDocumentInfoRequest,
      O: DocumentInfo,
      kind: MethodKind.Unary,
    },
    /**
     * Same as GetDocumentInfo but for multiple documents at once.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.BatchGetDocumentInfo
     */
    batchGetDocumentInfo: {
      name: 'BatchGetDocumentInfo',
      I: BatchGetDocumentInfoRequest,
      O: BatchGetDocumentInfoResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Creates a new Document Change.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.CreateDocumentChange
     */
    createDocumentChange: {
      name: 'CreateDocumentChange',
      I: CreateDocumentChangeRequest,
      O: Document,
      kind: MethodKind.Unary,
    },
    /**
     * Deletes a document.
     *
     * Deprecated: Use CreateRef API.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.DeleteDocument
     * @deprecated
     */
    deleteDocument: {
      name: 'DeleteDocument',
      I: DeleteDocumentRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Lists all accounts.
     *
     * TODO(burdiyan): rename to spaces or sites.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.ListAccounts
     */
    listAccounts: {
      name: 'ListAccounts',
      I: ListAccountsRequest,
      O: ListAccountsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Gets a single account by ID.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.GetAccount
     */
    getAccount: {
      name: 'GetAccount',
      I: GetAccountRequest,
      O: Account,
      kind: MethodKind.Unary,
    },
    /**
     * Gets multiple accounts by IDs.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.BatchGetAccounts
     */
    batchGetAccounts: {
      name: 'BatchGetAccounts',
      I: BatchGetAccountsRequest,
      O: BatchGetAccountsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Updates the profile of an account.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.UpdateProfile
     */
    updateProfile: {
      name: 'UpdateProfile',
      I: UpdateProfileRequest,
      O: Account,
      kind: MethodKind.Unary,
    },
    /**
     * Creates alias for an account.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.CreateAlias
     */
    createAlias: {
      name: 'CreateAlias',
      I: CreateAliasRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Creates a new contact for an account.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.CreateContact
     */
    createContact: {
      name: 'CreateContact',
      I: CreateContactRequest,
      O: Contact,
      kind: MethodKind.Unary,
    },
    /**
     * Gets a single contact by ID.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.GetContact
     */
    getContact: {
      name: 'GetContact',
      I: GetContactRequest,
      O: Contact,
      kind: MethodKind.Unary,
    },
    /**
     * Updates an existing contact.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.UpdateContact
     */
    updateContact: {
      name: 'UpdateContact',
      I: UpdateContactRequest,
      O: Contact,
      kind: MethodKind.Unary,
    },
    /**
     * Deletes a contact from an account.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.DeleteContact
     */
    deleteContact: {
      name: 'DeleteContact',
      I: DeleteContactRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Lists contacts for an account.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.ListContacts
     */
    listContacts: {
      name: 'ListContacts',
      I: ListContactsRequest,
      O: ListContactsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Lists documents in a directory of an account.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.ListDirectory
     */
    listDirectory: {
      name: 'ListDirectory',
      I: ListDirectoryRequest,
      O: ListDirectoryResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Lists documents within the account. Only the most recent versions show up.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.ListDocuments
     */
    listDocuments: {
      name: 'ListDocuments',
      I: ListDocumentsRequest,
      O: ListDocumentsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Lists all the root documents that we know about.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.ListRootDocuments
     */
    listRootDocuments: {
      name: 'ListRootDocuments',
      I: ListRootDocumentsRequest,
      O: ListRootDocumentsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Lists all changes of a document.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.ListDocumentChanges
     */
    listDocumentChanges: {
      name: 'ListDocumentChanges',
      I: ListDocumentChangesRequest,
      O: ListDocumentChangesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Gets a single document change by ID.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.GetDocumentChange
     */
    getDocumentChange: {
      name: 'GetDocumentChange',
      I: GetDocumentChangeRequest,
      O: DocumentChangeInfo,
      kind: MethodKind.Unary,
    },
    /**
     * Updates the read status of a document.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.UpdateDocumentReadStatus
     */
    updateDocumentReadStatus: {
      name: 'UpdateDocumentReadStatus',
      I: UpdateDocumentReadStatusRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Creates a Ref blob for the specified account + path.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.CreateRef
     */
    createRef: {
      name: 'CreateRef',
      I: CreateRefRequest,
      O: Ref,
      kind: MethodKind.Unary,
    },
    /**
     * Returns details about a Ref.
     *
     * @generated from rpc com.seed.documents.v3alpha.Documents.GetRef
     */
    getRef: {
      name: 'GetRef',
      I: GetRefRequest,
      O: Ref,
      kind: MethodKind.Unary,
    },
  },
}
class GetResourceRequest extends Message {
  /**
   * Required. IRI of the resource to retrieve.
   *
   * @generated from field: string iri = 1;
   */
  iri = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.GetResourceRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'iri',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetResourceRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetResourceRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetResourceRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetResourceRequest, a, b)
  }
}
class Resource extends Message {
  /**
   * Various kinds of resources.
   *
   * @generated from oneof com.seed.documents.v3alpha.Resource.kind
   */
  kind = {case: void 0}
  /**
   * Optional. The version of the resource (when applicable).
   *
   * @generated from field: string version = 4;
   */
  version = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.documents.v3alpha.Resource'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'document', kind: 'message', T: Document, oneof: 'kind'},
    {no: 2, name: 'comment', kind: 'message', T: Comment, oneof: 'kind'},
    {no: 3, name: 'contact', kind: 'message', T: Contact, oneof: 'kind'},
    {
      no: 4,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new Resource().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Resource().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Resource().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Resource, a, b)
  }
}
const Resources = {
  typeName: 'com.seed.documents.v3alpha.Resources',
  methods: {
    /**
     * Gets a single resource with a URL (technically IRI).
     *
     * @generated from rpc com.seed.documents.v3alpha.Resources.GetResource
     */
    getResource: {
      name: 'GetResource',
      I: GetResourceRequest,
      O: Resource,
      kind: MethodKind.Unary,
    },
  },
}
var DiscoveryTaskState = /* @__PURE__ */ ((DiscoveryTaskState2) => {
  DiscoveryTaskState2[(DiscoveryTaskState2['DISCOVERY_TASK_STARTED'] = 0)] =
    'DISCOVERY_TASK_STARTED'
  DiscoveryTaskState2[(DiscoveryTaskState2['DISCOVERY_TASK_IN_PROGRESS'] = 1)] =
    'DISCOVERY_TASK_IN_PROGRESS'
  DiscoveryTaskState2[(DiscoveryTaskState2['DISCOVERY_TASK_COMPLETED'] = 2)] =
    'DISCOVERY_TASK_COMPLETED'
  return DiscoveryTaskState2
})(DiscoveryTaskState || {})
proto3.util.setEnumType(
  DiscoveryTaskState,
  'com.seed.entities.v1alpha.DiscoveryTaskState',
  [
    {no: 0, name: 'DISCOVERY_TASK_STARTED'},
    {no: 1, name: 'DISCOVERY_TASK_IN_PROGRESS'},
    {no: 2, name: 'DISCOVERY_TASK_COMPLETED'},
  ],
)
class GetChangeRequest extends Message {
  /**
   * ID of the change.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.GetChangeRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetChangeRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetChangeRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetChangeRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetChangeRequest, a, b)
  }
}
class GetEntityTimelineRequest extends Message {
  /**
   * The entity ID to get the timeline for.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Flag to include draft changes in the timeline,
   * otherwise they are omitted by default.
   *
   * @generated from field: bool include_drafts = 2;
   */
  includeDrafts = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.GetEntityTimelineRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'include_drafts',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetEntityTimelineRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetEntityTimelineRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetEntityTimelineRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetEntityTimelineRequest, a, b)
  }
}
class DiscoverEntityRequest extends Message {
  /**
   * Required. The account the entity belongs to.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. The path of the wanted entity.
   *
   * @generated from field: string path = 2;
   */
  path = ''
  /**
   * Optional. Version of the entity to discover.
   *
   * @generated from field: string version = 3;
   */
  version = ''
  /**
   * Optional. If true, we sync the document and the child
   * documents as well.
   *
   * @generated from field: bool recursive = 4;
   */
  recursive = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.DiscoverEntityRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'path',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'recursive',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new DiscoverEntityRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DiscoverEntityRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DiscoverEntityRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DiscoverEntityRequest, a, b)
  }
}
class DiscoverEntityResponse extends Message {
  /**
   * The cached version of the document we've discovered within the last discovery process.
   *
   * @generated from field: string version = 1;
   */
  version = ''
  /**
   * The state of the discovery task.
   *
   * @generated from field: com.seed.entities.v1alpha.DiscoveryTaskState state = 2;
   */
  state = 0
  /**
   * The number of times we've called the discovery process for this entity and version so far.
   *
   * @generated from field: int32 call_count = 3;
   */
  callCount = 0
  /**
   * The timestamp of the last result we've found.
   * It can be empty if the discovery is still in progress.
   *
   * @generated from field: google.protobuf.Timestamp last_result_time = 4;
   */
  lastResultTime
  /**
   * The cached error message of the last discovery attempt if it failed.
   *
   * @generated from field: string last_error = 5;
   */
  lastError = ''
  /**
   * The time when the currently cached result will expire, and a new discovery attempt will be made,
   * if the client keeps calling the discovery RPC.
   * Can be empty if no results have been found yet.
   *
   * @generated from field: google.protobuf.Timestamp result_expire_time = 6;
   */
  resultExpireTime
  /**
   * The progress of the discovery process.
   *
   * @generated from field: com.seed.entities.v1alpha.DiscoveryProgress progress = 7;
   */
  progress
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.DiscoverEntityResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'state',
      kind: 'enum',
      T: proto3.getEnumType(DiscoveryTaskState),
    },
    {
      no: 3,
      name: 'call_count',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {no: 4, name: 'last_result_time', kind: 'message', T: Timestamp},
    {
      no: 5,
      name: 'last_error',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 6, name: 'result_expire_time', kind: 'message', T: Timestamp},
    {no: 7, name: 'progress', kind: 'message', T: DiscoveryProgress},
  ])
  static fromBinary(bytes, options) {
    return new DiscoverEntityResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DiscoverEntityResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DiscoverEntityResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DiscoverEntityResponse, a, b)
  }
}
class DiscoveryProgress extends Message {
  /**
   * Number of peers we have found so far.
   *
   * @generated from field: int32 peers_found = 1;
   */
  peersFound = 0
  /**
   * Number of peers we have successfully synced with.
   *
   * @generated from field: int32 peers_synced_ok = 2;
   */
  peersSyncedOk = 0
  /**
   * Number of peers we have failed to sync with.
   *
   * @generated from field: int32 peers_failed = 3;
   */
  peersFailed = 0
  /**
   * Number of blobs we have discovered so far.
   *
   * @generated from field: int32 blobs_discovered = 4;
   */
  blobsDiscovered = 0
  /**
   * Number of blobs we have successfully downloaded.
   *
   * @generated from field: int32 blobs_downloaded = 5;
   */
  blobsDownloaded = 0
  /**
   * Number of blobs we have failed to download.
   *
   * @generated from field: int32 blobs_failed = 6;
   */
  blobsFailed = 0
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.DiscoveryProgress'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'peers_found',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'peers_synced_ok',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: 'peers_failed',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: 'blobs_discovered',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 5,
      name: 'blobs_downloaded',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 6,
      name: 'blobs_failed',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
  ])
  static fromBinary(bytes, options) {
    return new DiscoveryProgress().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DiscoveryProgress().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DiscoveryProgress().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DiscoveryProgress, a, b)
  }
}
class Change extends Message {
  /**
   * ID of the change.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Author of the change.
   *
   * @generated from field: string author = 2;
   */
  author = ''
  /**
   * Timestamp when the change was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime
  /**
   * IDs of other changes this change depends on.
   *
   * @generated from field: repeated string deps = 4;
   */
  deps = []
  /**
   * IDs of other changes that depend on this change.
   *
   * @generated from field: repeated string children = 6;
   */
  children = []
  /**
   * Indicates whether this changes comes from a trusted peer of ours.
   *
   * @generated from field: bool is_trusted = 5;
   */
  isTrusted = false
  /**
   * Indicates whether this change is a draft.
   *
   * @generated from field: bool is_draft = 7;
   */
  isDraft = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.Change'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'author',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'create_time', kind: 'message', T: Timestamp},
    {no: 4, name: 'deps', kind: 'scalar', T: 9, repeated: true},
    {no: 6, name: 'children', kind: 'scalar', T: 9, repeated: true},
    {
      no: 5,
      name: 'is_trusted',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: 'is_draft',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new Change().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Change().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Change().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Change, a, b)
  }
}
class EntityTimeline extends Message {
  /**
   * The ID of the entity.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Account ID of the owner of the entity.
   *
   * @generated from field: string owner = 2;
   */
  owner = ''
  /**
   * The set of changes for the entity keyed by change ID.
   *
   * @generated from field: map<string, com.seed.entities.v1alpha.Change> changes = 3;
   */
  changes = {}
  /**
   * The sorted list of change IDs by time.
   *
   * @generated from field: repeated string changes_by_time = 4;
   */
  changesByTime = []
  /**
   * The set of changes that has no dependencies.
   * Normally there should only be one root,
   * but just in case it's defined as a list.
   *
   * @generated from field: repeated string roots = 5;
   */
  roots = []
  /**
   * The set of leaf changes considering the entire DAG.
   *
   * @generated from field: repeated string heads = 6;
   */
  heads = []
  /**
   * The set of author versions/variants sorted by timestamp.
   *
   * @generated from field: repeated com.seed.entities.v1alpha.AuthorVersion author_versions = 7;
   */
  authorVersions = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.EntityTimeline'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'owner',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'changes',
      kind: 'map',
      K: 9,
      V: {kind: 'message', T: Change},
    },
    {no: 4, name: 'changes_by_time', kind: 'scalar', T: 9, repeated: true},
    {no: 5, name: 'roots', kind: 'scalar', T: 9, repeated: true},
    {no: 6, name: 'heads', kind: 'scalar', T: 9, repeated: true},
    {
      no: 7,
      name: 'author_versions',
      kind: 'message',
      T: AuthorVersion,
      repeated: true,
    },
  ])
  static fromBinary(bytes, options) {
    return new EntityTimeline().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new EntityTimeline().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new EntityTimeline().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(EntityTimeline, a, b)
  }
}
class AuthorVersion extends Message {
  /**
   * Account ID of the author.
   *
   * @generated from field: string author = 1;
   */
  author = ''
  /**
   * The set of leaf changes from that author.
   *
   * @generated from field: repeated string heads = 2;
   */
  heads = []
  /**
   * The version string corresponding to the author's variant.
   * I.e. same as heads but concatenated with a '.' delimiter.
   *
   * @generated from field: string version = 3;
   */
  version = ''
  /**
   * The timestamp of the author's version.
   * For compound versions the greatest timestamp is used.
   *
   * @generated from field: google.protobuf.Timestamp version_time = 4;
   */
  versionTime
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.AuthorVersion'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'author',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 2, name: 'heads', kind: 'scalar', T: 9, repeated: true},
    {
      no: 3,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 4, name: 'version_time', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new AuthorVersion().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new AuthorVersion().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new AuthorVersion().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(AuthorVersion, a, b)
  }
}
class Entity extends Message {
  /**
   * EID of the entity, including version, block id and range
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Blob Id of the resource containing the matching record.
   *
   * @generated from field: string blob_id = 2;
   */
  blobId = ''
  /**
   * The time of the version of the entity.
   *
   * @generated from field: google.protobuf.Timestamp version_time = 3;
   */
  versionTime
  /**
   * In the case of comments, the document id
   * containing the comment.
   *
   * @generated from field: string doc_id = 4;
   */
  docId = ''
  /**
   * Content of the entity, depending on the type:
   * Alias in the case of account.
   * Title/Body in the case of groups and documents.
   * Body in the case of comments. We don't fill up the whole
   * block, just the part that contains the search term, with
   * the surrounding context. The context size is defined by
   * the context_size parameter.
   *
   * @generated from field: string content = 5;
   */
  content = ''
  /**
   * The owner of the entity
   *
   * @generated from field: string owner = 6;
   */
  owner = ''
  /**
   * The type of the entity it coud be Title, Document, Comment, ...
   *
   * @generated from field: string type = 7;
   */
  type = ''
  /**
   * Icon of the document containing that entity
   *
   * @generated from field: string icon = 8;
   */
  icon = ''
  /**
   * Parent document names
   *
   * @generated from field: repeated string parent_names = 9;
   */
  parentNames = []
  /**
   * Metadata of the document containing that entity.
   *
   * @generated from field: string metadata = 10;
   */
  metadata = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.Entity'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'blob_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'version_time', kind: 'message', T: Timestamp},
    {
      no: 4,
      name: 'doc_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'content',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'owner',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: 'icon',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 9, name: 'parent_names', kind: 'scalar', T: 9, repeated: true},
    {
      no: 10,
      name: 'metadata',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new Entity().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Entity().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Entity().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Entity, a, b)
  }
}
class DeletedEntity extends Message {
  /**
   * EID of the deleted entity.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * When the entity was deleted.
   *
   * @generated from field: google.protobuf.Timestamp delete_time = 2;
   */
  deleteTime
  /**
   * Reason why this entity was deleted.
   *
   * @generated from field: string deleted_reason = 3;
   */
  deletedReason = ''
  /**
   * Further metadata about the deleted entity, title, etc ...
   *
   * @generated from field: string metadata = 4;
   */
  metadata = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.DeletedEntity'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 2, name: 'delete_time', kind: 'message', T: Timestamp},
    {
      no: 3,
      name: 'deleted_reason',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'metadata',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DeletedEntity().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DeletedEntity().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DeletedEntity().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DeletedEntity, a, b)
  }
}
class SearchEntitiesRequest extends Message {
  /**
   * Query to find. We Ssupport wildcards and phrases.
   * See https://sqlite.org/fts5.html#full_text_query_syntax.
   *
   * @generated from field: string query = 1;
   */
  query = ''
  /**
   * Whether to look into all content available or just the titles.
   * If false, comments are not included in the search.
   * Default is false.
   *
   * @generated from field: bool include_body = 2;
   */
  includeBody = false
  /**
   * Optional. The size of the text accompanying the search match.
   * Half of the size is before the match, and half after.
   * Default is 48 runes.
   *
   * @generated from field: int32 context_size = 3;
   */
  contextSize = 0
  /**
   * Optional. The account uid to filter the search by.
   * If not set, the search will be performed across all accounts.
   *
   * @generated from field: string account_uid = 4;
   */
  accountUid = ''
  /**
   * Optional. The account uid the user is logged in with.
   * This is used to filter out contacts that the user doesn't have access to.
   * If not set, we won't provide any contact entities in the response.
   *
   * @generated from field: string logged_account_uid = 5;
   */
  loggedAccountUid = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.SearchEntitiesRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'query',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'include_body',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: 'context_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: 'account_uid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'logged_account_uid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new SearchEntitiesRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new SearchEntitiesRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new SearchEntitiesRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(SearchEntitiesRequest, a, b)
  }
}
class SearchEntitiesResponse extends Message {
  /**
   * Entities matching the input title
   *
   * @generated from field: repeated com.seed.entities.v1alpha.Entity entities = 1;
   */
  entities = []
  /**
   * Token for the next page if there's any.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.SearchEntitiesResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'entities', kind: 'message', T: Entity, repeated: true},
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new SearchEntitiesResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new SearchEntitiesResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new SearchEntitiesResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(SearchEntitiesResponse, a, b)
  }
}
class DeleteEntityRequest extends Message {
  /**
   * Entity ID of the entity to be removed.
   * All versions will also be removed.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Optional. Reason why the user wants to delete that entity.
   *
   * @generated from field: string reason = 2;
   */
  reason = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.DeleteEntityRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'reason',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DeleteEntityRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DeleteEntityRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DeleteEntityRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DeleteEntityRequest, a, b)
  }
}
class ListDeletedEntitiesRequest extends Message {
  /**
   * Optional. Number of results per page. Default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0
  /**
   * Optional. Value from next_page_token obtains from a previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.ListDeletedEntitiesRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListDeletedEntitiesRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListDeletedEntitiesRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListDeletedEntitiesRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListDeletedEntitiesRequest, a, b)
  }
}
class ListDeletedEntitiesResponse extends Message {
  /**
   * List of deleted entities.
   *
   * @generated from field: repeated com.seed.entities.v1alpha.DeletedEntity deleted_entities = 1;
   */
  deletedEntities = []
  /**
   * Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.ListDeletedEntitiesResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'deleted_entities',
      kind: 'message',
      T: DeletedEntity,
      repeated: true,
    },
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListDeletedEntitiesResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListDeletedEntitiesResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListDeletedEntitiesResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListDeletedEntitiesResponse, a, b)
  }
}
class UndeleteEntityRequest extends Message {
  /**
   * Entity ID of the entity to be restored.
   * All versions will also be restored.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.UndeleteEntityRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new UndeleteEntityRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UndeleteEntityRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UndeleteEntityRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(UndeleteEntityRequest, a, b)
  }
}
class ListEntityMentionsRequest extends Message {
  /**
   * Required. ID of the entity to list mentions for.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Optional. The size of the page to return by the server.
   * The server may ignore this, and return a bigger response.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0
  /**
   * Optional. The page token to continue the pagination.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = ''
  /**
   * Optional. Whether to return the results in descending order (newest-first).
   * By default mentions are listed in the chronological order,
   * according to the *locally perceived* order of the blobs that contain the mentions.
   *
   * I.e. we sort the links according to the time we receive the blobs, not according to the time blobs claim to have been created.
   * This is to prevent losing new mentions in case of receiving out-of-date blobs.
   *
   * This flag must remain the same when paginating through the results.
   *
   * @generated from field: bool reverse_order = 4;
   */
  reverseOrder = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.ListEntityMentionsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'reverse_order',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListEntityMentionsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListEntityMentionsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListEntityMentionsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListEntityMentionsRequest, a, b)
  }
}
class ListEntityMentionsResponse extends Message {
  /**
   * Required. The list of mentions for the entity.
   *
   * @generated from field: repeated com.seed.entities.v1alpha.Mention mentions = 1;
   */
  mentions = []
  /**
   * Optional. Token for the next page if there's any.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.ListEntityMentionsResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'mentions', kind: 'message', T: Mention, repeated: true},
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListEntityMentionsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListEntityMentionsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListEntityMentionsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListEntityMentionsResponse, a, b)
  }
}
class Mention extends Message {
  /**
   * Required. The source blob where the mention was found.
   *
   * @generated from field: string source = 1;
   */
  source = ''
  /**
   * Required. The Type of the source where the mention was found.
   *
   * @generated from field: string source_type = 2;
   */
  sourceType = ''
  /**
   * Required. Context can mean different things depending on the type of the source:
   * it can be the block ID when source type is a Document or Comment,
   * it can be a pretty-path when source type is a Group that mentions a Document.
   *
   * @generated from field: string source_context = 3;
   */
  sourceContext = ''
  /**
   * Required. Information about the blob where the mention was found.
   *
   * @generated from field: com.seed.entities.v1alpha.Mention.BlobInfo source_blob = 4;
   */
  sourceBlob
  /**
   * Required. Specifies whether the link points to the exact/pinned version of the target document,
   * or if the target version is a *suggested* minimum version, and a later one should be preferred if exists.
   *
   * @generated from field: bool is_exact_version = 5;
   */
  isExactVersion = false
  /**
   * Optional. Specifies the document where the mention was found. Relevant for comments.
   *
   * @generated from field: string source_document = 6;
   */
  sourceDocument = ''
  /**
   * Optional. The version of the target Entity the link points to,
   * if one is specified in the link.
   *
   * @generated from field: string target_version = 7;
   */
  targetVersion = ''
  /**
   * Optional. The fragment portion of the link.
   *
   * @generated from field: string target_fragment = 8;
   */
  targetFragment = ''
  /**
   * Optional. The type of mention. Could be embed, link, ...
   *
   * @generated from field: string mention_type = 9;
   */
  mentionType = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.Mention'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'source',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'source_type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'source_context',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 4, name: 'source_blob', kind: 'message', T: Mention_BlobInfo},
    {
      no: 5,
      name: 'is_exact_version',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: 'source_document',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'target_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: 'target_fragment',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: 'mention_type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new Mention().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Mention().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Mention().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Mention, a, b)
  }
}
class Mention_BlobInfo extends Message {
  /**
   * The CID-formatted hash of the blob.
   *
   * @generated from field: string cid = 1;
   */
  cid = ''
  /**
   * The Account ID of the author of the blob.
   *
   * @generated from field: string author = 2;
   */
  author = ''
  /**
   * The timestamp of the blob.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.entities.v1alpha.Mention.BlobInfo'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'cid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'author',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'create_time', kind: 'message', T: Timestamp},
  ])
  static fromBinary(bytes, options) {
    return new Mention_BlobInfo().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Mention_BlobInfo().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Mention_BlobInfo().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Mention_BlobInfo, a, b)
  }
}
const Entities = {
  typeName: 'com.seed.entities.v1alpha.Entities',
  methods: {
    /**
     * Gets a change by ID.
     *
     * @generated from rpc com.seed.entities.v1alpha.Entities.GetChange
     */
    getChange: {
      name: 'GetChange',
      I: GetChangeRequest,
      O: Change,
      kind: MethodKind.Unary,
    },
    /**
     * Gets the DAG of changes for an entity.
     *
     * @generated from rpc com.seed.entities.v1alpha.Entities.GetEntityTimeline
     */
    getEntityTimeline: {
      name: 'GetEntityTimeline',
      I: GetEntityTimelineRequest,
      O: EntityTimeline,
      kind: MethodKind.Unary,
    },
    /**
     * Triggers a best-effort discovery of an entity.
     *
     * @generated from rpc com.seed.entities.v1alpha.Entities.DiscoverEntity
     */
    discoverEntity: {
      name: 'DiscoverEntity',
      I: DiscoverEntityRequest,
      O: DiscoverEntityResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Finds the list of local entities whose titles match the input string.
     * A fuzzy search is performed among documents, groups and accounts.
     * For groups and documents, we match the title, while we match alias in accounts.
     *
     * @generated from rpc com.seed.entities.v1alpha.Entities.SearchEntities
     */
    searchEntities: {
      name: 'SearchEntities',
      I: SearchEntitiesRequest,
      O: SearchEntitiesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Deletes an entity from the local node. It removes all the patches corresponding to it, including comments.
     *
     * @generated from rpc com.seed.entities.v1alpha.Entities.DeleteEntity
     */
    deleteEntity: {
      name: 'DeleteEntity',
      I: DeleteEntityRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * Lists deleted entities.
     *
     * @generated from rpc com.seed.entities.v1alpha.Entities.ListDeletedEntities
     */
    listDeletedEntities: {
      name: 'ListDeletedEntities',
      I: ListDeletedEntitiesRequest,
      O: ListDeletedEntitiesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Undo the entity delition by removing the entity from the deleted list. That entity, if available
     * will be synced back in the next syncing round (or manually discovered).
     *
     * @generated from rpc com.seed.entities.v1alpha.Entities.UndeleteEntity
     */
    undeleteEntity: {
      name: 'UndeleteEntity',
      I: UndeleteEntityRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * List mentions of a given Entity across the locally-available content.
     *
     * @generated from rpc com.seed.entities.v1alpha.Entities.ListEntityMentions
     */
    listEntityMentions: {
      name: 'ListEntityMentions',
      I: ListEntityMentionsRequest,
      O: ListEntityMentionsResponse,
      kind: MethodKind.Unary,
    },
  },
}
var ConnectionStatus = /* @__PURE__ */ ((ConnectionStatus2) => {
  ConnectionStatus2[(ConnectionStatus2['NOT_CONNECTED'] = 0)] = 'NOT_CONNECTED'
  ConnectionStatus2[(ConnectionStatus2['CONNECTED'] = 1)] = 'CONNECTED'
  ConnectionStatus2[(ConnectionStatus2['CAN_CONNECT'] = 2)] = 'CAN_CONNECT'
  ConnectionStatus2[(ConnectionStatus2['CANNOT_CONNECT'] = 3)] =
    'CANNOT_CONNECT'
  ConnectionStatus2[(ConnectionStatus2['LIMITED'] = 4)] = 'LIMITED'
  return ConnectionStatus2
})(ConnectionStatus || {})
proto3.util.setEnumType(
  ConnectionStatus,
  'com.seed.networking.v1alpha.ConnectionStatus',
  [
    {no: 0, name: 'NOT_CONNECTED'},
    {no: 1, name: 'CONNECTED'},
    {no: 2, name: 'CAN_CONNECT'},
    {no: 3, name: 'CANNOT_CONNECT'},
    {no: 4, name: 'LIMITED'},
  ],
)
class GetPeerInfoRequest extends Message {
  /**
   * Required. CID-encoded Peer ID (a.k.a. Device ID).
   *
   * @generated from field: string device_id = 1;
   */
  deviceId = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.networking.v1alpha.GetPeerInfoRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'device_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetPeerInfoRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetPeerInfoRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetPeerInfoRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetPeerInfoRequest, a, b)
  }
}
class ListPeersRequest extends Message {
  /**
   * Optional. Number of results per page. Default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0
  /**
   * Optional. Value from next_page_token obtains from a previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.networking.v1alpha.ListPeersRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'page_size',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListPeersRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListPeersRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListPeersRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListPeersRequest, a, b)
  }
}
class ListPeersResponse extends Message {
  /**
   * List of known Hyper Media peers.
   *
   * @generated from field: repeated com.seed.networking.v1alpha.PeerInfo peers = 1;
   */
  peers = []
  /**
   * Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.networking.v1alpha.ListPeersResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'peers', kind: 'message', T: PeerInfo, repeated: true},
    {
      no: 2,
      name: 'next_page_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListPeersResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListPeersResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListPeersResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListPeersResponse, a, b)
  }
}
class ConnectRequest extends Message {
  /**
   * A list of multiaddrs for the same peer ID to attempt p2p connection.
   * For example `/ip4/10.0.0.1/tcp/55000/p2p/QmDeadBeef`.
   *
   * @generated from field: repeated string addrs = 1;
   */
  addrs = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.networking.v1alpha.ConnectRequest'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'addrs', kind: 'scalar', T: 9, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new ConnectRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ConnectRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ConnectRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ConnectRequest, a, b)
  }
}
class ConnectResponse extends Message {
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.networking.v1alpha.ConnectResponse'
  static fields = proto3.util.newFieldList(() => [])
  static fromBinary(bytes, options) {
    return new ConnectResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ConnectResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ConnectResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ConnectResponse, a, b)
  }
}
class PeerInfo extends Message {
  /**
   * Libp2p peer ID.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Account ID that this peer is bound to.
   *
   * @generated from field: string account_id = 2;
   */
  accountId = ''
  /**
   * List of known multiaddrs of the request peer.
   *
   * @generated from field: repeated string addrs = 3;
   */
  addrs = []
  /**
   * Connection status of our node with a remote peer.
   *
   * @generated from field: com.seed.networking.v1alpha.ConnectionStatus connection_status = 4;
   */
  connectionStatus = 0
  /**
   * Whether this peer was a direct connection or someone else shared it with us.
   *
   * @generated from field: bool is_direct = 5;
   */
  isDirect = false
  /**
   * When we first inserted that peer in the database.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt
  /**
   * When the peer updated its addresses for the last time.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 7;
   */
  updatedAt
  /**
   * Seed protocol version the peer talks.
   *
   * @generated from field: string protocol = 9;
   */
  protocol = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.networking.v1alpha.PeerInfo'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'account_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {no: 3, name: 'addrs', kind: 'scalar', T: 9, repeated: true},
    {
      no: 4,
      name: 'connection_status',
      kind: 'enum',
      T: proto3.getEnumType(ConnectionStatus),
    },
    {
      no: 5,
      name: 'is_direct',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {no: 6, name: 'created_at', kind: 'message', T: Timestamp},
    {no: 7, name: 'updated_at', kind: 'message', T: Timestamp},
    {
      no: 9,
      name: 'protocol',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new PeerInfo().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new PeerInfo().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new PeerInfo().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(PeerInfo, a, b)
  }
}
const Networking = {
  typeName: 'com.seed.networking.v1alpha.Networking',
  methods: {
    /**
     * Lookup details about a known peer.
     *
     * @generated from rpc com.seed.networking.v1alpha.Networking.GetPeerInfo
     */
    getPeerInfo: {
      name: 'GetPeerInfo',
      I: GetPeerInfoRequest,
      O: PeerInfo,
      kind: MethodKind.Unary,
    },
    /**
     * List peers by status.
     *
     * @generated from rpc com.seed.networking.v1alpha.Networking.ListPeers
     */
    listPeers: {
      name: 'ListPeers',
      I: ListPeersRequest,
      O: ListPeersResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Establishes a direct connection with a given peer explicitly.
     *
     * @generated from rpc com.seed.networking.v1alpha.Networking.Connect
     */
    connect: {
      name: 'Connect',
      I: ConnectRequest,
      O: ConnectResponse,
      kind: MethodKind.Unary,
    },
  },
}
class InvoiceResponse extends Message {
  /**
   * String representation of a bolt11 invoice payment request.
   *
   * @generated from field: string payreq = 1;
   */
  payreq = ''
  /**
   * Payment Hash of the invoice.
   *
   * @generated from field: string payment_hash = 2;
   */
  paymentHash = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.InvoiceResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'payreq',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'payment_hash',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new InvoiceResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new InvoiceResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new InvoiceResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(InvoiceResponse, a, b)
  }
}
class DecodeInvoiceRequest extends Message {
  /**
   * String representation of a bolt11 invoice payment request.
   *
   * @generated from field: string payreq = 1;
   */
  payreq = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.DecodeInvoiceRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'payreq',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new DecodeInvoiceRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new DecodeInvoiceRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new DecodeInvoiceRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(DecodeInvoiceRequest, a, b)
  }
}
class CreateInvoiceRequest extends Message {
  /**
   * Optional. The account we are creating the invoice from. The default wallet
   * from that account will be used to issue the invoice. If the user wants to
   * select an espedific wallet, then account must be blank and the user must
   * provide a wallet id.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Optional. In case account is not provided, the especific walletID
   * to issue an invoice from.
   *
   * @generated from field: string id = 2;
   */
  id = ''
  /**
   * Required. The amount in satoshis we want the invoice.
   *
   * @generated from field: int64 amount = 3;
   */
  amount = protoInt64.zero
  /**
   * Optional. Description we want to include in the invoice.
   *
   * @generated from field: string memo = 4;
   */
  memo = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.CreateInvoiceRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'amount',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: 'memo',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new CreateInvoiceRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateInvoiceRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateInvoiceRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(CreateInvoiceRequest, a, b)
  }
}
class PayInvoiceRequest extends Message {
  /**
   * Required. The payment request in plaintext representing the bolt-11 invoice to be paid
   *
   * @generated from field: string payreq = 1;
   */
  payreq = ''
  /**
   * Optional. The account used to pay this invoice. The default wallet of this account will
   * be used. If not provided, then an specific wallet ID must be provided
   *
   * @generated from field: string account = 2;
   */
  account = ''
  /**
   * Optional. Wallet id to pay the invoice with
   *
   * @generated from field: string id = 3;
   */
  id = ''
  /**
   * Optional. Amount in satoshis to pay. This should match the amount in the invoice.
   * For zero-amount invoices, the user can put whatever amount it wants.
   *
   * @generated from field: int64 amount = 4;
   */
  amount = protoInt64.zero
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.PayInvoiceRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'payreq',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'amount',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
  ])
  static fromBinary(bytes, options) {
    return new PayInvoiceRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new PayInvoiceRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new PayInvoiceRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(PayInvoiceRequest, a, b)
  }
}
class RequestLud6InvoiceRequest extends Message {
  /**
   * Required. URL associated with the ln server.
   *
   * @generated from field: string URL = 1;
   */
  URL = ''
  /**
   * Required. User to pay.
   *
   * @generated from field: string user = 2;
   */
  user = ''
  /**
   * Required. Amount in satohis.
   *
   * @generated from field: int64 amount = 3;
   */
  amount = protoInt64.zero
  /**
   * Optional. String to be attached in the invoice.
   *
   * @generated from field: string memo = 4;
   */
  memo = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.RequestLud6InvoiceRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'URL',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'user',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'amount',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: 'memo',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new RequestLud6InvoiceRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new RequestLud6InvoiceRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new RequestLud6InvoiceRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(RequestLud6InvoiceRequest, a, b)
  }
}
class GetLnAddressRequest extends Message {
  /**
   * Required. The wallet ID we want to know the lnaddress from.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.GetLnAddressRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetLnAddressRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetLnAddressRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetLnAddressRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetLnAddressRequest, a, b)
  }
}
class LNAddress extends Message {
  /**
   * Required. The account we want to know the lnaddress from.
   *
   * @generated from field: string address = 1;
   */
  address = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.LNAddress'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'address',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new LNAddress().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new LNAddress().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new LNAddress().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(LNAddress, a, b)
  }
}
class UpdateLNAddressRequest extends Message {
  /**
   * Required. The wallet we want to change its lnaddress. Not all wallets
   * support lnaddresses
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Required. The nickname of the new lnadress. The resultin lnaddress would be
   * <new_nickname>@<lnurl>
   *
   * @generated from field: string nickname = 2;
   */
  nickname = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.UpdateLNAddressRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'nickname',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new UpdateLNAddressRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UpdateLNAddressRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UpdateLNAddressRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(UpdateLNAddressRequest, a, b)
  }
}
class ListInvoicesRequest extends Message {
  /**
   * Required. The wallet id from where we want the list of paid invoices
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.ListInvoicesRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListInvoicesRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListInvoicesRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListInvoicesRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListInvoicesRequest, a, b)
  }
}
class Invoice extends Message {
  /**
   * The hash of the invoice. Unique identifier of the invoice
   *
   * @generated from field: string payment_hash = 1;
   */
  paymentHash = ''
  /**
   * The string representation of the invoice
   *
   * @generated from field: string payment_request = 2;
   */
  paymentRequest = ''
  /**
   * The description/memo/purpose of the invoice
   *
   * @generated from field: string description = 3;
   */
  description = ''
  /**
   * The description hash
   *
   * @generated from field: string description_hash = 4;
   */
  descriptionHash = ''
  /**
   * The preimage revealed upon settlement. Proof of payment.
   *
   * @generated from field: string payment_preimage = 5;
   */
  paymentPreimage = ''
  /**
   * The destination node of the payment.
   *
   * @generated from field: string destination = 6;
   */
  destination = ''
  /**
   * The amount in satoshis of the payment.
   *
   * @generated from field: int64 amount = 7;
   */
  amount = protoInt64.zero
  /**
   * The fees paid in satoshis.
   *
   * @generated from field: int64 fee = 8;
   */
  fee = protoInt64.zero
  /**
   * The satus of the invoice.
   *
   * @generated from field: string status = 9;
   */
  status = ''
  /**
   * The type of invoice.
   *
   * @generated from field: string type = 10;
   */
  type = ''
  /**
   * Error message (if any) of the transaction.
   *
   * @generated from field: string error_message = 11;
   */
  errorMessage = ''
  /**
   * When the invoice was settled
   *
   * @generated from field: string settled_at = 12;
   */
  settledAt = ''
  /**
   * When the invoice expires (if unpaid).
   *
   * @generated from field: string expires_at = 13;
   */
  expiresAt = ''
  /**
   * Whether or not the invoice has been paid.
   *
   * @generated from field: bool is_paid = 14;
   */
  isPaid = false
  /**
   * Whether or not this is a keysed payment.
   *
   * @generated from field: bool keysend = 15;
   */
  keysend = false
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.Invoice'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'payment_hash',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'payment_request',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'description',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'description_hash',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'payment_preimage',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'destination',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'amount',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 8,
      name: 'fee',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 9,
      name: 'status',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: 'type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: 'error_message',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: 'settled_at',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: 'expires_at',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 14,
      name: 'is_paid',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 15,
      name: 'keysend',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ])
  static fromBinary(bytes, options) {
    return new Invoice().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Invoice().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Invoice().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Invoice, a, b)
  }
}
class ListInvoicesResponse extends Message {
  /**
   * Required. The wallet id from where we want the list of paid invoices
   *
   * @generated from field: repeated com.seed.payments.v1alpha.Invoice invoices = 1;
   */
  invoices = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.ListInvoicesResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'invoices', kind: 'message', T: Invoice, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new ListInvoicesResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListInvoicesResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListInvoicesResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListInvoicesResponse, a, b)
  }
}
const Invoices = {
  typeName: 'com.seed.payments.v1alpha.Invoices',
  methods: {
    /**
     * CreateInvoice creates a local invoice. Used to get paid. Typicaly
     * seed users will call this remotely bc they don't know the lnaddress
     * of the receiver, just their seed account. The local node, upon the
     * request, issues an invoice.
     *
     * @generated from rpc com.seed.payments.v1alpha.Invoices.CreateInvoice
     */
    createInvoice: {
      name: 'CreateInvoice',
      I: CreateInvoiceRequest,
      O: InvoiceResponse,
      kind: MethodKind.Unary,
    },
    /**
     * PayInvoice Pays a bolt11 invoice.
     *
     * @generated from rpc com.seed.payments.v1alpha.Invoices.PayInvoice
     */
    payInvoice: {
      name: 'PayInvoice',
      I: PayInvoiceRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * ListPaidInvoices Pays a bolt11 invoice.
     *
     * @generated from rpc com.seed.payments.v1alpha.Invoices.ListPaidInvoices
     */
    listPaidInvoices: {
      name: 'ListPaidInvoices',
      I: ListInvoicesRequest,
      O: ListInvoicesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * DecodeInvoice decodes an invoice .
     *
     * @generated from rpc com.seed.payments.v1alpha.Invoices.DecodeInvoice
     */
    decodeInvoice: {
      name: 'DecodeInvoice',
      I: DecodeInvoiceRequest,
      O: Invoice,
      kind: MethodKind.Unary,
    },
    /**
     * ListReceivedInvoices Lists received payments.
     *
     * @generated from rpc com.seed.payments.v1alpha.Invoices.ListReceivedInvoices
     */
    listReceivedInvoices: {
      name: 'ListReceivedInvoices',
      I: ListInvoicesRequest,
      O: ListInvoicesResponse,
      kind: MethodKind.Unary,
    },
  },
}
;({
  methods: {
    /**
     * Request an invoice following the LNURL lud6 protocol
     * (https://github.com/lnurl/luds/blob/luds/06.md). This does not require the
     * caller to log in anywhere. Used to pay.
     *
     * @generated from rpc com.seed.payments.v1alpha.LNURL.RequestLud6Invoice
     */
    requestLud6Invoice: {
      kind: MethodKind.Unary,
    },
    /**
     * GetLnAddress gets the lnaddress (https://lightningaddress.com/) associated
     * with a wallet. Not all wallets are lnaddress compatible.
     *
     * @generated from rpc com.seed.payments.v1alpha.LNURL.GetLnAddress
     */
    getLnAddress: {
      kind: MethodKind.Unary,
    },
    /**
     * UpdateLNAddress change the lnaddress of a specific wallet.
     * LNaddress must be globally unique (like email addresses).
     *
     * @generated from rpc com.seed.payments.v1alpha.LNURL.UpdateLNAddress
     */
    updateLNAddress: {
      kind: MethodKind.Unary,
    },
  },
})
class Wallet extends Message {
  /**
   * Unique wallet identificator. Automatically generated. Unique across accounts.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * The account this wallet belongs to.
   *
   * @generated from field: string account = 2;
   */
  account = ''
  /**
   * Address of the LND node backing up this wallet. In case lndhub, this will be the
   * URL to connect via rest api. In case LND wallet, this will be the gRPC address.
   *
   * @generated from field: string address = 3;
   */
  address = ''
  /**
   * The name of the wallet.
   *
   * @generated from field: string name = 4;
   */
  name = ''
  /**
   * The type of the wallet.
   *
   * @generated from field: string type = 5;
   */
  type = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.Wallet'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'address',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new Wallet().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new Wallet().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new Wallet().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(Wallet, a, b)
  }
}
class CreateWalletRequest extends Message {
  /**
   * Required. The account we are creating the wallet to.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  /**
   * Required. Name of the wallet to be created.
   *
   * @generated from field: string name = 2;
   */
  name = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.CreateWalletRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new CreateWalletRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new CreateWalletRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new CreateWalletRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(CreateWalletRequest, a, b)
  }
}
class ImportWalletRequest extends Message {
  /**
   * Required. The credentials to insert the new wallet in the format of
   * <wallet_type>://<alphanumeric_login>:<alphanumeric_password>@https://<domain>
   *
   * @generated from field: string credentials_url = 1;
   */
  credentialsUrl = ''
  /**
   * Required. Account where this wallet will belong to.
   *
   * @generated from field: string account = 2;
   */
  account = ''
  /**
   * Required. The wallet name to be displayed.
   *
   * @generated from field: string name = 3;
   */
  name = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.ImportWalletRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'credentials_url',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ImportWalletRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ImportWalletRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ImportWalletRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ImportWalletRequest, a, b)
  }
}
class ExportWalletResponse extends Message {
  /**
   * The credentials url to be used with a compatible 3rd party app.
   *
   * @generated from field: string credentials = 1;
   */
  credentials = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.ExportWalletResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'credentials',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ExportWalletResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ExportWalletResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ExportWalletResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ExportWalletResponse, a, b)
  }
}
class WalletRequest extends Message {
  /**
   * Required. Id of the wallet to operate with
   *
   * @generated from field: string id = 1;
   */
  id = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.WalletRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new WalletRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new WalletRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new WalletRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(WalletRequest, a, b)
  }
}
class GetWalletBalanceResponse extends Message {
  /**
   * The wallet's balance in satohis.
   *
   * @generated from field: uint64 balance = 1;
   */
  balance = protoInt64.zero
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.GetWalletBalanceResponse'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'balance',
      kind: 'scalar',
      T: 4,
      /* ScalarType.UINT64 */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetWalletBalanceResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetWalletBalanceResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetWalletBalanceResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetWalletBalanceResponse, a, b)
  }
}
class ListWalletsRequest extends Message {
  /**
   * Required. Account to list wallets from.
   *
   * @generated from field: string account = 1;
   */
  account = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.ListWalletsRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new ListWalletsRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListWalletsRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListWalletsRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListWalletsRequest, a, b)
  }
}
class ListWalletsResponse extends Message {
  /**
   * Wallets under the account.
   *
   * @generated from field: repeated com.seed.payments.v1alpha.Wallet wallets = 1;
   */
  wallets = []
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.ListWalletsResponse'
  static fields = proto3.util.newFieldList(() => [
    {no: 1, name: 'wallets', kind: 'message', T: Wallet, repeated: true},
  ])
  static fromBinary(bytes, options) {
    return new ListWalletsResponse().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new ListWalletsResponse().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new ListWalletsResponse().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(ListWalletsResponse, a, b)
  }
}
class UpdateWalletNameRequest extends Message {
  /**
   * Required. The wallet id to be modified.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Required. The new wallet's name.
   *
   * @generated from field: string name = 2;
   */
  name = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.UpdateWalletNameRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new UpdateWalletNameRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new UpdateWalletNameRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new UpdateWalletNameRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(UpdateWalletNameRequest, a, b)
  }
}
class GetDefaultWalletRequest extends Message {
  /**
   * @generated from field: string account = 1;
   */
  account = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.GetDefaultWalletRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new GetDefaultWalletRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new GetDefaultWalletRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new GetDefaultWalletRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(GetDefaultWalletRequest, a, b)
  }
}
class SetDefaultWalletRequest extends Message {
  /**
   * Required. The wallet id to set as default.
   *
   * @generated from field: string id = 1;
   */
  id = ''
  /**
   * Required. The account the provided wallet is going to
   * be the default.
   *
   * @generated from field: string account = 2;
   */
  account = ''
  constructor(data) {
    super()
    proto3.util.initPartial(data, this)
  }
  static runtime = proto3
  static typeName = 'com.seed.payments.v1alpha.SetDefaultWalletRequest'
  static fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'account',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ])
  static fromBinary(bytes, options) {
    return new SetDefaultWalletRequest().fromBinary(bytes, options)
  }
  static fromJson(jsonValue, options) {
    return new SetDefaultWalletRequest().fromJson(jsonValue, options)
  }
  static fromJsonString(jsonString, options) {
    return new SetDefaultWalletRequest().fromJsonString(jsonString, options)
  }
  static equals(a, b) {
    return proto3.util.equals(SetDefaultWalletRequest, a, b)
  }
}
const Wallets = {
  typeName: 'com.seed.payments.v1alpha.Wallets',
  methods: {
    /**
     * CreateWallet Created a seed wallet based on mnemonics.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.CreateWallet
     */
    createWallet: {
      name: 'CreateWallet',
      I: CreateWalletRequest,
      O: Wallet,
      kind: MethodKind.Unary,
    },
    /**
     * RemoveWallet deletes a wallet locally. It can be later imported
     * with the necessary credentials and no funds will be lost.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.RemoveWallet
     */
    removeWallet: {
      name: 'RemoveWallet',
      I: WalletRequest,
      O: Empty,
      kind: MethodKind.Unary,
    },
    /**
     * ImportWallet Imports a 3rd party (compatible) wallet with credentials.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.ImportWallet
     */
    importWallet: {
      name: 'ImportWallet',
      I: ImportWalletRequest,
      O: Wallet,
      kind: MethodKind.Unary,
    },
    /**
     * ExportWallet Export the wallet credentials so they can be imported and
     * used with a 3rd party compatible app.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.ExportWallet
     */
    exportWallet: {
      name: 'ExportWallet',
      I: WalletRequest,
      O: ExportWalletResponse,
      kind: MethodKind.Unary,
    },
    /**
     * ListWallets lists all available wallets for the account.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.GetWalletBalance
     */
    getWalletBalance: {
      name: 'GetWalletBalance',
      I: WalletRequest,
      O: GetWalletBalanceResponse,
      kind: MethodKind.Unary,
    },
    /**
     * ListWallets lists all available wallets for the account.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.ListWallets
     */
    listWallets: {
      name: 'ListWallets',
      I: ListWalletsRequest,
      O: ListWalletsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * GetWallet gets a specific wallet.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.GetWallet
     */
    getWallet: {
      name: 'GetWallet',
      I: WalletRequest,
      O: Wallet,
      kind: MethodKind.Unary,
    },
    /**
     * UpdateWalletName changes the name of the wallet. This does not have any
     * implications on payments. Name is just for user convenience.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.UpdateWalletName
     */
    updateWalletName: {
      name: 'UpdateWalletName',
      I: UpdateWalletNameRequest,
      O: Wallet,
      kind: MethodKind.Unary,
    },
    /**
     * GetDefaultWallet returns the default wallet where payments are going
     * to be collected at. Also, this wallet will be used to make payments.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.GetDefaultWallet
     */
    getDefaultWallet: {
      name: 'GetDefaultWallet',
      I: GetDefaultWalletRequest,
      O: Wallet,
      kind: MethodKind.Unary,
    },
    /**
     * SetDefaultWallet changes the default wallet where payments are going
     * to be collected at. Also, this wallet will be used to make payments.
     *
     * @generated from rpc com.seed.payments.v1alpha.Wallets.SetDefaultWallet
     */
    setDefaultWallet: {
      name: 'SetDefaultWallet',
      I: SetDefaultWalletRequest,
      O: Wallet,
      kind: MethodKind.Unary,
    },
  },
}
var lodash$1 = {exports: {}}
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports
var hasRequiredLodash
function requireLodash() {
  if (hasRequiredLodash) return lodash$1.exports
  hasRequiredLodash = 1
  ;(function (module, exports) {
    ;(function () {
      var undefined$1
      var VERSION2 = '4.17.21'
      var LARGE_ARRAY_SIZE = 200
      var CORE_ERROR_TEXT =
          'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
        FUNC_ERROR_TEXT = 'Expected a function',
        INVALID_TEMPL_VAR_ERROR_TEXT =
          'Invalid `variable` option passed into `_.template`'
      var HASH_UNDEFINED = '__lodash_hash_undefined__'
      var MAX_MEMOIZE_SIZE = 500
      var PLACEHOLDER = '__lodash_placeholder__'
      var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4
      var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2
      var WRAP_BIND_FLAG = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512
      var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = '...'
      var HOT_COUNT = 800,
        HOT_SPAN = 16
      var LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2,
        LAZY_WHILE_FLAG = 3
      var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 17976931348623157e292,
        NAN = 0 / 0
      var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1
      var wrapFlags = [
        ['ary', WRAP_ARY_FLAG],
        ['bind', WRAP_BIND_FLAG],
        ['bindKey', WRAP_BIND_KEY_FLAG],
        ['curry', WRAP_CURRY_FLAG],
        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
        ['flip', WRAP_FLIP_FLAG],
        ['partial', WRAP_PARTIAL_FLAG],
        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
        ['rearg', WRAP_REARG_FLAG],
      ]
      var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        domExcTag = '[object DOMException]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]',
        weakSetTag = '[object WeakSet]'
      var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]'
      var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
        reUnescapedHtml = /[&<>"']/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source)
      var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName =
          /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source)
      var reTrimStart = /^\s+/
      var reWhitespace = /\s/
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/
      var reEscapeChar = /\\(\\)?/g
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g
      var reFlags = /\w*$/
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i
      var reIsBinary = /^0b[01]+$/i
      var reIsHostCtor = /^\[object .+?Constructor\]$/
      var reIsOctal = /^0o[0-7]+$/i
      var reIsUint = /^(?:0|[1-9]\d*)$/
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g
      var reNoMatch = /($^)/
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g
      var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange =
          rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange =
          ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange = '\\ufe0e\\ufe0f',
        rsBreakRange =
          rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange
      var rsApos = "[']",
        rsAstral = '[' + rsAstralRange + ']',
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc =
          '[^' +
          rsAstralRange +
          rsBreakRange +
          rsDigits +
          rsDingbatRange +
          rsLowerRange +
          rsUpperRange +
          ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ = '\\u200d'
      var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin =
          '(?:' +
          rsZWJ +
          '(?:' +
          [rsNonAstral, rsRegional, rsSurrPair].join('|') +
          ')' +
          rsOptVar +
          reOptMod +
          ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji =
          '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
        rsSymbol =
          '(?:' +
          [
            rsNonAstral + rsCombo + '?',
            rsCombo,
            rsRegional,
            rsSurrPair,
            rsAstral,
          ].join('|') +
          ')'
      var reApos = RegExp(rsApos, 'g')
      var reComboMark = RegExp(rsCombo, 'g')
      var reUnicode = RegExp(
        rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq,
        'g',
      )
      var reUnicodeWord = RegExp(
        [
          rsUpper +
            '?' +
            rsLower +
            '+' +
            rsOptContrLower +
            '(?=' +
            [rsBreak, rsUpper, '$'].join('|') +
            ')',
          rsMiscUpper +
            '+' +
            rsOptContrUpper +
            '(?=' +
            [rsBreak, rsUpper + rsMiscLower, '$'].join('|') +
            ')',
          rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
          rsUpper + '+' + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji,
        ].join('|'),
        'g',
      )
      var reHasUnicode = RegExp(
        '[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']',
      )
      var reHasUnicodeWord =
        /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/
      var contextProps = [
        'Array',
        'Buffer',
        'DataView',
        'Date',
        'Error',
        'Float32Array',
        'Float64Array',
        'Function',
        'Int8Array',
        'Int16Array',
        'Int32Array',
        'Map',
        'Math',
        'Object',
        'Promise',
        'RegExp',
        'Set',
        'String',
        'Symbol',
        'TypeError',
        'Uint8Array',
        'Uint8ClampedArray',
        'Uint16Array',
        'Uint32Array',
        'WeakMap',
        '_',
        'clearTimeout',
        'isFinite',
        'parseInt',
        'setTimeout',
      ]
      var templateCounter = -1
      var typedArrayTags = {}
      typedArrayTags[float32Tag] =
        typedArrayTags[float64Tag] =
        typedArrayTags[int8Tag] =
        typedArrayTags[int16Tag] =
        typedArrayTags[int32Tag] =
        typedArrayTags[uint8Tag] =
        typedArrayTags[uint8ClampedTag] =
        typedArrayTags[uint16Tag] =
        typedArrayTags[uint32Tag] =
          true
      typedArrayTags[argsTag] =
        typedArrayTags[arrayTag] =
        typedArrayTags[arrayBufferTag] =
        typedArrayTags[boolTag] =
        typedArrayTags[dataViewTag] =
        typedArrayTags[dateTag] =
        typedArrayTags[errorTag] =
        typedArrayTags[funcTag] =
        typedArrayTags[mapTag] =
        typedArrayTags[numberTag] =
        typedArrayTags[objectTag] =
        typedArrayTags[regexpTag] =
        typedArrayTags[setTag] =
        typedArrayTags[stringTag] =
        typedArrayTags[weakMapTag] =
          false
      var cloneableTags = {}
      cloneableTags[argsTag] =
        cloneableTags[arrayTag] =
        cloneableTags[arrayBufferTag] =
        cloneableTags[dataViewTag] =
        cloneableTags[boolTag] =
        cloneableTags[dateTag] =
        cloneableTags[float32Tag] =
        cloneableTags[float64Tag] =
        cloneableTags[int8Tag] =
        cloneableTags[int16Tag] =
        cloneableTags[int32Tag] =
        cloneableTags[mapTag] =
        cloneableTags[numberTag] =
        cloneableTags[objectTag] =
        cloneableTags[regexpTag] =
        cloneableTags[setTag] =
        cloneableTags[stringTag] =
        cloneableTags[symbolTag] =
        cloneableTags[uint8Tag] =
        cloneableTags[uint8ClampedTag] =
        cloneableTags[uint16Tag] =
        cloneableTags[uint32Tag] =
          true
      cloneableTags[errorTag] =
        cloneableTags[funcTag] =
        cloneableTags[weakMapTag] =
          false
      var deburredLetters = {
        // Latin-1 Supplement block.
        : 'A',
        : 'A',
        : 'A',
        : 'A',
        : 'A',
        : 'A',
        : 'a',
        : 'a',
        : 'a',
        : 'a',
        : 'a',
        : 'a',
        : 'C',
        : 'c',
        : 'D',
        : 'd',
        : 'E',
        : 'E',
        : 'E',
        : 'E',
        : 'e',
        : 'e',
        : 'e',
        : 'e',
        : 'I',
        : 'I',
        : 'I',
        : 'I',
        : 'i',
        : 'i',
        : 'i',
        : 'i',
        : 'N',
        : 'n',
        : 'O',
        : 'O',
        : 'O',
        : 'O',
        : 'O',
        : 'O',
        : 'o',
        : 'o',
        : 'o',
        : 'o',
        : 'o',
        : 'o',
        : 'U',
        : 'U',
        : 'U',
        : 'U',
        : 'u',
        : 'u',
        : 'u',
        : 'u',
        : 'Y',
        : 'y',
        : 'y',
        : 'Ae',
        : 'ae',
        : 'Th',
        : 'th',
        : 'ss',
        // Latin Extended-A block.
        : 'A',
        : 'A',
        : 'A',
        : 'a',
        : 'a',
        : 'a',
        : 'C',
        : 'C',
        : 'C',
        : 'C',
        : 'c',
        : 'c',
        : 'c',
        : 'c',
        : 'D',
        : 'D',
        : 'd',
        : 'd',
        : 'E',
        : 'E',
        : 'E',
        : 'E',
        : 'E',
        : 'e',
        : 'e',
        : 'e',
        : 'e',
        : 'e',
        : 'G',
        : 'G',
        : 'G',
        : 'G',
        : 'g',
        : 'g',
        : 'g',
        : 'g',
        : 'H',
        : 'H',
        : 'h',
        : 'h',
        : 'I',
        : 'I',
        : 'I',
        : 'I',
        : 'I',
        : 'i',
        : 'i',
        : 'i',
        : 'i',
        : 'i',
        : 'J',
        : 'j',
        : 'K',
        : 'k',
        : 'k',
        : 'L',
        : 'L',
        : 'L',
        : 'L',
        : 'L',
        : 'l',
        : 'l',
        : 'l',
        : 'l',
        : 'l',
        : 'N',
        : 'N',
        : 'N',
        : 'N',
        : 'n',
        : 'n',
        : 'n',
        : 'n',
        : 'O',
        : 'O',
        : 'O',
        : 'o',
        : 'o',
        : 'o',
        : 'R',
        : 'R',
        : 'R',
        : 'r',
        : 'r',
        : 'r',
        : 'S',
        : 'S',
        : 'S',
        : 'S',
        : 's',
        : 's',
        : 's',
        : 's',
        : 'T',
        : 'T',
        : 'T',
        : 't',
        : 't',
        : 't',
        : 'U',
        : 'U',
        : 'U',
        : 'U',
        : 'U',
        : 'U',
        : 'u',
        : 'u',
        : 'u',
        : 'u',
        : 'u',
        : 'u',
        : 'W',
        : 'w',
        : 'Y',
        : 'y',
        : 'Y',
        : 'Z',
        : 'Z',
        : 'Z',
        : 'z',
        : 'z',
        : 'z',
        : 'IJ',
        : 'ij',
        : 'Oe',
        : 'oe',
        : "'n",
        : 's',
      }
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
      }
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
      }
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029',
      }
      var freeParseFloat = parseFloat,
        freeParseInt = parseInt
      var freeGlobal =
        typeof commonjsGlobal == 'object' &&
        commonjsGlobal &&
        commonjsGlobal.Object === Object &&
        commonjsGlobal
      var freeSelf =
        typeof self == 'object' && self && self.Object === Object && self
      var root = freeGlobal || freeSelf || Function('return this')()
      var freeExports = exports && !exports.nodeType && exports
      var freeModule =
        freeExports && true && module && !module.nodeType && module
      var moduleExports = freeModule && freeModule.exports === freeExports
      var freeProcess = moduleExports && freeGlobal.process
      var nodeUtil = (function () {
        try {
          var types =
            freeModule && freeModule.require && freeModule.require('util').types
          if (types) {
            return types
          }
          return (
            freeProcess && freeProcess.binding && freeProcess.binding('util')
          )
        } catch (e) {}
      })()
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
        nodeIsDate = nodeUtil && nodeUtil.isDate,
        nodeIsMap = nodeUtil && nodeUtil.isMap,
        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
        nodeIsSet = nodeUtil && nodeUtil.isSet,
        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg)
          case 1:
            return func.call(thisArg, args[0])
          case 2:
            return func.call(thisArg, args[0], args[1])
          case 3:
            return func.call(thisArg, args[0], args[1], args[2])
        }
        return func.apply(thisArg, args)
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
          length = array == null ? 0 : array.length
        while (++index < length) {
          var value = array[index]
          setter(accumulator, value, iteratee(value), array)
        }
        return accumulator
      }
      function arrayEach(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break
          }
        }
        return array
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break
          }
        }
        return array
      }
      function arrayEvery(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false
          }
        }
        return true
      }
      function arrayFilter(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = []
        while (++index < length) {
          var value = array[index]
          if (predicate(value, index, array)) {
            result[resIndex++] = value
          }
        }
        return result
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length
        return !!length && baseIndexOf(array, value, 0) > -1
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
          length = array == null ? 0 : array.length
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true
          }
        }
        return false
      }
      function arrayMap(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length)
        while (++index < length) {
          result[index] = iteratee(array[index], index, array)
        }
        return result
      }
      function arrayPush(array, values) {
        var index = -1,
          length = values.length,
          offset = array.length
        while (++index < length) {
          array[offset + index] = values[index]
        }
        return array
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
          length = array == null ? 0 : array.length
        if (initAccum && length) {
          accumulator = array[++index]
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array)
        }
        return accumulator
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length
        if (initAccum && length) {
          accumulator = array[--length]
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array)
        }
        return accumulator
      }
      function arraySome(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true
          }
        }
        return false
      }
      var asciiSize = baseProperty('length')
      function asciiToArray(string) {
        return string.split('')
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || []
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result
        eachFunc(collection, function (value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key
            return false
          }
        })
        return result
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1)
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index
          }
        }
        return -1
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value
          ? strictIndexOf(array, value, fromIndex)
          : baseFindIndex(array, baseIsNaN, fromIndex)
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
          length = array.length
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index
          }
        }
        return -1
      }
      function baseIsNaN(value) {
        return value !== value
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length
        return length ? baseSum(array, iteratee) / length : NAN
      }
      function baseProperty(key) {
        return function (object) {
          return object == null ? undefined$1 : object[key]
        }
      }
      function basePropertyOf(object) {
        return function (key) {
          return object == null ? undefined$1 : object[key]
        }
      }
      function baseReduce(
        collection,
        iteratee,
        accumulator,
        initAccum,
        eachFunc,
      ) {
        eachFunc(collection, function (value, index, collection2) {
          accumulator = initAccum
            ? ((initAccum = false), value)
            : iteratee(accumulator, value, index, collection2)
        })
        return accumulator
      }
      function baseSortBy(array, comparer) {
        var length = array.length
        array.sort(comparer)
        while (length--) {
          array[length] = array[length].value
        }
        return array
      }
      function baseSum(array, iteratee) {
        var result,
          index = -1,
          length = array.length
        while (++index < length) {
          var current = iteratee(array[index])
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current
          }
        }
        return result
      }
      function baseTimes(n, iteratee) {
        var index = -1,
          result = Array(n)
        while (++index < n) {
          result[index] = iteratee(index)
        }
        return result
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function (key) {
          return [key, object[key]]
        })
      }
      function baseTrim(string) {
        return string
          ? string
              .slice(0, trimmedEndIndex(string) + 1)
              .replace(reTrimStart, '')
          : string
      }
      function baseUnary(func) {
        return function (value) {
          return func(value)
        }
      }
      function baseValues(object, props) {
        return arrayMap(props, function (key) {
          return object[key]
        })
      }
      function cacheHas(cache2, key) {
        return cache2.has(key)
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
          length = strSymbols.length
        while (
          ++index < length &&
          baseIndexOf(chrSymbols, strSymbols[index], 0) > -1
        ) {}
        return index
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index
      }
      function countHolders(array, placeholder) {
        var length = array.length,
          result = 0
        while (length--) {
          if (array[length] === placeholder) {
            ++result
          }
        }
        return result
      }
      var deburrLetter = basePropertyOf(deburredLetters)
      var escapeHtmlChar = basePropertyOf(htmlEscapes)
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr]
      }
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key]
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string)
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string)
      }
      function iteratorToArray(iterator) {
        var data,
          result = []
        while (!(data = iterator.next()).done) {
          result.push(data.value)
        }
        return result
      }
      function mapToArray(map) {
        var index = -1,
          result = Array(map.size)
        map.forEach(function (value, key) {
          result[++index] = [key, value]
        })
        return result
      }
      function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg))
        }
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
          length = array.length,
          resIndex = 0,
          result = []
        while (++index < length) {
          var value = array[index]
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER
            result[resIndex++] = index
          }
        }
        return result
      }
      function setToArray(set) {
        var index = -1,
          result = Array(set.size)
        set.forEach(function (value) {
          result[++index] = value
        })
        return result
      }
      function setToPairs(set) {
        var index = -1,
          result = Array(set.size)
        set.forEach(function (value) {
          result[++index] = [value, value]
        })
        return result
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
          length = array.length
        while (++index < length) {
          if (array[index] === value) {
            return index
          }
        }
        return -1
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1
        while (index--) {
          if (array[index] === value) {
            return index
          }
        }
        return index
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string)
      }
      function stringToArray(string) {
        return hasUnicode(string)
          ? unicodeToArray(string)
          : asciiToArray(string)
      }
      function trimmedEndIndex(string) {
        var index = string.length
        while (index-- && reWhitespace.test(string.charAt(index))) {}
        return index
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes)
      function unicodeSize(string) {
        var result = (reUnicode.lastIndex = 0)
        while (reUnicode.test(string)) {
          ++result
        }
        return result
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || []
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || []
      }
      var runInContext = function runInContext2(context) {
        context =
          context == null
            ? root
            : _.defaults(root.Object(), context, _.pick(root, contextProps))
        var Array2 = context.Array,
          Date2 = context.Date,
          Error2 = context.Error,
          Function2 = context.Function,
          Math2 = context.Math,
          Object2 = context.Object,
          RegExp2 = context.RegExp,
          String2 = context.String,
          TypeError = context.TypeError
        var arrayProto = Array2.prototype,
          funcProto = Function2.prototype,
          objectProto = Object2.prototype
        var coreJsData = context['__core-js_shared__']
        var funcToString = funcProto.toString
        var hasOwnProperty = objectProto.hasOwnProperty
        var idCounter2 = 0
        var maskSrcKey = (function () {
          var uid = /[^.]+$/.exec(
            (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '',
          )
          return uid ? 'Symbol(src)_1.' + uid : ''
        })()
        var nativeObjectToString = objectProto.toString
        var objectCtorString = funcToString.call(Object2)
        var oldDash = root._
        var reIsNative = RegExp2(
          '^' +
            funcToString
              .call(hasOwnProperty)
              .replace(reRegExpChar, '\\$&')
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                '$1.*?',
              ) +
            '$',
        )
        var Buffer = moduleExports ? context.Buffer : undefined$1,
          Symbol2 = context.Symbol,
          Uint8Array2 = context.Uint8Array,
          allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
          getPrototype = overArg(Object2.getPrototypeOf, Object2),
          objectCreate = Object2.create,
          propertyIsEnumerable = objectProto.propertyIsEnumerable,
          splice = arrayProto.splice,
          spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1,
          symIterator = Symbol2 ? Symbol2.iterator : undefined$1,
          symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1
        var defineProperty = (function () {
          try {
            var func = getNative(Object2, 'defineProperty')
            func({}, '', {})
            return func
          } catch (e) {}
        })()
        var ctxClearTimeout =
            context.clearTimeout !== root.clearTimeout && context.clearTimeout,
          ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now,
          ctxSetTimeout =
            context.setTimeout !== root.setTimeout && context.setTimeout
        var nativeCeil = Math2.ceil,
          nativeFloor = Math2.floor,
          nativeGetSymbols = Object2.getOwnPropertySymbols,
          nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
          nativeIsFinite = context.isFinite,
          nativeJoin = arrayProto.join,
          nativeKeys = overArg(Object2.keys, Object2),
          nativeMax = Math2.max,
          nativeMin = Math2.min,
          nativeNow = Date2.now,
          nativeParseInt = context.parseInt,
          nativeRandom = Math2.random,
          nativeReverse = arrayProto.reverse
        var DataView = getNative(context, 'DataView'),
          Map2 = getNative(context, 'Map'),
          Promise2 = getNative(context, 'Promise'),
          Set2 = getNative(context, 'Set'),
          WeakMap2 = getNative(context, 'WeakMap'),
          nativeCreate = getNative(Object2, 'create')
        var metaMap = WeakMap2 && new WeakMap2()
        var realNames = {}
        var dataViewCtorString = toSource(DataView),
          mapCtorString = toSource(Map2),
          promiseCtorString = toSource(Promise2),
          setCtorString = toSource(Set2),
          weakMapCtorString = toSource(WeakMap2)
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
          symbolToString = symbolProto ? symbolProto.toString : undefined$1
        function lodash2(value) {
          if (
            isObjectLike(value) &&
            !isArray2(value) &&
            !(value instanceof LazyWrapper)
          ) {
            if (value instanceof LodashWrapper) {
              return value
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value)
            }
          }
          return new LodashWrapper(value)
        }
        var baseCreate = /* @__PURE__ */ (function () {
          function object() {}
          return function (proto) {
            if (!isObject(proto)) {
              return {}
            }
            if (objectCreate) {
              return objectCreate(proto)
            }
            object.prototype = proto
            var result2 = new object()
            object.prototype = undefined$1
            return result2
          }
        })()
        function baseLodash() {}
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value
          this.__actions__ = []
          this.__chain__ = !!chainAll
          this.__index__ = 0
          this.__values__ = undefined$1
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: '',
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: lodash2,
          },
        }
        lodash2.prototype = baseLodash.prototype
        lodash2.prototype.constructor = lodash2
        LodashWrapper.prototype = baseCreate(baseLodash.prototype)
        LodashWrapper.prototype.constructor = LodashWrapper
        function LazyWrapper(value) {
          this.__wrapped__ = value
          this.__actions__ = []
          this.__dir__ = 1
          this.__filtered__ = false
          this.__iteratees__ = []
          this.__takeCount__ = MAX_ARRAY_LENGTH
          this.__views__ = []
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__)
          result2.__actions__ = copyArray(this.__actions__)
          result2.__dir__ = this.__dir__
          result2.__filtered__ = this.__filtered__
          result2.__iteratees__ = copyArray(this.__iteratees__)
          result2.__takeCount__ = this.__takeCount__
          result2.__views__ = copyArray(this.__views__)
          return result2
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this)
            result2.__dir__ = -1
            result2.__filtered__ = true
          } else {
            result2 = this.clone()
            result2.__dir__ *= -1
          }
          return result2
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
            dir = this.__dir__,
            isArr = isArray2(array),
            isRight = dir < 0,
            arrLength = isArr ? array.length : 0,
            view = getView(0, arrLength, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : start - 1,
            iteratees = this.__iteratees__,
            iterLength = iteratees.length,
            resIndex = 0,
            takeCount = nativeMin(length, this.__takeCount__)
          if (
            !isArr ||
            (!isRight && arrLength == length && takeCount == length)
          ) {
            return baseWrapperValue(array, this.__actions__)
          }
          var result2 = []
          outer: while (length-- && resIndex < takeCount) {
            index += dir
            var iterIndex = -1,
              value = array[index]
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                iteratee2 = data.iteratee,
                type = data.type,
                computed = iteratee2(value)
              if (type == LAZY_MAP_FLAG) {
                value = computed
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer
                } else {
                  break outer
                }
              }
            }
            result2[resIndex++] = value
          }
          return result2
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype)
        LazyWrapper.prototype.constructor = LazyWrapper
        function Hash(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length
          this.clear()
          while (++index < length) {
            var entry = entries[index]
            this.set(entry[0], entry[1])
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {}
          this.size = 0
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key]
          this.size -= result2 ? 1 : 0
          return result2
        }
        function hashGet(key) {
          var data = this.__data__
          if (nativeCreate) {
            var result2 = data[key]
            return result2 === HASH_UNDEFINED ? undefined$1 : result2
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1
        }
        function hashHas(key) {
          var data = this.__data__
          return nativeCreate
            ? data[key] !== undefined$1
            : hasOwnProperty.call(data, key)
        }
        function hashSet(key, value) {
          var data = this.__data__
          this.size += this.has(key) ? 0 : 1
          data[key] =
            nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value
          return this
        }
        Hash.prototype.clear = hashClear
        Hash.prototype['delete'] = hashDelete
        Hash.prototype.get = hashGet
        Hash.prototype.has = hashHas
        Hash.prototype.set = hashSet
        function ListCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length
          this.clear()
          while (++index < length) {
            var entry = entries[index]
            this.set(entry[0], entry[1])
          }
        }
        function listCacheClear() {
          this.__data__ = []
          this.size = 0
        }
        function listCacheDelete(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key)
          if (index < 0) {
            return false
          }
          var lastIndex = data.length - 1
          if (index == lastIndex) {
            data.pop()
          } else {
            splice.call(data, index, 1)
          }
          --this.size
          return true
        }
        function listCacheGet(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key)
          return index < 0 ? undefined$1 : data[index][1]
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1
        }
        function listCacheSet(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key)
          if (index < 0) {
            ++this.size
            data.push([key, value])
          } else {
            data[index][1] = value
          }
          return this
        }
        ListCache.prototype.clear = listCacheClear
        ListCache.prototype['delete'] = listCacheDelete
        ListCache.prototype.get = listCacheGet
        ListCache.prototype.has = listCacheHas
        ListCache.prototype.set = listCacheSet
        function MapCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length
          this.clear()
          while (++index < length) {
            var entry = entries[index]
            this.set(entry[0], entry[1])
          }
        }
        function mapCacheClear() {
          this.size = 0
          this.__data__ = {
            hash: new Hash(),
            map: new (Map2 || ListCache)(),
            string: new Hash(),
          }
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)['delete'](key)
          this.size -= result2 ? 1 : 0
          return result2
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key)
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key)
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
            size2 = data.size
          data.set(key, value)
          this.size += data.size == size2 ? 0 : 1
          return this
        }
        MapCache.prototype.clear = mapCacheClear
        MapCache.prototype['delete'] = mapCacheDelete
        MapCache.prototype.get = mapCacheGet
        MapCache.prototype.has = mapCacheHas
        MapCache.prototype.set = mapCacheSet
        function SetCache(values2) {
          var index = -1,
            length = values2 == null ? 0 : values2.length
          this.__data__ = new MapCache()
          while (++index < length) {
            this.add(values2[index])
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED)
          return this
        }
        function setCacheHas(value) {
          return this.__data__.has(value)
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
        SetCache.prototype.has = setCacheHas
        function Stack(entries) {
          var data = (this.__data__ = new ListCache(entries))
          this.size = data.size
        }
        function stackClear() {
          this.__data__ = new ListCache()
          this.size = 0
        }
        function stackDelete(key) {
          var data = this.__data__,
            result2 = data['delete'](key)
          this.size = data.size
          return result2
        }
        function stackGet(key) {
          return this.__data__.get(key)
        }
        function stackHas(key) {
          return this.__data__.has(key)
        }
        function stackSet(key, value) {
          var data = this.__data__
          if (data instanceof ListCache) {
            var pairs = data.__data__
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value])
              this.size = ++data.size
              return this
            }
            data = this.__data__ = new MapCache(pairs)
          }
          data.set(key, value)
          this.size = data.size
          return this
        }
        Stack.prototype.clear = stackClear
        Stack.prototype['delete'] = stackDelete
        Stack.prototype.get = stackGet
        Stack.prototype.has = stackHas
        Stack.prototype.set = stackSet
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result2 = skipIndexes ? baseTimes(value.length, String2) : [],
            length = result2.length
          for (var key in value) {
            if (
              (inherited || hasOwnProperty.call(value, key)) &&
              !(
                skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                (key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
                  (isBuff && (key == 'offset' || key == 'parent')) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  (isType &&
                    (key == 'buffer' ||
                      key == 'byteLength' ||
                      key == 'byteOffset')) || // Skip index properties.
                  isIndex(key, length))
              )
            ) {
              result2.push(key)
            }
          }
          return result2
        }
        function arraySample(array) {
          var length = array.length
          return length ? array[baseRandom(0, length - 1)] : undefined$1
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length))
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array))
        }
        function assignMergeValue(object, key, value) {
          if (
            (value !== undefined$1 && !eq(object[key], value)) ||
            (value === undefined$1 && !(key in object))
          ) {
            baseAssignValue(object, key, value)
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key]
          if (
            !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
            (value === undefined$1 && !(key in object))
          ) {
            baseAssignValue(object, key, value)
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length
          while (length--) {
            if (eq(array[length][0], key)) {
              return length
            }
          }
          return -1
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function (value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2)
          })
          return accumulator
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object)
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object)
        }
        function baseAssignValue(object, key, value) {
          if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true,
            })
          } else {
            object[key] = value
          }
        }
        function baseAt(object, paths) {
          var index = -1,
            length = paths.length,
            result2 = Array2(length),
            skip = object == null
          while (++index < length) {
            result2[index] = skip ? undefined$1 : get(object, paths[index])
          }
          return result2
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower
            }
          }
          return number
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2,
            isDeep = bitmask & CLONE_DEEP_FLAG,
            isFlat = bitmask & CLONE_FLAT_FLAG,
            isFull = bitmask & CLONE_SYMBOLS_FLAG
          if (customizer) {
            result2 = object
              ? customizer(value, key, object, stack)
              : customizer(value)
          }
          if (result2 !== undefined$1) {
            return result2
          }
          if (!isObject(value)) {
            return value
          }
          var isArr = isArray2(value)
          if (isArr) {
            result2 = initCloneArray(value)
            if (!isDeep) {
              return copyArray(value, result2)
            }
          } else {
            var tag = getTag(value),
              isFunc = tag == funcTag || tag == genTag
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep)
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value)
              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result2, value))
                  : copySymbols(value, baseAssign(result2, value))
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {}
              }
              result2 = initCloneByTag(value, tag, isDeep)
            }
          }
          stack || (stack = new Stack())
          var stacked = stack.get(value)
          if (stacked) {
            return stacked
          }
          stack.set(value, result2)
          if (isSet(value)) {
            value.forEach(function (subValue) {
              result2.add(
                baseClone(
                  subValue,
                  bitmask,
                  customizer,
                  subValue,
                  value,
                  stack,
                ),
              )
            })
          } else if (isMap(value)) {
            value.forEach(function (subValue, key2) {
              result2.set(
                key2,
                baseClone(subValue, bitmask, customizer, key2, value, stack),
              )
            })
          }
          var keysFunc = isFull
            ? isFlat
              ? getAllKeysIn
              : getAllKeys
            : isFlat
            ? keysIn
            : keys
          var props = isArr ? undefined$1 : keysFunc(value)
          arrayEach(props || value, function (subValue, key2) {
            if (props) {
              key2 = subValue
              subValue = value[key2]
            }
            assignValue(
              result2,
              key2,
              baseClone(subValue, bitmask, customizer, key2, value, stack),
            )
          })
          return result2
        }
        function baseConforms(source) {
          var props = keys(source)
          return function (object) {
            return baseConformsTo(object, source, props)
          }
        }
        function baseConformsTo(object, source, props) {
          var length = props.length
          if (object == null) {
            return !length
          }
          object = Object2(object)
          while (length--) {
            var key = props[length],
              predicate = source[key],
              value = object[key]
            if (
              (value === undefined$1 && !(key in object)) ||
              !predicate(value)
            ) {
              return false
            }
          }
          return true
        }
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          return setTimeout2(function () {
            func.apply(undefined$1, args)
          }, wait)
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1,
            includes2 = arrayIncludes,
            isCommon = true,
            length = array.length,
            result2 = [],
            valuesLength = values2.length
          if (!length) {
            return result2
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2))
          }
          if (comparator) {
            includes2 = arrayIncludesWith
            isCommon = false
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas
            isCommon = false
            values2 = new SetCache(values2)
          }
          outer: while (++index < length) {
            var value = array[index],
              computed = iteratee2 == null ? value : iteratee2(value)
            value = comparator || value !== 0 ? value : 0
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer
                }
              }
              result2.push(value)
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value)
            }
          }
          return result2
        }
        var baseEach = createBaseEach(baseForOwn)
        var baseEachRight = createBaseEach(baseForOwnRight, true)
        function baseEvery(collection, predicate) {
          var result2 = true
          baseEach(collection, function (value, index, collection2) {
            result2 = !!predicate(value, index, collection2)
            return result2
          })
          return result2
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1,
            length = array.length
          while (++index < length) {
            var value = array[index],
              current = iteratee2(value)
            if (
              current != null &&
              (computed === undefined$1
                ? current === current && !isSymbol(current)
                : comparator(current, computed))
            ) {
              var computed = current,
                result2 = value
            }
          }
          return result2
        }
        function baseFill(array, value, start, end) {
          var length = array.length
          start = toInteger(start)
          if (start < 0) {
            start = -start > length ? 0 : length + start
          }
          end = end === undefined$1 || end > length ? length : toInteger(end)
          if (end < 0) {
            end += length
          }
          end = start > end ? 0 : toLength(end)
          while (start < end) {
            array[start++] = value
          }
          return array
        }
        function baseFilter(collection, predicate) {
          var result2 = []
          baseEach(collection, function (value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value)
            }
          })
          return result2
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1,
            length = array.length
          predicate || (predicate = isFlattenable)
          result2 || (result2 = [])
          while (++index < length) {
            var value = array[index]
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2)
              } else {
                arrayPush(result2, value)
              }
            } else if (!isStrict) {
              result2[result2.length] = value
            }
          }
          return result2
        }
        var baseFor = createBaseFor()
        var baseForRight = createBaseFor(true)
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys)
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys)
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function (key) {
            return isFunction(object[key])
          })
        }
        function baseGet(object, path) {
          path = castPath(path, object)
          var index = 0,
            length = path.length
          while (object != null && index < length) {
            object = object[toKey(path[index++])]
          }
          return index && index == length ? object : undefined$1
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object)
          return isArray2(object)
            ? result2
            : arrayPush(result2, symbolsFunc(object))
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag
          }
          return symToStringTag && symToStringTag in Object2(value)
            ? getRawTag(value)
            : objectToString(value)
        }
        function baseGt(value, other) {
          return value > other
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key)
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object)
        }
        function baseInRange(number, start, end) {
          return (
            number >= nativeMin(start, end) && number < nativeMax(start, end)
          )
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array2(othLength),
            maxLength = Infinity,
            result2 = []
          while (othIndex--) {
            var array = arrays[othIndex]
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2))
            }
            maxLength = nativeMin(array.length, maxLength)
            caches[othIndex] =
              !comparator &&
              (iteratee2 || (length >= 120 && array.length >= 120))
                ? new SetCache(othIndex && array)
                : undefined$1
          }
          array = arrays[0]
          var index = -1,
            seen = caches[0]
          outer: while (++index < length && result2.length < maxLength) {
            var value = array[index],
              computed = iteratee2 ? iteratee2(value) : value
            value = comparator || value !== 0 ? value : 0
            if (
              !(seen
                ? cacheHas(seen, computed)
                : includes2(result2, computed, comparator))
            ) {
              othIndex = othLength
              while (--othIndex) {
                var cache2 = caches[othIndex]
                if (
                  !(cache2
                    ? cacheHas(cache2, computed)
                    : includes2(arrays[othIndex], computed, comparator))
                ) {
                  continue outer
                }
              }
              if (seen) {
                seen.push(computed)
              }
              result2.push(value)
            }
          }
          return result2
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function (value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2)
          })
          return accumulator
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object)
          object = parent(object, path)
          var func = object == null ? object : object[toKey(last(path))]
          return func == null ? undefined$1 : apply(func, object, args)
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true
          }
          if (
            value == null ||
            other == null ||
            (!isObjectLike(value) && !isObjectLike(other))
          ) {
            return value !== value && other !== other
          }
          return baseIsEqualDeep(
            value,
            other,
            bitmask,
            customizer,
            baseIsEqual,
            stack,
          )
        }
        function baseIsEqualDeep(
          object,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack,
        ) {
          var objIsArr = isArray2(object),
            othIsArr = isArray2(other),
            objTag = objIsArr ? arrayTag : getTag(object),
            othTag = othIsArr ? arrayTag : getTag(other)
          objTag = objTag == argsTag ? objectTag : objTag
          othTag = othTag == argsTag ? objectTag : othTag
          var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false
            }
            objIsArr = true
            objIsObj = false
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack())
            return objIsArr || isTypedArray(object)
              ? equalArrays(
                  object,
                  other,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack,
                )
              : equalByTag(
                  object,
                  other,
                  objTag,
                  bitmask,
                  customizer,
                  equalFunc,
                  stack,
                )
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped =
                objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othIsWrapped =
                othIsObj && hasOwnProperty.call(other, '__wrapped__')
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other
              stack || (stack = new Stack())
              return equalFunc(
                objUnwrapped,
                othUnwrapped,
                bitmask,
                customizer,
                stack,
              )
            }
          }
          if (!isSameTag) {
            return false
          }
          stack || (stack = new Stack())
          return equalObjects(
            object,
            other,
            bitmask,
            customizer,
            equalFunc,
            stack,
          )
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
            length = index,
            noCustomizer = !customizer
          if (object == null) {
            return !length
          }
          object = Object2(object)
          while (index--) {
            var data = matchData[index]
            if (
              noCustomizer && data[2]
                ? data[1] !== object[data[0]]
                : !(data[0] in object)
            ) {
              return false
            }
          }
          while (++index < length) {
            data = matchData[index]
            var key = data[0],
              objValue = object[key],
              srcValue = data[1]
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false
              }
            } else {
              var stack = new Stack()
              if (customizer) {
                var result2 = customizer(
                  objValue,
                  srcValue,
                  key,
                  object,
                  source,
                  stack,
                )
              }
              if (
                !(result2 === undefined$1
                  ? baseIsEqual(
                      srcValue,
                      objValue,
                      COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
                      customizer,
                      stack,
                    )
                  : result2)
              ) {
                return false
              }
            }
          }
          return true
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor
          return pattern.test(toSource(value))
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag
        }
        function baseIsTypedArray(value) {
          return (
            isObjectLike(value) &&
            isLength(value.length) &&
            !!typedArrayTags[baseGetTag(value)]
          )
        }
        function baseIteratee(value) {
          if (typeof value == 'function') {
            return value
          }
          if (value == null) {
            return identity
          }
          if (typeof value == 'object') {
            return isArray2(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value)
          }
          return property(value)
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object)
          }
          var result2 = []
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
              result2.push(key)
            }
          }
          return result2
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object)
          }
          var isProto = isPrototype(object),
            result2 = []
          for (var key in object) {
            if (
              !(
                key == 'constructor' &&
                (isProto || !hasOwnProperty.call(object, key))
              )
            ) {
              result2.push(key)
            }
          }
          return result2
        }
        function baseLt(value, other) {
          return value < other
        }
        function baseMap(collection, iteratee2) {
          var index = -1,
            result2 = isArrayLike(collection) ? Array2(collection.length) : []
          baseEach(collection, function (value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2)
          })
          return result2
        }
        function baseMatches(source) {
          var matchData = getMatchData(source)
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1])
          }
          return function (object) {
            return object === source || baseIsMatch(object, source, matchData)
          }
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue)
          }
          return function (object) {
            var objValue = get(object, path)
            return objValue === undefined$1 && objValue === srcValue
              ? hasIn(object, path)
              : baseIsEqual(
                  srcValue,
                  objValue,
                  COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG,
                )
          }
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return
          }
          baseFor(
            source,
            function (srcValue, key) {
              stack || (stack = new Stack())
              if (isObject(srcValue)) {
                baseMergeDeep(
                  object,
                  source,
                  key,
                  srcIndex,
                  baseMerge,
                  customizer,
                  stack,
                )
              } else {
                var newValue = customizer
                  ? customizer(
                      safeGet(object, key),
                      srcValue,
                      key + '',
                      object,
                      source,
                      stack,
                    )
                  : undefined$1
                if (newValue === undefined$1) {
                  newValue = srcValue
                }
                assignMergeValue(object, key, newValue)
              }
            },
            keysIn,
          )
        }
        function baseMergeDeep(
          object,
          source,
          key,
          srcIndex,
          mergeFunc,
          customizer,
          stack,
        ) {
          var objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack.get(srcValue)
          if (stacked) {
            assignMergeValue(object, key, stacked)
            return
          }
          var newValue = customizer
            ? customizer(objValue, srcValue, key + '', object, source, stack)
            : undefined$1
          var isCommon = newValue === undefined$1
          if (isCommon) {
            var isArr = isArray2(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue)
            newValue = srcValue
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue)
              } else if (isBuff) {
                isCommon = false
                newValue = cloneBuffer(srcValue, true)
              } else if (isTyped) {
                isCommon = false
                newValue = cloneTypedArray(srcValue, true)
              } else {
                newValue = []
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue)
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue)
              }
            } else {
              isCommon = false
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue)
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack)
            stack['delete'](srcValue)
          }
          assignMergeValue(object, key, newValue)
        }
        function baseNth(array, n) {
          var length = array.length
          if (!length) {
            return
          }
          n += n < 0 ? length : 0
          return isIndex(n, length) ? array[n] : undefined$1
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function (iteratee2) {
              if (isArray2(iteratee2)) {
                return function (value) {
                  return baseGet(
                    value,
                    iteratee2.length === 1 ? iteratee2[0] : iteratee2,
                  )
                }
              }
              return iteratee2
            })
          } else {
            iteratees = [identity]
          }
          var index = -1
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()))
          var result2 = baseMap(collection, function (value, key, collection2) {
            var criteria = arrayMap(iteratees, function (iteratee2) {
              return iteratee2(value)
            })
            return {criteria: criteria, index: ++index, value: value}
          })
          return baseSortBy(result2, function (object, other) {
            return compareMultiple(object, other, orders)
          })
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function (value, path) {
            return hasIn(object, path)
          })
        }
        function basePickBy(object, paths, predicate) {
          var index = -1,
            length = paths.length,
            result2 = {}
          while (++index < length) {
            var path = paths[index],
              value = baseGet(object, path)
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value)
            }
          }
          return result2
        }
        function basePropertyDeep(path) {
          return function (object) {
            return baseGet(object, path)
          }
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf,
            index = -1,
            length = values2.length,
            seen = array
          if (array === values2) {
            values2 = copyArray(values2)
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2))
          }
          while (++index < length) {
            var fromIndex = 0,
              value = values2[index],
              computed = iteratee2 ? iteratee2(value) : value
            while (
              (fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1
            ) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1)
              }
              splice.call(array, fromIndex, 1)
            }
          }
          return array
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
            lastIndex = length - 1
          while (length--) {
            var index = indexes[length]
            if (length == lastIndex || index !== previous) {
              var previous = index
              if (isIndex(index)) {
                splice.call(array, index, 1)
              } else {
                baseUnset(array, index)
              }
            }
          }
          return array
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1,
            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
            result2 = Array2(length)
          while (length--) {
            result2[fromRight ? length : ++index] = start
            start += step
          }
          return result2
        }
        function baseRepeat(string, n) {
          var result2 = ''
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2
          }
          do {
            if (n % 2) {
              result2 += string
            }
            n = nativeFloor(n / 2)
            if (n) {
              string += string
            }
          } while (n)
          return result2
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + '')
        }
        function baseSample(collection) {
          return arraySample(values(collection))
        }
        function baseSampleSize(collection, n) {
          var array = values(collection)
          return shuffleSelf(array, baseClamp(n, 0, array.length))
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object
          }
          path = castPath(path, object)
          var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object
          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
              newValue = value
            if (
              key === '__proto__' ||
              key === 'constructor' ||
              key === 'prototype'
            ) {
              return object
            }
            if (index != lastIndex) {
              var objValue = nested[key]
              newValue = customizer
                ? customizer(objValue, key, nested)
                : undefined$1
              if (newValue === undefined$1) {
                newValue = isObject(objValue)
                  ? objValue
                  : isIndex(path[index + 1])
                  ? []
                  : {}
              }
            }
            assignValue(nested, key, newValue)
            nested = nested[key]
          }
          return object
        }
        var baseSetData = !metaMap
          ? identity
          : function (func, data) {
              metaMap.set(func, data)
              return func
            }
        var baseSetToString = !defineProperty
          ? identity
          : function (func, string) {
              return defineProperty(func, 'toString', {
                configurable: true,
                enumerable: false,
                value: constant(string),
                writable: true,
              })
            }
        function baseShuffle(collection) {
          return shuffleSelf(values(collection))
        }
        function baseSlice(array, start, end) {
          var index = -1,
            length = array.length
          if (start < 0) {
            start = -start > length ? 0 : length + start
          }
          end = end > length ? length : end
          if (end < 0) {
            end += length
          }
          length = start > end ? 0 : (end - start) >>> 0
          start >>>= 0
          var result2 = Array2(length)
          while (++index < length) {
            result2[index] = array[index + start]
          }
          return result2
        }
        function baseSome(collection, predicate) {
          var result2
          baseEach(collection, function (value, index, collection2) {
            result2 = predicate(value, index, collection2)
            return !result2
          })
          return !!result2
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
            high = array == null ? low : array.length
          if (
            typeof value == 'number' &&
            value === value &&
            high <= HALF_MAX_ARRAY_LENGTH
          ) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                computed = array[mid]
              if (
                computed !== null &&
                !isSymbol(computed) &&
                (retHighest ? computed <= value : computed < value)
              ) {
                low = mid + 1
              } else {
                high = mid
              }
            }
            return high
          }
          return baseSortedIndexBy(array, value, identity, retHighest)
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0,
            high = array == null ? 0 : array.length
          if (high === 0) {
            return 0
          }
          value = iteratee2(value)
          var valIsNaN = value !== value,
            valIsNull = value === null,
            valIsSymbol = isSymbol(value),
            valIsUndefined = value === undefined$1
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
              computed = iteratee2(array[mid]),
              othIsDefined = computed !== undefined$1,
              othIsNull = computed === null,
              othIsReflexive = computed === computed,
              othIsSymbol = isSymbol(computed)
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined)
            } else if (valIsNull) {
              setLow =
                othIsReflexive && othIsDefined && (retHighest || !othIsNull)
            } else if (valIsSymbol) {
              setLow =
                othIsReflexive &&
                othIsDefined &&
                !othIsNull &&
                (retHighest || !othIsSymbol)
            } else if (othIsNull || othIsSymbol) {
              setLow = false
            } else {
              setLow = retHighest ? computed <= value : computed < value
            }
            if (setLow) {
              low = mid + 1
            } else {
              high = mid
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX)
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1,
            length = array.length,
            resIndex = 0,
            result2 = []
          while (++index < length) {
            var value = array[index],
              computed = iteratee2 ? iteratee2(value) : value
            if (!index || !eq(computed, seen)) {
              var seen = computed
              result2[resIndex++] = value === 0 ? 0 : value
            }
          }
          return result2
        }
        function baseToNumber(value) {
          if (typeof value == 'number') {
            return value
          }
          if (isSymbol(value)) {
            return NAN
          }
          return +value
        }
        function baseToString(value) {
          if (typeof value == 'string') {
            return value
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + ''
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : ''
          }
          var result2 = value + ''
          return result2 == '0' && 1 / value == -INFINITY ? '-0' : result2
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1,
            includes2 = arrayIncludes,
            length = array.length,
            isCommon = true,
            result2 = [],
            seen = result2
          if (comparator) {
            isCommon = false
            includes2 = arrayIncludesWith
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array)
            if (set2) {
              return setToArray(set2)
            }
            isCommon = false
            includes2 = cacheHas
            seen = new SetCache()
          } else {
            seen = iteratee2 ? [] : result2
          }
          outer: while (++index < length) {
            var value = array[index],
              computed = iteratee2 ? iteratee2(value) : value
            value = comparator || value !== 0 ? value : 0
            if (isCommon && computed === computed) {
              var seenIndex = seen.length
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer
                }
              }
              if (iteratee2) {
                seen.push(computed)
              }
              result2.push(value)
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed)
              }
              result2.push(value)
            }
          }
          return result2
        }
        function baseUnset(object, path) {
          path = castPath(path, object)
          object = parent(object, path)
          return object == null || delete object[toKey(last(path))]
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(
            object,
            path,
            updater(baseGet(object, path)),
            customizer,
          )
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
            index = fromRight ? length : -1
          while (
            (fromRight ? index-- : ++index < length) &&
            predicate(array[index], index, array)
          ) {}
          return isDrop
            ? baseSlice(
                array,
                fromRight ? 0 : index,
                fromRight ? index + 1 : length,
              )
            : baseSlice(
                array,
                fromRight ? index + 1 : 0,
                fromRight ? length : index,
              )
        }
        function baseWrapperValue(value, actions) {
          var result2 = value
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value()
          }
          return arrayReduce(
            actions,
            function (result3, action) {
              return action.func.apply(
                action.thisArg,
                arrayPush([result3], action.args),
              )
            },
            result2,
          )
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : []
          }
          var index = -1,
            result2 = Array2(length)
          while (++index < length) {
            var array = arrays[index],
              othIndex = -1
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(
                  result2[index] || array,
                  arrays[othIndex],
                  iteratee2,
                  comparator,
                )
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator)
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1,
            length = props.length,
            valsLength = values2.length,
            result2 = {}
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined$1
            assignFunc(result2, props[index], value)
          }
          return result2
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : []
        }
        function castFunction(value) {
          return typeof value == 'function' ? value : identity
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value))
        }
        var castRest = baseRest
        function castSlice(array, start, end) {
          var length = array.length
          end = end === undefined$1 ? length : end
          return !start && end >= length ? array : baseSlice(array, start, end)
        }
        var clearTimeout2 =
          ctxClearTimeout ||
          function (id) {
            return root.clearTimeout(id)
          }
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice()
          }
          var length = buffer.length,
            result2 = allocUnsafe
              ? allocUnsafe(length)
              : new buffer.constructor(length)
          buffer.copy(result2)
          return result2
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength)
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer))
          return result2
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep
            ? cloneArrayBuffer(dataView.buffer)
            : dataView.buffer
          return new dataView.constructor(
            buffer,
            dataView.byteOffset,
            dataView.byteLength,
          )
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(
            regexp.source,
            reFlags.exec(regexp),
          )
          result2.lastIndex = regexp.lastIndex
          return result2
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {}
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep
            ? cloneArrayBuffer(typedArray.buffer)
            : typedArray.buffer
          return new typedArray.constructor(
            buffer,
            typedArray.byteOffset,
            typedArray.length,
          )
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1,
              valIsNull = value === null,
              valIsReflexive = value === value,
              valIsSymbol = isSymbol(value)
            var othIsDefined = other !== undefined$1,
              othIsNull = other === null,
              othIsReflexive = other === other,
              othIsSymbol = isSymbol(other)
            if (
              (!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
              (valIsSymbol &&
                othIsDefined &&
                othIsReflexive &&
                !othIsNull &&
                !othIsSymbol) ||
              (valIsNull && othIsDefined && othIsReflexive) ||
              (!valIsDefined && othIsReflexive) ||
              !valIsReflexive
            ) {
              return 1
            }
            if (
              (!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
              (othIsSymbol &&
                valIsDefined &&
                valIsReflexive &&
                !valIsNull &&
                !valIsSymbol) ||
              (othIsNull && valIsDefined && valIsReflexive) ||
              (!othIsDefined && valIsReflexive) ||
              !othIsReflexive
            ) {
              return -1
            }
          }
          return 0
        }
        function compareMultiple(object, other, orders) {
          var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length
          while (++index < length) {
            var result2 = compareAscending(
              objCriteria[index],
              othCriteria[index],
            )
            if (result2) {
              if (index >= ordersLength) {
                return result2
              }
              var order = orders[index]
              return result2 * (order == 'desc' ? -1 : 1)
            }
          }
          return object.index - other.index
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
            argsLength = args.length,
            holdersLength = holders.length,
            leftIndex = -1,
            leftLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result2 = Array2(leftLength + rangeLength),
            isUncurried = !isCurried
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex]
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex]
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++]
          }
          return result2
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
            argsLength = args.length,
            holdersIndex = -1,
            holdersLength = holders.length,
            rightIndex = -1,
            rightLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result2 = Array2(rangeLength + rightLength),
            isUncurried = !isCurried
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex]
          }
          var offset = argsIndex
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex]
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++]
            }
          }
          return result2
        }
        function copyArray(source, array) {
          var index = -1,
            length = source.length
          array || (array = Array2(length))
          while (++index < length) {
            array[index] = source[index]
          }
          return array
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object
          object || (object = {})
          var index = -1,
            length = props.length
          while (++index < length) {
            var key = props[index]
            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined$1
            if (newValue === undefined$1) {
              newValue = source[key]
            }
            if (isNew) {
              baseAssignValue(object, key, newValue)
            } else {
              assignValue(object, key, newValue)
            }
          }
          return object
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object)
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object)
        }
        function createAggregator(setter, initializer) {
          return function (collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator,
              accumulator = initializer ? initializer() : {}
            return func(
              collection,
              setter,
              getIteratee(iteratee2, 2),
              accumulator,
            )
          }
        }
        function createAssigner(assigner) {
          return baseRest(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined$1,
              guard = length > 2 ? sources[2] : undefined$1
            customizer =
              assigner.length > 3 && typeof customizer == 'function'
                ? (length--, customizer)
                : undefined$1
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer
              length = 1
            }
            object = Object2(object)
            while (++index < length) {
              var source = sources[index]
              if (source) {
                assigner(object, source, index, customizer)
              }
            }
            return object
          })
        }
        function createBaseEach(eachFunc, fromRight) {
          return function (collection, iteratee2) {
            if (collection == null) {
              return collection
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2)
            }
            var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object2(collection)
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break
              }
            }
            return collection
          }
        }
        function createBaseFor(fromRight) {
          return function (object, iteratee2, keysFunc) {
            var index = -1,
              iterable = Object2(object),
              props = keysFunc(object),
              length = props.length
            while (length--) {
              var key = props[fromRight ? length : ++index]
              if (iteratee2(iterable[key], key, iterable) === false) {
                break
              }
            }
            return object
          }
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func)
          function wrapper() {
            var fn =
              this && this !== root && this instanceof wrapper ? Ctor : func
            return fn.apply(isBind ? thisArg : this, arguments)
          }
          return wrapper
        }
        function createCaseFirst(methodName) {
          return function (string) {
            string = toString(string)
            var strSymbols = hasUnicode(string)
              ? stringToArray(string)
              : undefined$1
            var chr = strSymbols ? strSymbols[0] : string.charAt(0)
            var trailing = strSymbols
              ? castSlice(strSymbols, 1).join('')
              : string.slice(1)
            return chr[methodName]() + trailing
          }
        }
        function createCompounder(callback) {
          return function (string) {
            return arrayReduce(
              words(deburr(string).replace(reApos, '')),
              callback,
              '',
            )
          }
        }
        function createCtor(Ctor) {
          return function () {
            var args = arguments
            switch (args.length) {
              case 0:
                return new Ctor()
              case 1:
                return new Ctor(args[0])
              case 2:
                return new Ctor(args[0], args[1])
              case 3:
                return new Ctor(args[0], args[1], args[2])
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3])
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4])
              case 6:
                return new Ctor(
                  args[0],
                  args[1],
                  args[2],
                  args[3],
                  args[4],
                  args[5],
                )
              case 7:
                return new Ctor(
                  args[0],
                  args[1],
                  args[2],
                  args[3],
                  args[4],
                  args[5],
                  args[6],
                )
            }
            var thisBinding = baseCreate(Ctor.prototype),
              result2 = Ctor.apply(thisBinding, args)
            return isObject(result2) ? result2 : thisBinding
          }
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func)
          function wrapper() {
            var length = arguments.length,
              args = Array2(length),
              index = length,
              placeholder = getHolder(wrapper)
            while (index--) {
              args[index] = arguments[index]
            }
            var holders =
              length < 3 &&
              args[0] !== placeholder &&
              args[length - 1] !== placeholder
                ? []
                : replaceHolders(args, placeholder)
            length -= holders.length
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length,
              )
            }
            var fn =
              this && this !== root && this instanceof wrapper ? Ctor : func
            return apply(fn, this, args)
          }
          return wrapper
        }
        function createFind(findIndexFunc) {
          return function (collection, predicate, fromIndex) {
            var iterable = Object2(collection)
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3)
              collection = keys(collection)
              predicate = function (key) {
                return iteratee2(iterable[key], key, iterable)
              }
            }
            var index = findIndexFunc(collection, predicate, fromIndex)
            return index > -1
              ? iterable[iteratee2 ? collection[index] : index]
              : undefined$1
          }
        }
        function createFlow(fromRight) {
          return flatRest(function (funcs) {
            var length = funcs.length,
              index = length,
              prereq = LodashWrapper.prototype.thru
            if (fromRight) {
              funcs.reverse()
            }
            while (index--) {
              var func = funcs[index]
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT)
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true)
              }
            }
            index = wrapper ? index : length
            while (++index < length) {
              func = funcs[index]
              var funcName = getFuncName(func),
                data = funcName == 'wrapper' ? getData(func) : undefined$1
              if (
                data &&
                isLaziable(data[0]) &&
                data[1] ==
                  (WRAP_ARY_FLAG |
                    WRAP_CURRY_FLAG |
                    WRAP_PARTIAL_FLAG |
                    WRAP_REARG_FLAG) &&
                !data[4].length &&
                data[9] == 1
              ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3])
              } else {
                wrapper =
                  func.length == 1 && isLaziable(func)
                    ? wrapper[funcName]()
                    : wrapper.thru(func)
              }
            }
            return function () {
              var args = arguments,
                value = args[0]
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value()
              }
              var index2 = 0,
                result2 = length ? funcs[index2].apply(this, args) : value
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2)
              }
              return result2
            }
          })
        }
        function createHybrid(
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity,
        ) {
          var isAry = bitmask & WRAP_ARY_FLAG,
            isBind = bitmask & WRAP_BIND_FLAG,
            isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
            isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
            isFlip = bitmask & WRAP_FLIP_FLAG,
            Ctor = isBindKey ? undefined$1 : createCtor(func)
          function wrapper() {
            var length = arguments.length,
              args = Array2(length),
              index = length
            while (index--) {
              args[index] = arguments[index]
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                holdersCount = countHolders(args, placeholder)
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried)
            }
            if (partialsRight) {
              args = composeArgsRight(
                args,
                partialsRight,
                holdersRight,
                isCurried,
              )
            }
            length -= holdersCount
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder)
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length,
              )
            }
            var thisBinding = isBind ? thisArg : this,
              fn = isBindKey ? thisBinding[func] : func
            length = args.length
            if (argPos) {
              args = reorder(args, argPos)
            } else if (isFlip && length > 1) {
              args.reverse()
            }
            if (isAry && ary2 < length) {
              args.length = ary2
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn)
            }
            return fn.apply(thisBinding, args)
          }
          return wrapper
        }
        function createInverter(setter, toIteratee) {
          return function (object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {})
          }
        }
        function createMathOperation(operator, defaultValue) {
          return function (value, other) {
            var result2
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue
            }
            if (value !== undefined$1) {
              result2 = value
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other
              }
              if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value)
                other = baseToString(other)
              } else {
                value = baseToNumber(value)
                other = baseToNumber(other)
              }
              result2 = operator(value, other)
            }
            return result2
          }
        }
        function createOver(arrayFunc) {
          return flatRest(function (iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()))
            return baseRest(function (args) {
              var thisArg = this
              return arrayFunc(iteratees, function (iteratee2) {
                return apply(iteratee2, thisArg, args)
              })
            })
          })
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? ' ' : baseToString(chars)
          var charsLength = chars.length
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars
          }
          var result2 = baseRepeat(
            chars,
            nativeCeil(length / stringSize(chars)),
          )
          return hasUnicode(chars)
            ? castSlice(stringToArray(result2), 0, length).join('')
            : result2.slice(0, length)
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func)
          function wrapper() {
            var argsIndex = -1,
              argsLength = arguments.length,
              leftIndex = -1,
              leftLength = partials.length,
              args = Array2(leftLength + argsLength),
              fn =
                this && this !== root && this instanceof wrapper ? Ctor : func
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex]
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex]
            }
            return apply(fn, isBind ? thisArg : this, args)
          }
          return wrapper
        }
        function createRange(fromRight) {
          return function (start, end, step) {
            if (
              step &&
              typeof step != 'number' &&
              isIterateeCall(start, end, step)
            ) {
              end = step = undefined$1
            }
            start = toFinite(start)
            if (end === undefined$1) {
              end = start
              start = 0
            } else {
              end = toFinite(end)
            }
            step =
              step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step)
            return baseRange(start, end, step, fromRight)
          }
        }
        function createRelationalOperation(operator) {
          return function (value, other) {
            if (!(typeof value == 'string' && typeof other == 'string')) {
              value = toNumber2(value)
              other = toNumber2(other)
            }
            return operator(value, other)
          }
        }
        function createRecurry(
          func,
          bitmask,
          wrapFunc,
          placeholder,
          thisArg,
          partials,
          holders,
          argPos,
          ary2,
          arity,
        ) {
          var isCurry = bitmask & WRAP_CURRY_FLAG,
            newHolders = isCurry ? holders : undefined$1,
            newHoldersRight = isCurry ? undefined$1 : holders,
            newPartials = isCurry ? partials : undefined$1,
            newPartialsRight = isCurry ? undefined$1 : partials
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG)
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= -4
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity,
          ]
          var result2 = wrapFunc.apply(undefined$1, newData)
          if (isLaziable(func)) {
            setData(result2, newData)
          }
          result2.placeholder = placeholder
          return setWrapToString(result2, func, bitmask)
        }
        function createRound(methodName) {
          var func = Math2[methodName]
          return function (number, precision) {
            number = toNumber2(number)
            precision =
              precision == null ? 0 : nativeMin(toInteger(precision), 292)
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + 'e').split('e'),
                value = func(pair[0] + 'e' + (+pair[1] + precision))
              pair = (toString(value) + 'e').split('e')
              return +(pair[0] + 'e' + (+pair[1] - precision))
            }
            return func(number)
          }
        }
        var createSet = !(
          Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY
        )
          ? noop2
          : function (values2) {
              return new Set2(values2)
            }
        function createToPairs(keysFunc) {
          return function (object) {
            var tag = getTag(object)
            if (tag == mapTag) {
              return mapToArray(object)
            }
            if (tag == setTag) {
              return setToPairs(object)
            }
            return baseToPairs(object, keysFunc(object))
          }
        }
        function createWrap(
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          argPos,
          ary2,
          arity,
        ) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          var length = partials ? partials.length : 0
          if (!length) {
            bitmask &= -97
            partials = holders = undefined$1
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0)
          arity = arity === undefined$1 ? arity : toInteger(arity)
          length -= holders ? holders.length : 0
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
              holdersRight = holders
            partials = holders = undefined$1
          }
          var data = isBindKey ? undefined$1 : getData(func)
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity,
          ]
          if (data) {
            mergeData(newData, data)
          }
          func = newData[0]
          bitmask = newData[1]
          thisArg = newData[2]
          partials = newData[3]
          holders = newData[4]
          arity = newData[9] =
            newData[9] === undefined$1
              ? isBindKey
                ? 0
                : func.length
              : nativeMax(newData[9] - length, 0)
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= -25
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg)
          } else if (
            bitmask == WRAP_CURRY_FLAG ||
            bitmask == WRAP_CURRY_RIGHT_FLAG
          ) {
            result2 = createCurry(func, bitmask, arity)
          } else if (
            (bitmask == WRAP_PARTIAL_FLAG ||
              bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &&
            !holders.length
          ) {
            result2 = createPartial(func, bitmask, thisArg, partials)
          } else {
            result2 = createHybrid.apply(undefined$1, newData)
          }
          var setter = data ? baseSetData : setData
          return setWrapToString(setter(result2, newData), func, bitmask)
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (
            objValue === undefined$1 ||
            (eq(objValue, objectProto[key]) &&
              !hasOwnProperty.call(object, key))
          ) {
            return srcValue
          }
          return objValue
        }
        function customDefaultsMerge(
          objValue,
          srcValue,
          key,
          object,
          source,
          stack,
        ) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue)
            baseMerge(
              objValue,
              srcValue,
              undefined$1,
              customDefaultsMerge,
              stack,
            )
            stack['delete'](srcValue)
          }
          return objValue
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value
        }
        function equalArrays(
          array,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack,
        ) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            arrLength = array.length,
            othLength = other.length
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false
          }
          var arrStacked = stack.get(array)
          var othStacked = stack.get(other)
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array
          }
          var index = -1,
            result2 = true,
            seen =
              bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1
          stack.set(array, other)
          stack.set(other, array)
          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index]
            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack)
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue
              }
              result2 = false
              break
            }
            if (seen) {
              if (
                !arraySome(other, function (othValue2, othIndex) {
                  if (
                    !cacheHas(seen, othIndex) &&
                    (arrValue === othValue2 ||
                      equalFunc(
                        arrValue,
                        othValue2,
                        bitmask,
                        customizer,
                        stack,
                      ))
                  ) {
                    return seen.push(othIndex)
                  }
                })
              ) {
                result2 = false
                break
              }
            } else if (
              !(
                arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
              )
            ) {
              result2 = false
              break
            }
          }
          stack['delete'](array)
          stack['delete'](other)
          return result2
        }
        function equalByTag(
          object,
          other,
          tag,
          bitmask,
          customizer,
          equalFunc,
          stack,
        ) {
          switch (tag) {
            case dataViewTag:
              if (
                object.byteLength != other.byteLength ||
                object.byteOffset != other.byteOffset
              ) {
                return false
              }
              object = object.buffer
              other = other.buffer
            case arrayBufferTag:
              if (
                object.byteLength != other.byteLength ||
                !equalFunc(new Uint8Array2(object), new Uint8Array2(other))
              ) {
                return false
              }
              return true
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other)
            case errorTag:
              return (
                object.name == other.name && object.message == other.message
              )
            case regexpTag:
            case stringTag:
              return object == other + ''
            case mapTag:
              var convert = mapToArray
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG
              convert || (convert = setToArray)
              if (object.size != other.size && !isPartial) {
                return false
              }
              var stacked = stack.get(object)
              if (stacked) {
                return stacked == other
              }
              bitmask |= COMPARE_UNORDERED_FLAG
              stack.set(object, other)
              var result2 = equalArrays(
                convert(object),
                convert(other),
                bitmask,
                customizer,
                equalFunc,
                stack,
              )
              stack['delete'](object)
              return result2
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other)
              }
          }
          return false
        }
        function equalObjects(
          object,
          other,
          bitmask,
          customizer,
          equalFunc,
          stack,
        ) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length
          if (objLength != othLength && !isPartial) {
            return false
          }
          var index = objLength
          while (index--) {
            var key = objProps[index]
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false
            }
          }
          var objStacked = stack.get(object)
          var othStacked = stack.get(other)
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object
          }
          var result2 = true
          stack.set(object, other)
          stack.set(other, object)
          var skipCtor = isPartial
          while (++index < objLength) {
            key = objProps[index]
            var objValue = object[key],
              othValue = other[key]
            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack)
            }
            if (
              !(compared === undefined$1
                ? objValue === othValue ||
                  equalFunc(objValue, othValue, bitmask, customizer, stack)
                : compared)
            ) {
              result2 = false
              break
            }
            skipCtor || (skipCtor = key == 'constructor')
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor,
              othCtor = other.constructor
            if (
              objCtor != othCtor &&
              'constructor' in object &&
              'constructor' in other &&
              !(
                typeof objCtor == 'function' &&
                objCtor instanceof objCtor &&
                typeof othCtor == 'function' &&
                othCtor instanceof othCtor
              )
            ) {
              result2 = false
            }
          }
          stack['delete'](object)
          stack['delete'](other)
          return result2
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + '')
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols)
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn)
        }
        var getData = !metaMap
          ? noop2
          : function (func) {
              return metaMap.get(func)
            }
        function getFuncName(func) {
          var result2 = func.name + '',
            array = realNames[result2],
            length = hasOwnProperty.call(realNames, result2) ? array.length : 0
          while (length--) {
            var data = array[length],
              otherFunc = data.func
            if (otherFunc == null || otherFunc == func) {
              return data.name
            }
          }
          return result2
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash2, 'placeholder')
            ? lodash2
            : func
          return object.placeholder
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee
          result2 = result2 === iteratee ? baseIteratee : result2
          return arguments.length
            ? result2(arguments[0], arguments[1])
            : result2
        }
        function getMapData(map2, key) {
          var data = map2.__data__
          return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map
        }
        function getMatchData(object) {
          var result2 = keys(object),
            length = result2.length
          while (length--) {
            var key = result2[length],
              value = object[key]
            result2[length] = [key, value, isStrictComparable(value)]
          }
          return result2
        }
        function getNative(object, key) {
          var value = getValue(object, key)
          return baseIsNative(value) ? value : undefined$1
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag]
          try {
            value[symToStringTag] = undefined$1
            var unmasked = true
          } catch (e) {}
          var result2 = nativeObjectToString.call(value)
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag
            } else {
              delete value[symToStringTag]
            }
          }
          return result2
        }
        var getSymbols = !nativeGetSymbols
          ? stubArray
          : function (object) {
              if (object == null) {
                return []
              }
              object = Object2(object)
              return arrayFilter(nativeGetSymbols(object), function (symbol) {
                return propertyIsEnumerable.call(object, symbol)
              })
            }
        var getSymbolsIn = !nativeGetSymbols
          ? stubArray
          : function (object) {
              var result2 = []
              while (object) {
                arrayPush(result2, getSymbols(object))
                object = getPrototype(object)
              }
              return result2
            }
        var getTag = baseGetTag
        if (
          (DataView &&
            getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
          (Map2 && getTag(new Map2()) != mapTag) ||
          (Promise2 && getTag(Promise2.resolve()) != promiseTag) ||
          (Set2 && getTag(new Set2()) != setTag) ||
          (WeakMap2 && getTag(new WeakMap2()) != weakMapTag)
        ) {
          getTag = function (value) {
            var result2 = baseGetTag(value),
              Ctor = result2 == objectTag ? value.constructor : undefined$1,
              ctorString = Ctor ? toSource(Ctor) : ''
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag
                case mapCtorString:
                  return mapTag
                case promiseCtorString:
                  return promiseTag
                case setCtorString:
                  return setTag
                case weakMapCtorString:
                  return weakMapTag
              }
            }
            return result2
          }
        }
        function getView(start, end, transforms) {
          var index = -1,
            length = transforms.length
          while (++index < length) {
            var data = transforms[index],
              size2 = data.size
            switch (data.type) {
              case 'drop':
                start += size2
                break
              case 'dropRight':
                end -= size2
                break
              case 'take':
                end = nativeMin(end, start + size2)
                break
              case 'takeRight':
                start = nativeMax(start, end - size2)
                break
            }
          }
          return {start: start, end: end}
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails)
          return match2 ? match2[1].split(reSplitDetails) : []
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object)
          var index = -1,
            length = path.length,
            result2 = false
          while (++index < length) {
            var key = toKey(path[index])
            if (!(result2 = object != null && hasFunc(object, key))) {
              break
            }
            object = object[key]
          }
          if (result2 || ++index != length) {
            return result2
          }
          length = object == null ? 0 : object.length
          return (
            !!length &&
            isLength(length) &&
            isIndex(key, length) &&
            (isArray2(object) || isArguments(object))
          )
        }
        function initCloneArray(array) {
          var length = array.length,
            result2 = new array.constructor(length)
          if (
            length &&
            typeof array[0] == 'string' &&
            hasOwnProperty.call(array, 'index')
          ) {
            result2.index = array.index
            result2.input = array.input
          }
          return result2
        }
        function initCloneObject(object) {
          return typeof object.constructor == 'function' && !isPrototype(object)
            ? baseCreate(getPrototype(object))
            : {}
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object)
            case boolTag:
            case dateTag:
              return new Ctor(+object)
            case dataViewTag:
              return cloneDataView(object, isDeep)
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep)
            case mapTag:
              return new Ctor()
            case numberTag:
            case stringTag:
              return new Ctor(object)
            case regexpTag:
              return cloneRegExp(object)
            case setTag:
              return new Ctor()
            case symbolTag:
              return cloneSymbol(object)
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length
          if (!length) {
            return source
          }
          var lastIndex = length - 1
          details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex]
          details = details.join(length > 2 ? ', ' : ' ')
          return source.replace(
            reWrapComment,
            '{\n/* [wrapped with ' + details + '] */\n',
          )
        }
        function isFlattenable(value) {
          return (
            isArray2(value) ||
            isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol])
          )
        }
        function isIndex(value, length) {
          var type = typeof value
          length = length == null ? MAX_SAFE_INTEGER : length
          return (
            !!length &&
            (type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&
            value > -1 &&
            value % 1 == 0 &&
            value < length
          )
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false
          }
          var type = typeof index
          if (
            type == 'number'
              ? isArrayLike(object) && isIndex(index, object.length)
              : type == 'string' && index in object
          ) {
            return eq(object[index], value)
          }
          return false
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false
          }
          var type = typeof value
          if (
            type == 'number' ||
            type == 'symbol' ||
            type == 'boolean' ||
            value == null ||
            isSymbol(value)
          ) {
            return true
          }
          return (
            reIsPlainProp.test(value) ||
            !reIsDeepProp.test(value) ||
            (object != null && value in Object2(object))
          )
        }
        function isKeyable(value) {
          var type = typeof value
          return type == 'string' ||
            type == 'number' ||
            type == 'symbol' ||
            type == 'boolean'
            ? value !== '__proto__'
            : value === null
        }
        function isLaziable(func) {
          var funcName = getFuncName(func),
            other = lodash2[funcName]
          if (
            typeof other != 'function' ||
            !(funcName in LazyWrapper.prototype)
          ) {
            return false
          }
          if (func === other) {
            return true
          }
          var data = getData(other)
          return !!data && func === data[0]
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func
        }
        var isMaskable = coreJsData ? isFunction : stubFalse
        function isPrototype(value) {
          var Ctor = value && value.constructor,
            proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto
          return value === proto
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value)
        }
        function matchesStrictComparable(key, srcValue) {
          return function (object) {
            if (object == null) {
              return false
            }
            return (
              object[key] === srcValue &&
              (srcValue !== undefined$1 || key in Object2(object))
            )
          }
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function (key) {
            if (cache2.size === MAX_MEMOIZE_SIZE) {
              cache2.clear()
            }
            return key
          })
          var cache2 = result2.cache
          return result2
        }
        function mergeData(data, source) {
          var bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask,
            isCommon =
              newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG)
          var isCombo =
            (srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG) ||
            (srcBitmask == WRAP_ARY_FLAG &&
              bitmask == WRAP_REARG_FLAG &&
              data[7].length <= source[8]) ||
            (srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) &&
              source[7].length <= source[8] &&
              bitmask == WRAP_CURRY_FLAG)
          if (!(isCommon || isCombo)) {
            return data
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2]
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG
          }
          var value = source[3]
          if (value) {
            var partials = data[3]
            data[3] = partials ? composeArgs(partials, value, source[4]) : value
            data[4] = partials
              ? replaceHolders(data[3], PLACEHOLDER)
              : source[4]
          }
          value = source[5]
          if (value) {
            partials = data[5]
            data[5] = partials
              ? composeArgsRight(partials, value, source[6])
              : value
            data[6] = partials
              ? replaceHolders(data[5], PLACEHOLDER)
              : source[6]
          }
          value = source[7]
          if (value) {
            data[7] = value
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] =
              data[8] == null ? source[8] : nativeMin(data[8], source[8])
          }
          if (data[9] == null) {
            data[9] = source[9]
          }
          data[0] = source[0]
          data[1] = newBitmask
          return data
        }
        function nativeKeysIn(object) {
          var result2 = []
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key)
            }
          }
          return result2
        }
        function objectToString(value) {
          return nativeObjectToString.call(value)
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0)
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array2(length)
            while (++index < length) {
              array[index] = args[start + index]
            }
            index = -1
            var otherArgs = Array2(start + 1)
            while (++index < start) {
              otherArgs[index] = args[index]
            }
            otherArgs[start] = transform2(array)
            return apply(func, this, otherArgs)
          }
        }
        function parent(object, path) {
          return path.length < 2
            ? object
            : baseGet(object, baseSlice(path, 0, -1))
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = copyArray(array)
          while (length--) {
            var index = indexes[length]
            array[length] = isIndex(index, arrLength)
              ? oldArray[index]
              : undefined$1
          }
          return array
        }
        function safeGet(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return
          }
          if (key == '__proto__') {
            return
          }
          return object[key]
        }
        var setData = shortOut(baseSetData)
        var setTimeout2 =
          ctxSetTimeout ||
          function (func, wait) {
            return root.setTimeout(func, wait)
          }
        var setToString = shortOut(baseSetToString)
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + ''
          return setToString(
            wrapper,
            insertWrapDetails(
              source,
              updateWrapDetails(getWrapDetails(source), bitmask),
            ),
          )
        }
        function shortOut(func) {
          var count = 0,
            lastCalled = 0
          return function () {
            var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled)
            lastCalled = stamp
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0]
              }
            } else {
              count = 0
            }
            return func.apply(undefined$1, arguments)
          }
        }
        function shuffleSelf(array, size2) {
          var index = -1,
            length = array.length,
            lastIndex = length - 1
          size2 = size2 === undefined$1 ? length : size2
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex),
              value = array[rand]
            array[rand] = array[index]
            array[index] = value
          }
          array.length = size2
          return array
        }
        var stringToPath = memoizeCapped(function (string) {
          var result2 = []
          if (string.charCodeAt(0) === 46) {
            result2.push('')
          }
          string.replace(
            rePropName,
            function (match2, number, quote, subString) {
              result2.push(
                quote
                  ? subString.replace(reEscapeChar, '$1')
                  : number || match2,
              )
            },
          )
          return result2
        })
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value
          }
          var result2 = value + ''
          return result2 == '0' && 1 / value == -INFINITY ? '-0' : result2
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func)
            } catch (e) {}
            try {
              return func + ''
            } catch (e) {}
          }
          return ''
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function (pair) {
            var value = '_.' + pair[0]
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value)
            }
          })
          return details.sort()
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone()
          }
          var result2 = new LodashWrapper(
            wrapper.__wrapped__,
            wrapper.__chain__,
          )
          result2.__actions__ = copyArray(wrapper.__actions__)
          result2.__index__ = wrapper.__index__
          result2.__values__ = wrapper.__values__
          return result2
        }
        function chunk(array, size2, guard) {
          if (
            guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1
          ) {
            size2 = 1
          } else {
            size2 = nativeMax(toInteger(size2), 0)
          }
          var length = array == null ? 0 : array.length
          if (!length || size2 < 1) {
            return []
          }
          var index = 0,
            resIndex = 0,
            result2 = Array2(nativeCeil(length / size2))
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, (index += size2))
          }
          return result2
        }
        function compact(array) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result2 = []
          while (++index < length) {
            var value = array[index]
            if (value) {
              result2[resIndex++] = value
            }
          }
          return result2
        }
        function concat() {
          var length = arguments.length
          if (!length) {
            return []
          }
          var args = Array2(length - 1),
            array = arguments[0],
            index = length
          while (index--) {
            args[index - 1] = arguments[index]
          }
          return arrayPush(
            isArray2(array) ? copyArray(array) : [array],
            baseFlatten(args, 1),
          )
        }
        var difference = baseRest(function (array, values2) {
          return isArrayLikeObject(array)
            ? baseDifference(
                array,
                baseFlatten(values2, 1, isArrayLikeObject, true),
              )
            : []
        })
        var differenceBy = baseRest(function (array, values2) {
          var iteratee2 = last(values2)
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1
          }
          return isArrayLikeObject(array)
            ? baseDifference(
                array,
                baseFlatten(values2, 1, isArrayLikeObject, true),
                getIteratee(iteratee2, 2),
              )
            : []
        })
        var differenceWith = baseRest(function (array, values2) {
          var comparator = last(values2)
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1
          }
          return isArrayLikeObject(array)
            ? baseDifference(
                array,
                baseFlatten(values2, 1, isArrayLikeObject, true),
                undefined$1,
                comparator,
              )
            : []
        })
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return []
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n)
          return baseSlice(array, n < 0 ? 0 : n, length)
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return []
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n)
          n = length - n
          return baseSlice(array, 0, n < 0 ? 0 : n)
        }
        function dropRightWhile(array, predicate) {
          return array && array.length
            ? baseWhile(array, getIteratee(predicate, 3), true, true)
            : []
        }
        function dropWhile(array, predicate) {
          return array && array.length
            ? baseWhile(array, getIteratee(predicate, 3), true)
            : []
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return []
          }
          if (
            start &&
            typeof start != 'number' &&
            isIterateeCall(array, value, start)
          ) {
            start = 0
            end = length
          }
          return baseFill(array, value, start, end)
        }
        function findIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return -1
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex)
          if (index < 0) {
            index = nativeMax(length + index, 0)
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index)
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return -1
          }
          var index = length - 1
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex)
            index =
              fromIndex < 0
                ? nativeMax(length + index, 0)
                : nativeMin(index, length - 1)
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true)
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length
          return length ? baseFlatten(array, 1) : []
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length
          return length ? baseFlatten(array, INFINITY) : []
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return []
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth)
          return baseFlatten(array, depth)
        }
        function fromPairs(pairs) {
          var index = -1,
            length = pairs == null ? 0 : pairs.length,
            result2 = {}
          while (++index < length) {
            var pair = pairs[index]
            result2[pair[0]] = pair[1]
          }
          return result2
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return -1
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex)
          if (index < 0) {
            index = nativeMax(length + index, 0)
          }
          return baseIndexOf(array, value, index)
        }
        function initial(array) {
          var length = array == null ? 0 : array.length
          return length ? baseSlice(array, 0, -1) : []
        }
        var intersection = baseRest(function (arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject)
          return mapped.length && mapped[0] === arrays[0]
            ? baseIntersection(mapped)
            : []
        })
        var intersectionBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject)
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1
          } else {
            mapped.pop()
          }
          return mapped.length && mapped[0] === arrays[0]
            ? baseIntersection(mapped, getIteratee(iteratee2, 2))
            : []
        })
        var intersectionWith = baseRest(function (arrays) {
          var comparator = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject)
          comparator =
            typeof comparator == 'function' ? comparator : undefined$1
          if (comparator) {
            mapped.pop()
          }
          return mapped.length && mapped[0] === arrays[0]
            ? baseIntersection(mapped, undefined$1, comparator)
            : []
        })
        function join2(array, separator) {
          return array == null ? '' : nativeJoin.call(array, separator)
        }
        function last(array) {
          var length = array == null ? 0 : array.length
          return length ? array[length - 1] : undefined$1
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return -1
          }
          var index = length
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex)
            index =
              index < 0
                ? nativeMax(length + index, 0)
                : nativeMin(index, length - 1)
          }
          return value === value
            ? strictLastIndexOf(array, value, index)
            : baseFindIndex(array, baseIsNaN, index, true)
        }
        function nth(array, n) {
          return array && array.length
            ? baseNth(array, toInteger(n))
            : undefined$1
        }
        var pull = baseRest(pullAll)
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length
            ? basePullAll(array, values2)
            : array
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length
            ? basePullAll(array, values2, getIteratee(iteratee2, 2))
            : array
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length
            ? basePullAll(array, values2, undefined$1, comparator)
            : array
        }
        var pullAt = flatRest(function (array, indexes) {
          var length = array == null ? 0 : array.length,
            result2 = baseAt(array, indexes)
          basePullAt(
            array,
            arrayMap(indexes, function (index) {
              return isIndex(index, length) ? +index : index
            }).sort(compareAscending),
          )
          return result2
        })
        function remove(array, predicate) {
          var result2 = []
          if (!(array && array.length)) {
            return result2
          }
          var index = -1,
            indexes = [],
            length = array.length
          predicate = getIteratee(predicate, 3)
          while (++index < length) {
            var value = array[index]
            if (predicate(value, index, array)) {
              result2.push(value)
              indexes.push(index)
            }
          }
          basePullAt(array, indexes)
          return result2
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array)
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return []
          }
          if (
            end &&
            typeof end != 'number' &&
            isIterateeCall(array, start, end)
          ) {
            start = 0
            end = length
          } else {
            start = start == null ? 0 : toInteger(start)
            end = end === undefined$1 ? length : toInteger(end)
          }
          return baseSlice(array, start, end)
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value)
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2))
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length
          if (length) {
            var index = baseSortedIndex(array, value)
            if (index < length && eq(array[index], value)) {
              return index
            }
          }
          return -1
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true)
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(
            array,
            value,
            getIteratee(iteratee2, 2),
            true,
          )
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1
            if (eq(array[index], value)) {
              return index
            }
          }
          return -1
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : []
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length
            ? baseSortedUniq(array, getIteratee(iteratee2, 2))
            : []
        }
        function tail(array) {
          var length = array == null ? 0 : array.length
          return length ? baseSlice(array, 1, length) : []
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return []
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n)
          return baseSlice(array, 0, n < 0 ? 0 : n)
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length
          if (!length) {
            return []
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n)
          n = length - n
          return baseSlice(array, n < 0 ? 0 : n, length)
        }
        function takeRightWhile(array, predicate) {
          return array && array.length
            ? baseWhile(array, getIteratee(predicate, 3), false, true)
            : []
        }
        function takeWhile(array, predicate) {
          return array && array.length
            ? baseWhile(array, getIteratee(predicate, 3))
            : []
        }
        var union = baseRest(function (arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true))
        })
        var unionBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays)
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1
          }
          return baseUniq(
            baseFlatten(arrays, 1, isArrayLikeObject, true),
            getIteratee(iteratee2, 2),
          )
        })
        var unionWith = baseRest(function (arrays) {
          var comparator = last(arrays)
          comparator =
            typeof comparator == 'function' ? comparator : undefined$1
          return baseUniq(
            baseFlatten(arrays, 1, isArrayLikeObject, true),
            undefined$1,
            comparator,
          )
        })
        function uniq(array) {
          return array && array.length ? baseUniq(array) : []
        }
        function uniqBy(array, iteratee2) {
          return array && array.length
            ? baseUniq(array, getIteratee(iteratee2, 2))
            : []
        }
        function uniqWith(array, comparator) {
          comparator =
            typeof comparator == 'function' ? comparator : undefined$1
          return array && array.length
            ? baseUniq(array, undefined$1, comparator)
            : []
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return []
          }
          var length = 0
          array = arrayFilter(array, function (group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length)
              return true
            }
          })
          return baseTimes(length, function (index) {
            return arrayMap(array, baseProperty(index))
          })
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return []
          }
          var result2 = unzip(array)
          if (iteratee2 == null) {
            return result2
          }
          return arrayMap(result2, function (group) {
            return apply(iteratee2, undefined$1, group)
          })
        }
        var without = baseRest(function (array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : []
        })
        var xor = baseRest(function (arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject))
        })
        var xorBy = baseRest(function (arrays) {
          var iteratee2 = last(arrays)
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1
          }
          return baseXor(
            arrayFilter(arrays, isArrayLikeObject),
            getIteratee(iteratee2, 2),
          )
        })
        var xorWith = baseRest(function (arrays) {
          var comparator = last(arrays)
          comparator =
            typeof comparator == 'function' ? comparator : undefined$1
          return baseXor(
            arrayFilter(arrays, isArrayLikeObject),
            undefined$1,
            comparator,
          )
        })
        var zip = baseRest(unzip)
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue)
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet)
        }
        var zipWith = baseRest(function (arrays) {
          var length = arrays.length,
            iteratee2 = length > 1 ? arrays[length - 1] : undefined$1
          iteratee2 =
            typeof iteratee2 == 'function'
              ? (arrays.pop(), iteratee2)
              : undefined$1
          return unzipWith(arrays, iteratee2)
        })
        function chain(value) {
          var result2 = lodash2(value)
          result2.__chain__ = true
          return result2
        }
        function tap(value, interceptor) {
          interceptor(value)
          return value
        }
        function thru(value, interceptor) {
          return interceptor(value)
        }
        var wrapperAt = flatRest(function (paths) {
          var length = paths.length,
            start = length ? paths[0] : 0,
            value = this.__wrapped__,
            interceptor = function (object) {
              return baseAt(object, paths)
            }
          if (
            length > 1 ||
            this.__actions__.length ||
            !(value instanceof LazyWrapper) ||
            !isIndex(start)
          ) {
            return this.thru(interceptor)
          }
          value = value.slice(start, +start + (length ? 1 : 0))
          value.__actions__.push({
            func: thru,
            args: [interceptor],
            thisArg: undefined$1,
          })
          return new LodashWrapper(value, this.__chain__).thru(
            function (array) {
              if (length && !array.length) {
                array.push(undefined$1)
              }
              return array
            },
          )
        })
        function wrapperChain() {
          return chain(this)
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__)
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray2(this.value())
          }
          var done = this.__index__ >= this.__values__.length,
            value = done ? undefined$1 : this.__values__[this.__index__++]
          return {done: done, value: value}
        }
        function wrapperToIterator() {
          return this
        }
        function wrapperPlant(value) {
          var result2,
            parent2 = this
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2)
            clone2.__index__ = 0
            clone2.__values__ = undefined$1
            if (result2) {
              previous.__wrapped__ = clone2
            } else {
              result2 = clone2
            }
            var previous = clone2
            parent2 = parent2.__wrapped__
          }
          previous.__wrapped__ = value
          return result2
        }
        function wrapperReverse() {
          var value = this.__wrapped__
          if (value instanceof LazyWrapper) {
            var wrapped = value
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this)
            }
            wrapped = wrapped.reverse()
            wrapped.__actions__.push({
              func: thru,
              args: [reverse],
              thisArg: undefined$1,
            })
            return new LodashWrapper(wrapped, this.__chain__)
          }
          return this.thru(reverse)
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__)
        }
        var countBy = createAggregator(function (result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key]
          } else {
            baseAssignValue(result2, key, 1)
          }
        })
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1
          }
          return func(collection, getIteratee(predicate, 3))
        }
        function filter(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter
          return func(collection, getIteratee(predicate, 3))
        }
        var find = createFind(findIndex2)
        var findLast = createFind(findLastIndex)
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1)
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY)
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth)
          return baseFlatten(map(collection, iteratee2), depth)
        }
        function forEach(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach
          return func(collection, getIteratee(iteratee2, 3))
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight
          return func(collection, getIteratee(iteratee2, 3))
        }
        var groupBy = createAggregator(function (result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value)
          } else {
            baseAssignValue(result2, key, [value])
          }
        })
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection)
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0
          var length = collection.length
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0)
          }
          return isString(collection)
            ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
            : !!length && baseIndexOf(collection, value, fromIndex) > -1
        }
        var invokeMap = baseRest(function (collection, path, args) {
          var index = -1,
            isFunc = typeof path == 'function',
            result2 = isArrayLike(collection) ? Array2(collection.length) : []
          baseEach(collection, function (value) {
            result2[++index] = isFunc
              ? apply(path, value, args)
              : baseInvoke(value, path, args)
          })
          return result2
        })
        var keyBy = createAggregator(function (result2, value, key) {
          baseAssignValue(result2, key, value)
        })
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap
          return func(collection, getIteratee(iteratee2, 3))
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return []
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees]
          }
          orders = guard ? undefined$1 : orders
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders]
          }
          return baseOrderBy(collection, iteratees, orders)
        }
        var partition = createAggregator(
          function (result2, value, key) {
            result2[key ? 0 : 1].push(value)
          },
          function () {
            return [[], []]
          },
        )
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce,
            initAccum = arguments.length < 3
          return func(
            collection,
            getIteratee(iteratee2, 4),
            accumulator,
            initAccum,
            baseEach,
          )
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce,
            initAccum = arguments.length < 3
          return func(
            collection,
            getIteratee(iteratee2, 4),
            accumulator,
            initAccum,
            baseEachRight,
          )
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter
          return func(collection, negate(getIteratee(predicate, 3)))
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample
          return func(collection)
        }
        function sampleSize(collection, n, guard) {
          if (
            guard ? isIterateeCall(collection, n, guard) : n === undefined$1
          ) {
            n = 1
          } else {
            n = toInteger(n)
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize
          return func(collection, n)
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle
          return func(collection)
        }
        function size(collection) {
          if (collection == null) {
            return 0
          }
          if (isArrayLike(collection)) {
            return isString(collection)
              ? stringSize(collection)
              : collection.length
          }
          var tag = getTag(collection)
          if (tag == mapTag || tag == setTag) {
            return collection.size
          }
          return baseKeys(collection).length
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1
          }
          return func(collection, getIteratee(predicate, 3))
        }
        var sortBy = baseRest(function (collection, iteratees) {
          if (collection == null) {
            return []
          }
          var length = iteratees.length
          if (
            length > 1 &&
            isIterateeCall(collection, iteratees[0], iteratees[1])
          ) {
            iteratees = []
          } else if (
            length > 2 &&
            isIterateeCall(iteratees[0], iteratees[1], iteratees[2])
          ) {
            iteratees = [iteratees[0]]
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), [])
        })
        var now =
          ctxNow ||
          function () {
            return root.Date.now()
          }
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          n = toInteger(n)
          return function () {
            if (--n < 1) {
              return func.apply(this, arguments)
            }
          }
        }
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n
          n = func && n == null ? func.length : n
          return createWrap(
            func,
            WRAP_ARY_FLAG,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            n,
          )
        }
        function before(n, func) {
          var result2
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          n = toInteger(n)
          return function () {
            if (--n > 0) {
              result2 = func.apply(this, arguments)
            }
            if (n <= 1) {
              func = undefined$1
            }
            return result2
          }
        }
        var bind = baseRest(function (func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind))
            bitmask |= WRAP_PARTIAL_FLAG
          }
          return createWrap(func, bitmask, thisArg, partials, holders)
        })
        var bindKey = baseRest(function (object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey))
            bitmask |= WRAP_PARTIAL_FLAG
          }
          return createWrap(key, bitmask, object, partials, holders)
        })
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity
          var result2 = createWrap(
            func,
            WRAP_CURRY_FLAG,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            arity,
          )
          result2.placeholder = curry.placeholder
          return result2
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity
          var result2 = createWrap(
            func,
            WRAP_CURRY_RIGHT_FLAG,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            undefined$1,
            arity,
          )
          result2.placeholder = curryRight.placeholder
          return result2
        }
        function debounce(func, wait, options) {
          var lastArgs,
            lastThis,
            maxWait,
            result2,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          wait = toNumber2(wait) || 0
          if (isObject(options)) {
            leading = !!options.leading
            maxing = 'maxWait' in options
            maxWait = maxing
              ? nativeMax(toNumber2(options.maxWait) || 0, wait)
              : maxWait
            trailing = 'trailing' in options ? !!options.trailing : trailing
          }
          function invokeFunc(time) {
            var args = lastArgs,
              thisArg = lastThis
            lastArgs = lastThis = undefined$1
            lastInvokeTime = time
            result2 = func.apply(thisArg, args)
            return result2
          }
          function leadingEdge(time) {
            lastInvokeTime = time
            timerId = setTimeout2(timerExpired, wait)
            return leading ? invokeFunc(time) : result2
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall
            return maxing
              ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
              : timeWaiting
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime
            return (
              lastCallTime === undefined$1 ||
              timeSinceLastCall >= wait ||
              timeSinceLastCall < 0 ||
              (maxing && timeSinceLastInvoke >= maxWait)
            )
          }
          function timerExpired() {
            var time = now()
            if (shouldInvoke(time)) {
              return trailingEdge(time)
            }
            timerId = setTimeout2(timerExpired, remainingWait(time))
          }
          function trailingEdge(time) {
            timerId = undefined$1
            if (trailing && lastArgs) {
              return invokeFunc(time)
            }
            lastArgs = lastThis = undefined$1
            return result2
          }
          function cancel2() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId)
            }
            lastInvokeTime = 0
            lastArgs = lastCallTime = lastThis = timerId = undefined$1
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now())
          }
          function debounced() {
            var time = now(),
              isInvoking = shouldInvoke(time)
            lastArgs = arguments
            lastThis = this
            lastCallTime = time
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime)
              }
              if (maxing) {
                clearTimeout2(timerId)
                timerId = setTimeout2(timerExpired, wait)
                return invokeFunc(lastCallTime)
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait)
            }
            return result2
          }
          debounced.cancel = cancel2
          debounced.flush = flush
          return debounced
        }
        var defer = baseRest(function (func, args) {
          return baseDelay(func, 1, args)
        })
        var delay = baseRest(function (func, wait, args) {
          return baseDelay(func, toNumber2(wait) || 0, args)
        })
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG)
        }
        function memoize(func, resolver) {
          if (
            typeof func != 'function' ||
            (resolver != null && typeof resolver != 'function')
          ) {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          var memoized = function () {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache2 = memoized.cache
            if (cache2.has(key)) {
              return cache2.get(key)
            }
            var result2 = func.apply(this, args)
            memoized.cache = cache2.set(key, result2) || cache2
            return result2
          }
          memoized.cache = new (memoize.Cache || MapCache)()
          return memoized
        }
        memoize.Cache = MapCache
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          return function () {
            var args = arguments
            switch (args.length) {
              case 0:
                return !predicate.call(this)
              case 1:
                return !predicate.call(this, args[0])
              case 2:
                return !predicate.call(this, args[0], args[1])
              case 3:
                return !predicate.call(this, args[0], args[1], args[2])
            }
            return !predicate.apply(this, args)
          }
        }
        function once(func) {
          return before(2, func)
        }
        var overArgs = castRest(function (func, transforms) {
          transforms =
            transforms.length == 1 && isArray2(transforms[0])
              ? arrayMap(transforms[0], baseUnary(getIteratee()))
              : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()))
          var funcsLength = transforms.length
          return baseRest(function (args) {
            var index = -1,
              length = nativeMin(args.length, funcsLength)
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index])
            }
            return apply(func, this, args)
          })
        })
        var partial = baseRest(function (func, partials) {
          var holders = replaceHolders(partials, getHolder(partial))
          return createWrap(
            func,
            WRAP_PARTIAL_FLAG,
            undefined$1,
            partials,
            holders,
          )
        })
        var partialRight = baseRest(function (func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight))
          return createWrap(
            func,
            WRAP_PARTIAL_RIGHT_FLAG,
            undefined$1,
            partials,
            holders,
          )
        })
        var rearg = flatRest(function (func, indexes) {
          return createWrap(
            func,
            WRAP_REARG_FLAG,
            undefined$1,
            undefined$1,
            undefined$1,
            indexes,
          )
        })
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          start = start === undefined$1 ? start : toInteger(start)
          return baseRest(func, start)
        }
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0)
          return baseRest(function (args) {
            var array = args[start],
              otherArgs = castSlice(args, 0, start)
            if (array) {
              arrayPush(otherArgs, array)
            }
            return apply(func, this, otherArgs)
          })
        }
        function throttle(func, wait, options) {
          var leading = true,
            trailing = true
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT)
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading
            trailing = 'trailing' in options ? !!options.trailing : trailing
          }
          return debounce(func, wait, {
            leading: leading,
            maxWait: wait,
            trailing: trailing,
          })
        }
        function unary(func) {
          return ary(func, 1)
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value)
        }
        function castArray() {
          if (!arguments.length) {
            return []
          }
          var value = arguments[0]
          return isArray2(value) ? value : [value]
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG)
        }
        function cloneWith(value, customizer) {
          customizer =
            typeof customizer == 'function' ? customizer : undefined$1
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer)
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
        }
        function cloneDeepWith(value, customizer) {
          customizer =
            typeof customizer == 'function' ? customizer : undefined$1
          return baseClone(
            value,
            CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG,
            customizer,
          )
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source))
        }
        function eq(value, other) {
          return value === other || (value !== value && other !== other)
        }
        var gt = createRelationalOperation(baseGt)
        var gte = createRelationalOperation(function (value, other) {
          return value >= other
        })
        var isArguments = baseIsArguments(
          /* @__PURE__ */ (function () {
            return arguments
          })(),
        )
          ? baseIsArguments
          : function (value) {
              return (
                isObjectLike(value) &&
                hasOwnProperty.call(value, 'callee') &&
                !propertyIsEnumerable.call(value, 'callee')
              )
            }
        var isArray2 = Array2.isArray
        var isArrayBuffer = nodeIsArrayBuffer
          ? baseUnary(nodeIsArrayBuffer)
          : baseIsArrayBuffer
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value)
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value)
        }
        function isBoolean(value) {
          return (
            value === true ||
            value === false ||
            (isObjectLike(value) && baseGetTag(value) == boolTag)
          )
        }
        var isBuffer = nativeIsBuffer || stubFalse
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate
        function isElement(value) {
          return (
            isObjectLike(value) &&
            value.nodeType === 1 &&
            !isPlainObject2(value)
          )
        }
        function isEmpty(value) {
          if (value == null) {
            return true
          }
          if (
            isArrayLike(value) &&
            (isArray2(value) ||
              typeof value == 'string' ||
              typeof value.splice == 'function' ||
              isBuffer(value) ||
              isTypedArray(value) ||
              isArguments(value))
          ) {
            return !value.length
          }
          var tag = getTag(value)
          if (tag == mapTag || tag == setTag) {
            return !value.size
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false
            }
          }
          return true
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other)
        }
        function isEqualWith(value, other, customizer) {
          customizer =
            typeof customizer == 'function' ? customizer : undefined$1
          var result2 = customizer ? customizer(value, other) : undefined$1
          return result2 === undefined$1
            ? baseIsEqual(value, other, undefined$1, customizer)
            : !!result2
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false
          }
          var tag = baseGetTag(value)
          return (
            tag == errorTag ||
            tag == domExcTag ||
            (typeof value.message == 'string' &&
              typeof value.name == 'string' &&
              !isPlainObject2(value))
          )
        }
        function isFinite2(value) {
          return typeof value == 'number' && nativeIsFinite(value)
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false
          }
          var tag = baseGetTag(value)
          return (
            tag == funcTag ||
            tag == genTag ||
            tag == asyncTag ||
            tag == proxyTag
          )
        }
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value)
        }
        function isLength(value) {
          return (
            typeof value == 'number' &&
            value > -1 &&
            value % 1 == 0 &&
            value <= MAX_SAFE_INTEGER
          )
        }
        function isObject(value) {
          var type = typeof value
          return value != null && (type == 'object' || type == 'function')
        }
        function isObjectLike(value) {
          return value != null && typeof value == 'object'
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap
        function isMatch(object, source) {
          return (
            object === source ||
            baseIsMatch(object, source, getMatchData(source))
          )
        }
        function isMatchWith(object, source, customizer) {
          customizer =
            typeof customizer == 'function' ? customizer : undefined$1
          return baseIsMatch(object, source, getMatchData(source), customizer)
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT)
          }
          return baseIsNative(value)
        }
        function isNull(value) {
          return value === null
        }
        function isNil(value) {
          return value == null
        }
        function isNumber(value) {
          return (
            typeof value == 'number' ||
            (isObjectLike(value) && baseGetTag(value) == numberTag)
          )
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false
          }
          var proto = getPrototype(value)
          if (proto === null) {
            return true
          }
          var Ctor =
            hasOwnProperty.call(proto, 'constructor') && proto.constructor
          return (
            typeof Ctor == 'function' &&
            Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString
          )
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp
        function isSafeInteger(value) {
          return (
            isInteger(value) &&
            value >= -MAX_SAFE_INTEGER &&
            value <= MAX_SAFE_INTEGER
          )
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet
        function isString(value) {
          return (
            typeof value == 'string' ||
            (!isArray2(value) &&
              isObjectLike(value) &&
              baseGetTag(value) == stringTag)
          )
        }
        function isSymbol(value) {
          return (
            typeof value == 'symbol' ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag)
          )
        }
        var isTypedArray = nodeIsTypedArray
          ? baseUnary(nodeIsTypedArray)
          : baseIsTypedArray
        function isUndefined(value) {
          return value === undefined$1
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag
        }
        var lt = createRelationalOperation(baseLt)
        var lte = createRelationalOperation(function (value, other) {
          return value <= other
        })
        function toArray2(value) {
          if (!value) {
            return []
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value)
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]())
          }
          var tag = getTag(value),
            func =
              tag == mapTag ? mapToArray : tag == setTag ? setToArray : values
          return func(value)
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0
          }
          value = toNumber2(value)
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1
            return sign * MAX_INTEGER
          }
          return value === value ? value : 0
        }
        function toInteger(value) {
          var result2 = toFinite(value),
            remainder = result2 % 1
          return result2 === result2
            ? remainder
              ? result2 - remainder
              : result2
            : 0
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
        }
        function toNumber2(value) {
          if (typeof value == 'number') {
            return value
          }
          if (isSymbol(value)) {
            return NAN
          }
          if (isObject(value)) {
            var other =
              typeof value.valueOf == 'function' ? value.valueOf() : value
            value = isObject(other) ? other + '' : other
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value
          }
          value = baseTrim(value)
          var isBinary = reIsBinary.test(value)
          return isBinary || reIsOctal.test(value)
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : reIsBadHex.test(value)
            ? NAN
            : +value
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value))
        }
        function toSafeInteger(value) {
          return value
            ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
            : value === 0
            ? value
            : 0
        }
        function toString(value) {
          return value == null ? '' : baseToString(value)
        }
        var assign2 = createAssigner(function (object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object)
            return
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key])
            }
          }
        })
        var assignIn = createAssigner(function (object, source) {
          copyObject(source, keysIn(source), object)
        })
        var assignInWith = createAssigner(
          function (object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer)
          },
        )
        var assignWith = createAssigner(
          function (object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer)
          },
        )
        var at = flatRest(baseAt)
        function create(prototype, properties) {
          var result2 = baseCreate(prototype)
          return properties == null ? result2 : baseAssign(result2, properties)
        }
        var defaults = baseRest(function (object, sources) {
          object = Object2(object)
          var index = -1
          var length = sources.length
          var guard = length > 2 ? sources[2] : undefined$1
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1
          }
          while (++index < length) {
            var source = sources[index]
            var props = keysIn(source)
            var propsIndex = -1
            var propsLength = props.length
            while (++propsIndex < propsLength) {
              var key = props[propsIndex]
              var value = object[key]
              if (
                value === undefined$1 ||
                (eq(value, objectProto[key]) &&
                  !hasOwnProperty.call(object, key))
              ) {
                object[key] = source[key]
              }
            }
          }
          return object
        })
        var defaultsDeep = baseRest(function (args) {
          args.push(undefined$1, customDefaultsMerge)
          return apply(mergeWith, undefined$1, args)
        })
        function findKey2(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn)
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight)
        }
        function forIn(object, iteratee2) {
          return object == null
            ? object
            : baseFor(object, getIteratee(iteratee2, 3), keysIn)
        }
        function forInRight(object, iteratee2) {
          return object == null
            ? object
            : baseForRight(object, getIteratee(iteratee2, 3), keysIn)
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3))
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3))
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object))
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object))
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path)
          return result2 === undefined$1 ? defaultValue : result2
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas)
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn)
        }
        var invert = createInverter(function (result2, value, key) {
          if (value != null && typeof value.toString != 'function') {
            value = nativeObjectToString.call(value)
          }
          result2[value] = key
        }, constant(identity))
        var invertBy = createInverter(function (result2, value, key) {
          if (value != null && typeof value.toString != 'function') {
            value = nativeObjectToString.call(value)
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key)
          } else {
            result2[value] = [key]
          }
        }, getIteratee)
        var invoke = baseRest(baseInvoke)
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
        }
        function keysIn(object) {
          return isArrayLike(object)
            ? arrayLikeKeys(object, true)
            : baseKeysIn(object)
        }
        function mapKeys(object, iteratee2) {
          var result2 = {}
          iteratee2 = getIteratee(iteratee2, 3)
          baseForOwn(object, function (value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value)
          })
          return result2
        }
        function mapValues2(object, iteratee2) {
          var result2 = {}
          iteratee2 = getIteratee(iteratee2, 3)
          baseForOwn(object, function (value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2))
          })
          return result2
        }
        var merge = createAssigner(function (object, source, srcIndex) {
          baseMerge(object, source, srcIndex)
        })
        var mergeWith = createAssigner(
          function (object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer)
          },
        )
        var omit = flatRest(function (object, paths) {
          var result2 = {}
          if (object == null) {
            return result2
          }
          var isDeep = false
          paths = arrayMap(paths, function (path) {
            path = castPath(path, object)
            isDeep || (isDeep = path.length > 1)
            return path
          })
          copyObject(object, getAllKeysIn(object), result2)
          if (isDeep) {
            result2 = baseClone(
              result2,
              CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG,
              customOmitClone,
            )
          }
          var length = paths.length
          while (length--) {
            baseUnset(result2, paths[length])
          }
          return result2
        })
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)))
        }
        var pick = flatRest(function (object, paths) {
          return object == null ? {} : basePick(object, paths)
        })
        function pickBy(object, predicate) {
          if (object == null) {
            return {}
          }
          var props = arrayMap(getAllKeysIn(object), function (prop) {
            return [prop]
          })
          predicate = getIteratee(predicate)
          return basePickBy(object, props, function (value, path) {
            return predicate(value, path[0])
          })
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object)
          var index = -1,
            length = path.length
          if (!length) {
            length = 1
            object = undefined$1
          }
          while (++index < length) {
            var value =
              object == null ? undefined$1 : object[toKey(path[index])]
            if (value === undefined$1) {
              index = length
              value = defaultValue
            }
            object = isFunction(value) ? value.call(object) : value
          }
          return object
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value)
        }
        function setWith(object, path, value, customizer) {
          customizer =
            typeof customizer == 'function' ? customizer : undefined$1
          return object == null
            ? object
            : baseSet(object, path, value, customizer)
        }
        var toPairs = createToPairs(keys)
        var toPairsIn = createToPairs(keysIn)
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object),
            isArrLike = isArr || isBuffer(object) || isTypedArray(object)
          iteratee2 = getIteratee(iteratee2, 4)
          if (accumulator == null) {
            var Ctor = object && object.constructor
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : []
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor)
                ? baseCreate(getPrototype(object))
                : {}
            } else {
              accumulator = {}
            }
          }
          ;(isArrLike ? arrayEach : baseForOwn)(
            object,
            function (value, index, object2) {
              return iteratee2(accumulator, value, index, object2)
            },
          )
          return accumulator
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path)
        }
        function update(object, path, updater) {
          return object == null
            ? object
            : baseUpdate(object, path, castFunction(updater))
        }
        function updateWith(object, path, updater, customizer) {
          customizer =
            typeof customizer == 'function' ? customizer : undefined$1
          return object == null
            ? object
            : baseUpdate(object, path, castFunction(updater), customizer)
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object))
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object))
        }
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower
            lower = undefined$1
          }
          if (upper !== undefined$1) {
            upper = toNumber2(upper)
            upper = upper === upper ? upper : 0
          }
          if (lower !== undefined$1) {
            lower = toNumber2(lower)
            lower = lower === lower ? lower : 0
          }
          return baseClamp(toNumber2(number), lower, upper)
        }
        function inRange(number, start, end) {
          start = toFinite(start)
          if (end === undefined$1) {
            end = start
            start = 0
          } else {
            end = toFinite(end)
          }
          number = toNumber2(number)
          return baseInRange(number, start, end)
        }
        function random(lower, upper, floating) {
          if (
            floating &&
            typeof floating != 'boolean' &&
            isIterateeCall(lower, upper, floating)
          ) {
            upper = floating = undefined$1
          }
          if (floating === undefined$1) {
            if (typeof upper == 'boolean') {
              floating = upper
              upper = undefined$1
            } else if (typeof lower == 'boolean') {
              floating = lower
              lower = undefined$1
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0
            upper = 1
          } else {
            lower = toFinite(lower)
            if (upper === undefined$1) {
              upper = lower
              lower = 0
            } else {
              upper = toFinite(upper)
            }
          }
          if (lower > upper) {
            var temp = lower
            lower = upper
            upper = temp
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom()
            return nativeMin(
              lower +
                rand *
                  (upper -
                    lower +
                    freeParseFloat('1e-' + ((rand + '').length - 1))),
              upper,
            )
          }
          return baseRandom(lower, upper)
        }
        var camelCase = createCompounder(function (result2, word, index) {
          word = word.toLowerCase()
          return result2 + (index ? capitalize(word) : word)
        })
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase())
        }
        function deburr(string) {
          string = toString(string)
          return (
            string &&
            string.replace(reLatin, deburrLetter).replace(reComboMark, '')
          )
        }
        function endsWith(string, target, position) {
          string = toString(string)
          target = baseToString(target)
          var length = string.length
          position =
            position === undefined$1
              ? length
              : baseClamp(toInteger(position), 0, length)
          var end = position
          position -= target.length
          return position >= 0 && string.slice(position, end) == target
        }
        function escape(string) {
          string = toString(string)
          return string && reHasUnescapedHtml.test(string)
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string
        }
        function escapeRegExp(string) {
          string = toString(string)
          return string && reHasRegExpChar.test(string)
            ? string.replace(reRegExpChar, '\\$&')
            : string
        }
        var kebabCase2 = createCompounder(function (result2, word, index) {
          return result2 + (index ? '-' : '') + word.toLowerCase()
        })
        var lowerCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? ' ' : '') + word.toLowerCase()
        })
        var lowerFirst = createCaseFirst('toLowerCase')
        function pad(string, length, chars) {
          string = toString(string)
          length = toInteger(length)
          var strLength = length ? stringSize(string) : 0
          if (!length || strLength >= length) {
            return string
          }
          var mid = (length - strLength) / 2
          return (
            createPadding(nativeFloor(mid), chars) +
            string +
            createPadding(nativeCeil(mid), chars)
          )
        }
        function padEnd(string, length, chars) {
          string = toString(string)
          length = toInteger(length)
          var strLength = length ? stringSize(string) : 0
          return length && strLength < length
            ? string + createPadding(length - strLength, chars)
            : string
        }
        function padStart(string, length, chars) {
          string = toString(string)
          length = toInteger(length)
          var strLength = length ? stringSize(string) : 0
          return length && strLength < length
            ? createPadding(length - strLength, chars) + string
            : string
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0
          } else if (radix) {
            radix = +radix
          }
          return nativeParseInt(
            toString(string).replace(reTrimStart, ''),
            radix || 0,
          )
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
            n = 1
          } else {
            n = toInteger(n)
          }
          return baseRepeat(toString(string), n)
        }
        function replace() {
          var args = arguments,
            string = toString(args[0])
          return args.length < 3 ? string : string.replace(args[1], args[2])
        }
        var snakeCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? '_' : '') + word.toLowerCase()
        })
        function split(string, separator, limit) {
          if (
            limit &&
            typeof limit != 'number' &&
            isIterateeCall(string, separator, limit)
          ) {
            separator = limit = undefined$1
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0
          if (!limit) {
            return []
          }
          string = toString(string)
          if (
            string &&
            (typeof separator == 'string' ||
              (separator != null && !isRegExp(separator)))
          ) {
            separator = baseToString(separator)
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit)
            }
          }
          return string.split(separator, limit)
        }
        var startCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? ' ' : '') + upperFirst(word)
        })
        function startsWith(string, target, position) {
          string = toString(string)
          position =
            position == null
              ? 0
              : baseClamp(toInteger(position), 0, string.length)
          target = baseToString(target)
          return string.slice(position, position + target.length) == target
        }
        function template(string, options, guard) {
          var settings = lodash2.templateSettings
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1
          }
          string = toString(string)
          options = assignInWith({}, options, settings, customDefaultsAssignIn)
          var imports = assignInWith(
              {},
              options.imports,
              settings.imports,
              customDefaultsAssignIn,
            ),
            importsKeys = keys(imports),
            importsValues = baseValues(imports, importsKeys)
          var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '"
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source +
              '|' +
              interpolate.source +
              '|' +
              (interpolate === reInterpolate ? reEsTemplate : reNoMatch)
                .source +
              '|' +
              (options.evaluate || reNoMatch).source +
              '|$',
            'g',
          )
          var sourceURL =
            '//# sourceURL=' +
            (hasOwnProperty.call(options, 'sourceURL')
              ? (options.sourceURL + '').replace(/\s/g, ' ')
              : 'lodash.templateSources[' + ++templateCounter + ']') +
            '\n'
          string.replace(
            reDelimiters,
            function (
              match2,
              escapeValue,
              interpolateValue,
              esTemplateValue,
              evaluateValue,
              offset,
            ) {
              interpolateValue || (interpolateValue = esTemplateValue)
              source += string
                .slice(index, offset)
                .replace(reUnescapedString, escapeStringChar)
              if (escapeValue) {
                isEscaping = true
                source += "' +\n__e(" + escapeValue + ") +\n'"
              }
              if (evaluateValue) {
                isEvaluating = true
                source += "';\n" + evaluateValue + ";\n__p += '"
              }
              if (interpolateValue) {
                source +=
                  "' +\n((__t = (" +
                  interpolateValue +
                  ")) == null ? '' : __t) +\n'"
              }
              index = offset + match2.length
              return match2
            },
          )
          source += "';\n"
          var variable =
            hasOwnProperty.call(options, 'variable') && options.variable
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n'
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT)
          }
          source = (
            isEvaluating ? source.replace(reEmptyStringLeading, '') : source
          )
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;')
          source =
            'function(' +
            (variable || 'obj') +
            ') {\n' +
            (variable ? '' : 'obj || (obj = {});\n') +
            "var __t, __p = ''" +
            (isEscaping ? ', __e = _.escape' : '') +
            (isEvaluating
              ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n"
              : ';\n') +
            source +
            'return __p\n}'
          var result2 = attempt(function () {
            return Function2(importsKeys, sourceURL + 'return ' + source).apply(
              undefined$1,
              importsValues,
            )
          })
          result2.source = source
          if (isError(result2)) {
            throw result2
          }
          return result2
        }
        function toLower(value) {
          return toString(value).toLowerCase()
        }
        function toUpper(value) {
          return toString(value).toUpperCase()
        }
        function trim(string, chars, guard) {
          string = toString(string)
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string)
          }
          if (!string || !(chars = baseToString(chars))) {
            return string
          }
          var strSymbols = stringToArray(string),
            chrSymbols = stringToArray(chars),
            start = charsStartIndex(strSymbols, chrSymbols),
            end = charsEndIndex(strSymbols, chrSymbols) + 1
          return castSlice(strSymbols, start, end).join('')
        }
        function trimEnd(string, chars, guard) {
          string = toString(string)
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1)
          }
          if (!string || !(chars = baseToString(chars))) {
            return string
          }
          var strSymbols = stringToArray(string),
            end = charsEndIndex(strSymbols, stringToArray(chars)) + 1
          return castSlice(strSymbols, 0, end).join('')
        }
        function trimStart(string, chars, guard) {
          string = toString(string)
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, '')
          }
          if (!string || !(chars = baseToString(chars))) {
            return string
          }
          var strSymbols = stringToArray(string),
            start = charsStartIndex(strSymbols, stringToArray(chars))
          return castSlice(strSymbols, start).join('')
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
            omission = DEFAULT_TRUNC_OMISSION
          if (isObject(options)) {
            var separator =
              'separator' in options ? options.separator : separator
            length = 'length' in options ? toInteger(options.length) : length
            omission =
              'omission' in options ? baseToString(options.omission) : omission
          }
          string = toString(string)
          var strLength = string.length
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string)
            strLength = strSymbols.length
          }
          if (length >= strLength) {
            return string
          }
          var end = length - stringSize(omission)
          if (end < 1) {
            return omission
          }
          var result2 = strSymbols
            ? castSlice(strSymbols, 0, end).join('')
            : string.slice(0, end)
          if (separator === undefined$1) {
            return result2 + omission
          }
          if (strSymbols) {
            end += result2.length - end
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match2,
                substring = result2
              if (!separator.global) {
                separator = RegExp2(
                  separator.source,
                  toString(reFlags.exec(separator)) + 'g',
                )
              }
              separator.lastIndex = 0
              while ((match2 = separator.exec(substring))) {
                var newEnd = match2.index
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd)
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator)
            if (index > -1) {
              result2 = result2.slice(0, index)
            }
          }
          return result2 + omission
        }
        function unescape(string) {
          string = toString(string)
          return string && reHasEscapedHtml.test(string)
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string
        }
        var upperCase = createCompounder(function (result2, word, index) {
          return result2 + (index ? ' ' : '') + word.toUpperCase()
        })
        var upperFirst = createCaseFirst('toUpperCase')
        function words(string, pattern, guard) {
          string = toString(string)
          pattern = guard ? undefined$1 : pattern
          if (pattern === undefined$1) {
            return hasUnicodeWord(string)
              ? unicodeWords(string)
              : asciiWords(string)
          }
          return string.match(pattern) || []
        }
        var attempt = baseRest(function (func, args) {
          try {
            return apply(func, undefined$1, args)
          } catch (e) {
            return isError(e) ? e : new Error2(e)
          }
        })
        var bindAll = flatRest(function (object, methodNames) {
          arrayEach(methodNames, function (key) {
            key = toKey(key)
            baseAssignValue(object, key, bind(object[key], object))
          })
          return object
        })
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length,
            toIteratee = getIteratee()
          pairs = !length
            ? []
            : arrayMap(pairs, function (pair) {
                if (typeof pair[1] != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT)
                }
                return [toIteratee(pair[0]), pair[1]]
              })
          return baseRest(function (args) {
            var index = -1
            while (++index < length) {
              var pair = pairs[index]
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args)
              }
            }
          })
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG))
        }
        function constant(value) {
          return function () {
            return value
          }
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value
        }
        var flow = createFlow()
        var flowRight = createFlow(true)
        function identity(value) {
          return value
        }
        function iteratee(func) {
          return baseIteratee(
            typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG),
          )
        }
        function matches2(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG))
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG))
        }
        var method = baseRest(function (path, args) {
          return function (object) {
            return baseInvoke(object, path, args)
          }
        })
        var methodOf = baseRest(function (object, args) {
          return function (path) {
            return baseInvoke(object, path, args)
          }
        })
        function mixin(object, source, options) {
          var props = keys(source),
            methodNames = baseFunctions(source, props)
          if (
            options == null &&
            !(isObject(source) && (methodNames.length || !props.length))
          ) {
            options = source
            source = object
            object = this
            methodNames = baseFunctions(source, keys(source))
          }
          var chain2 =
              !(isObject(options) && 'chain' in options) || !!options.chain,
            isFunc = isFunction(object)
          arrayEach(methodNames, function (methodName) {
            var func = source[methodName]
            object[methodName] = func
            if (isFunc) {
              object.prototype[methodName] = function () {
                var chainAll = this.__chain__
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__),
                    actions = (result2.__actions__ = copyArray(
                      this.__actions__,
                    ))
                  actions.push({func: func, args: arguments, thisArg: object})
                  result2.__chain__ = chainAll
                  return result2
                }
                return func.apply(object, arrayPush([this.value()], arguments))
              }
            }
          })
          return object
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash
          }
          return this
        }
        function noop2() {}
        function nthArg(n) {
          n = toInteger(n)
          return baseRest(function (args) {
            return baseNth(args, n)
          })
        }
        var over = createOver(arrayMap)
        var overEvery = createOver(arrayEvery)
        var overSome = createOver(arraySome)
        function property(path) {
          return isKey(path)
            ? baseProperty(toKey(path))
            : basePropertyDeep(path)
        }
        function propertyOf(object) {
          return function (path) {
            return object == null ? undefined$1 : baseGet(object, path)
          }
        }
        var range = createRange()
        var rangeRight = createRange(true)
        function stubArray() {
          return []
        }
        function stubFalse() {
          return false
        }
        function stubObject() {
          return {}
        }
        function stubString() {
          return ''
        }
        function stubTrue() {
          return true
        }
        function times(n, iteratee2) {
          n = toInteger(n)
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return []
          }
          var index = MAX_ARRAY_LENGTH,
            length = nativeMin(n, MAX_ARRAY_LENGTH)
          iteratee2 = getIteratee(iteratee2)
          n -= MAX_ARRAY_LENGTH
          var result2 = baseTimes(length, iteratee2)
          while (++index < n) {
            iteratee2(index)
          }
          return result2
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey)
          }
          return isSymbol(value)
            ? [value]
            : copyArray(stringToPath(toString(value)))
        }
        function uniqueId(prefix) {
          var id = ++idCounter2
          return toString(prefix) + id
        }
        var add = createMathOperation(function (augend, addend) {
          return augend + addend
        }, 0)
        var ceil = createRound('ceil')
        var divide = createMathOperation(function (dividend, divisor) {
          return dividend / divisor
        }, 1)
        var floor = createRound('floor')
        function max(array) {
          return array && array.length
            ? baseExtremum(array, identity, baseGt)
            : undefined$1
        }
        function maxBy(array, iteratee2) {
          return array && array.length
            ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt)
            : undefined$1
        }
        function mean(array) {
          return baseMean(array, identity)
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2))
        }
        function min(array) {
          return array && array.length
            ? baseExtremum(array, identity, baseLt)
            : undefined$1
        }
        function minBy(array, iteratee2) {
          return array && array.length
            ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt)
            : undefined$1
        }
        var multiply = createMathOperation(function (multiplier, multiplicand) {
          return multiplier * multiplicand
        }, 1)
        var round = createRound('round')
        var subtract = createMathOperation(function (minuend, subtrahend) {
          return minuend - subtrahend
        }, 0)
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0
        }
        function sumBy(array, iteratee2) {
          return array && array.length
            ? baseSum(array, getIteratee(iteratee2, 2))
            : 0
        }
        lodash2.after = after
        lodash2.ary = ary
        lodash2.assign = assign2
        lodash2.assignIn = assignIn
        lodash2.assignInWith = assignInWith
        lodash2.assignWith = assignWith
        lodash2.at = at
        lodash2.before = before
        lodash2.bind = bind
        lodash2.bindAll = bindAll
        lodash2.bindKey = bindKey
        lodash2.castArray = castArray
        lodash2.chain = chain
        lodash2.chunk = chunk
        lodash2.compact = compact
        lodash2.concat = concat
        lodash2.cond = cond
        lodash2.conforms = conforms
        lodash2.constant = constant
        lodash2.countBy = countBy
        lodash2.create = create
        lodash2.curry = curry
        lodash2.curryRight = curryRight
        lodash2.debounce = debounce
        lodash2.defaults = defaults
        lodash2.defaultsDeep = defaultsDeep
        lodash2.defer = defer
        lodash2.delay = delay
        lodash2.difference = difference
        lodash2.differenceBy = differenceBy
        lodash2.differenceWith = differenceWith
        lodash2.drop = drop
        lodash2.dropRight = dropRight
        lodash2.dropRightWhile = dropRightWhile
        lodash2.dropWhile = dropWhile
        lodash2.fill = fill
        lodash2.filter = filter
        lodash2.flatMap = flatMap
        lodash2.flatMapDeep = flatMapDeep
        lodash2.flatMapDepth = flatMapDepth
        lodash2.flatten = flatten
        lodash2.flattenDeep = flattenDeep
        lodash2.flattenDepth = flattenDepth
        lodash2.flip = flip
        lodash2.flow = flow
        lodash2.flowRight = flowRight
        lodash2.fromPairs = fromPairs
        lodash2.functions = functions
        lodash2.functionsIn = functionsIn
        lodash2.groupBy = groupBy
        lodash2.initial = initial
        lodash2.intersection = intersection
        lodash2.intersectionBy = intersectionBy
        lodash2.intersectionWith = intersectionWith
        lodash2.invert = invert
        lodash2.invertBy = invertBy
        lodash2.invokeMap = invokeMap
        lodash2.iteratee = iteratee
        lodash2.keyBy = keyBy
        lodash2.keys = keys
        lodash2.keysIn = keysIn
        lodash2.map = map
        lodash2.mapKeys = mapKeys
        lodash2.mapValues = mapValues2
        lodash2.matches = matches2
        lodash2.matchesProperty = matchesProperty
        lodash2.memoize = memoize
        lodash2.merge = merge
        lodash2.mergeWith = mergeWith
        lodash2.method = method
        lodash2.methodOf = methodOf
        lodash2.mixin = mixin
        lodash2.negate = negate
        lodash2.nthArg = nthArg
        lodash2.omit = omit
        lodash2.omitBy = omitBy
        lodash2.once = once
        lodash2.orderBy = orderBy
        lodash2.over = over
        lodash2.overArgs = overArgs
        lodash2.overEvery = overEvery
        lodash2.overSome = overSome
        lodash2.partial = partial
        lodash2.partialRight = partialRight
        lodash2.partition = partition
        lodash2.pick = pick
        lodash2.pickBy = pickBy
        lodash2.property = property
        lodash2.propertyOf = propertyOf
        lodash2.pull = pull
        lodash2.pullAll = pullAll
        lodash2.pullAllBy = pullAllBy
        lodash2.pullAllWith = pullAllWith
        lodash2.pullAt = pullAt
        lodash2.range = range
        lodash2.rangeRight = rangeRight
        lodash2.rearg = rearg
        lodash2.reject = reject
        lodash2.remove = remove
        lodash2.rest = rest
        lodash2.reverse = reverse
        lodash2.sampleSize = sampleSize
        lodash2.set = set
        lodash2.setWith = setWith
        lodash2.shuffle = shuffle
        lodash2.slice = slice
        lodash2.sortBy = sortBy
        lodash2.sortedUniq = sortedUniq
        lodash2.sortedUniqBy = sortedUniqBy
        lodash2.split = split
        lodash2.spread = spread
        lodash2.tail = tail
        lodash2.take = take
        lodash2.takeRight = takeRight
        lodash2.takeRightWhile = takeRightWhile
        lodash2.takeWhile = takeWhile
        lodash2.tap = tap
        lodash2.throttle = throttle
        lodash2.thru = thru
        lodash2.toArray = toArray2
        lodash2.toPairs = toPairs
        lodash2.toPairsIn = toPairsIn
        lodash2.toPath = toPath
        lodash2.toPlainObject = toPlainObject
        lodash2.transform = transform
        lodash2.unary = unary
        lodash2.union = union
        lodash2.unionBy = unionBy
        lodash2.unionWith = unionWith
        lodash2.uniq = uniq
        lodash2.uniqBy = uniqBy
        lodash2.uniqWith = uniqWith
        lodash2.unset = unset
        lodash2.unzip = unzip
        lodash2.unzipWith = unzipWith
        lodash2.update = update
        lodash2.updateWith = updateWith
        lodash2.values = values
        lodash2.valuesIn = valuesIn
        lodash2.without = without
        lodash2.words = words
        lodash2.wrap = wrap
        lodash2.xor = xor
        lodash2.xorBy = xorBy
        lodash2.xorWith = xorWith
        lodash2.zip = zip
        lodash2.zipObject = zipObject
        lodash2.zipObjectDeep = zipObjectDeep
        lodash2.zipWith = zipWith
        lodash2.entries = toPairs
        lodash2.entriesIn = toPairsIn
        lodash2.extend = assignIn
        lodash2.extendWith = assignInWith
        mixin(lodash2, lodash2)
        lodash2.add = add
        lodash2.attempt = attempt
        lodash2.camelCase = camelCase
        lodash2.capitalize = capitalize
        lodash2.ceil = ceil
        lodash2.clamp = clamp
        lodash2.clone = clone
        lodash2.cloneDeep = cloneDeep
        lodash2.cloneDeepWith = cloneDeepWith
        lodash2.cloneWith = cloneWith
        lodash2.conformsTo = conformsTo
        lodash2.deburr = deburr
        lodash2.defaultTo = defaultTo
        lodash2.divide = divide
        lodash2.endsWith = endsWith
        lodash2.eq = eq
        lodash2.escape = escape
        lodash2.escapeRegExp = escapeRegExp
        lodash2.every = every
        lodash2.find = find
        lodash2.findIndex = findIndex2
        lodash2.findKey = findKey2
        lodash2.findLast = findLast
        lodash2.findLastIndex = findLastIndex
        lodash2.findLastKey = findLastKey
        lodash2.floor = floor
        lodash2.forEach = forEach
        lodash2.forEachRight = forEachRight
        lodash2.forIn = forIn
        lodash2.forInRight = forInRight
        lodash2.forOwn = forOwn
        lodash2.forOwnRight = forOwnRight
        lodash2.get = get
        lodash2.gt = gt
        lodash2.gte = gte
        lodash2.has = has
        lodash2.hasIn = hasIn
        lodash2.head = head
        lodash2.identity = identity
        lodash2.includes = includes
        lodash2.indexOf = indexOf
        lodash2.inRange = inRange
        lodash2.invoke = invoke
        lodash2.isArguments = isArguments
        lodash2.isArray = isArray2
        lodash2.isArrayBuffer = isArrayBuffer
        lodash2.isArrayLike = isArrayLike
        lodash2.isArrayLikeObject = isArrayLikeObject
        lodash2.isBoolean = isBoolean
        lodash2.isBuffer = isBuffer
        lodash2.isDate = isDate2
        lodash2.isElement = isElement
        lodash2.isEmpty = isEmpty
        lodash2.isEqual = isEqual
        lodash2.isEqualWith = isEqualWith
        lodash2.isError = isError
        lodash2.isFinite = isFinite2
        lodash2.isFunction = isFunction
        lodash2.isInteger = isInteger
        lodash2.isLength = isLength
        lodash2.isMap = isMap
        lodash2.isMatch = isMatch
        lodash2.isMatchWith = isMatchWith
        lodash2.isNaN = isNaN2
        lodash2.isNative = isNative
        lodash2.isNil = isNil
        lodash2.isNull = isNull
        lodash2.isNumber = isNumber
        lodash2.isObject = isObject
        lodash2.isObjectLike = isObjectLike
        lodash2.isPlainObject = isPlainObject2
        lodash2.isRegExp = isRegExp
        lodash2.isSafeInteger = isSafeInteger
        lodash2.isSet = isSet
        lodash2.isString = isString
        lodash2.isSymbol = isSymbol
        lodash2.isTypedArray = isTypedArray
        lodash2.isUndefined = isUndefined
        lodash2.isWeakMap = isWeakMap
        lodash2.isWeakSet = isWeakSet
        lodash2.join = join2
        lodash2.kebabCase = kebabCase2
        lodash2.last = last
        lodash2.lastIndexOf = lastIndexOf
        lodash2.lowerCase = lowerCase
        lodash2.lowerFirst = lowerFirst
        lodash2.lt = lt
        lodash2.lte = lte
        lodash2.max = max
        lodash2.maxBy = maxBy
        lodash2.mean = mean
        lodash2.meanBy = meanBy
        lodash2.min = min
        lodash2.minBy = minBy
        lodash2.stubArray = stubArray
        lodash2.stubFalse = stubFalse
        lodash2.stubObject = stubObject
        lodash2.stubString = stubString
        lodash2.stubTrue = stubTrue
        lodash2.multiply = multiply
        lodash2.nth = nth
        lodash2.noConflict = noConflict
        lodash2.noop = noop2
        lodash2.now = now
        lodash2.pad = pad
        lodash2.padEnd = padEnd
        lodash2.padStart = padStart
        lodash2.parseInt = parseInt2
        lodash2.random = random
        lodash2.reduce = reduce
        lodash2.reduceRight = reduceRight
        lodash2.repeat = repeat
        lodash2.replace = replace
        lodash2.result = result
        lodash2.round = round
        lodash2.runInContext = runInContext2
        lodash2.sample = sample
        lodash2.size = size
        lodash2.snakeCase = snakeCase
        lodash2.some = some
        lodash2.sortedIndex = sortedIndex
        lodash2.sortedIndexBy = sortedIndexBy
        lodash2.sortedIndexOf = sortedIndexOf
        lodash2.sortedLastIndex = sortedLastIndex
        lodash2.sortedLastIndexBy = sortedLastIndexBy
        lodash2.sortedLastIndexOf = sortedLastIndexOf
        lodash2.startCase = startCase
        lodash2.startsWith = startsWith
        lodash2.subtract = subtract
        lodash2.sum = sum
        lodash2.sumBy = sumBy
        lodash2.template = template
        lodash2.times = times
        lodash2.toFinite = toFinite
        lodash2.toInteger = toInteger
        lodash2.toLength = toLength
        lodash2.toLower = toLower
        lodash2.toNumber = toNumber2
        lodash2.toSafeInteger = toSafeInteger
        lodash2.toString = toString
        lodash2.toUpper = toUpper
        lodash2.trim = trim
        lodash2.trimEnd = trimEnd
        lodash2.trimStart = trimStart
        lodash2.truncate = truncate
        lodash2.unescape = unescape
        lodash2.uniqueId = uniqueId
        lodash2.upperCase = upperCase
        lodash2.upperFirst = upperFirst
        lodash2.each = forEach
        lodash2.eachRight = forEachRight
        lodash2.first = head
        mixin(
          lodash2,
          (function () {
            var source = {}
            baseForOwn(lodash2, function (func, methodName) {
              if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
                source[methodName] = func
              }
            })
            return source
          })(),
          {chain: false},
        )
        lodash2.VERSION = VERSION2
        arrayEach(
          ['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'],
          function (methodName) {
            lodash2[methodName].placeholder = lodash2
          },
        )
        arrayEach(['drop', 'take'], function (methodName, index) {
          LazyWrapper.prototype[methodName] = function (n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0)
            var result2 =
              this.__filtered__ && !index ? new LazyWrapper(this) : this.clone()
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__)
            } else {
              result2.__views__.push({
                size: nativeMin(n, MAX_ARRAY_LENGTH),
                type: methodName + (result2.__dir__ < 0 ? 'Right' : ''),
              })
            }
            return result2
          }
          LazyWrapper.prototype[methodName + 'Right'] = function (n) {
            return this.reverse()[methodName](n).reverse()
          }
        })
        arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
          var type = index + 1,
            isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG
          LazyWrapper.prototype[methodName] = function (iteratee2) {
            var result2 = this.clone()
            result2.__iteratees__.push({
              iteratee: getIteratee(iteratee2, 3),
              type: type,
            })
            result2.__filtered__ = result2.__filtered__ || isFilter
            return result2
          }
        })
        arrayEach(['head', 'last'], function (methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '')
          LazyWrapper.prototype[methodName] = function () {
            return this[takeName](1).value()[0]
          }
        })
        arrayEach(['initial', 'tail'], function (methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right')
          LazyWrapper.prototype[methodName] = function () {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
          }
        })
        LazyWrapper.prototype.compact = function () {
          return this.filter(identity)
        }
        LazyWrapper.prototype.find = function (predicate) {
          return this.filter(predicate).head()
        }
        LazyWrapper.prototype.findLast = function (predicate) {
          return this.reverse().find(predicate)
        }
        LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
          if (typeof path == 'function') {
            return new LazyWrapper(this)
          }
          return this.map(function (value) {
            return baseInvoke(value, path, args)
          })
        })
        LazyWrapper.prototype.reject = function (predicate) {
          return this.filter(negate(getIteratee(predicate)))
        }
        LazyWrapper.prototype.slice = function (start, end) {
          start = toInteger(start)
          var result2 = this
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2)
          }
          if (start < 0) {
            result2 = result2.takeRight(-start)
          } else if (start) {
            result2 = result2.drop(start)
          }
          if (end !== undefined$1) {
            end = toInteger(end)
            result2 =
              end < 0 ? result2.dropRight(-end) : result2.take(end - start)
          }
          return result2
        }
        LazyWrapper.prototype.takeRightWhile = function (predicate) {
          return this.reverse().takeWhile(predicate).reverse()
        }
        LazyWrapper.prototype.toArray = function () {
          return this.take(MAX_ARRAY_LENGTH)
        }
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(
              methodName,
            ),
            isTaker = /^(?:head|last)$/.test(methodName),
            lodashFunc =
              lodash2[
                isTaker
                  ? 'take' + (methodName == 'last' ? 'Right' : '')
                  : methodName
              ],
            retUnwrapped = isTaker || /^find/.test(methodName)
          if (!lodashFunc) {
            return
          }
          lodash2.prototype[methodName] = function () {
            var value = this.__wrapped__,
              args = isTaker ? [1] : arguments,
              isLazy = value instanceof LazyWrapper,
              iteratee2 = args[0],
              useLazy = isLazy || isArray2(value)
            var interceptor = function (value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args))
              return isTaker && chainAll ? result3[0] : result3
            }
            if (
              useLazy &&
              checkIteratee &&
              typeof iteratee2 == 'function' &&
              iteratee2.length != 1
            ) {
              isLazy = useLazy = false
            }
            var chainAll = this.__chain__,
              isHybrid = !!this.__actions__.length,
              isUnwrapped = retUnwrapped && !chainAll,
              onlyLazy = isLazy && !isHybrid
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this)
              var result2 = func.apply(value, args)
              result2.__actions__.push({
                func: thru,
                args: [interceptor],
                thisArg: undefined$1,
              })
              return new LodashWrapper(result2, chainAll)
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args)
            }
            result2 = this.thru(interceptor)
            return isUnwrapped
              ? isTaker
                ? result2.value()[0]
                : result2.value()
              : result2
          }
        })
        arrayEach(
          ['pop', 'push', 'shift', 'sort', 'splice', 'unshift'],
          function (methodName) {
            var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName)
                ? 'tap'
                : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName)
            lodash2.prototype[methodName] = function () {
              var args = arguments
              if (retUnwrapped && !this.__chain__) {
                var value = this.value()
                return func.apply(isArray2(value) ? value : [], args)
              }
              return this[chainName](function (value2) {
                return func.apply(isArray2(value2) ? value2 : [], args)
              })
            }
          },
        )
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var lodashFunc = lodash2[methodName]
          if (lodashFunc) {
            var key = lodashFunc.name + ''
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = []
            }
            realNames[key].push({name: methodName, func: lodashFunc})
          }
        })
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [
          {
            name: 'wrapper',
            func: undefined$1,
          },
        ]
        LazyWrapper.prototype.clone = lazyClone
        LazyWrapper.prototype.reverse = lazyReverse
        LazyWrapper.prototype.value = lazyValue
        lodash2.prototype.at = wrapperAt
        lodash2.prototype.chain = wrapperChain
        lodash2.prototype.commit = wrapperCommit
        lodash2.prototype.next = wrapperNext
        lodash2.prototype.plant = wrapperPlant
        lodash2.prototype.reverse = wrapperReverse
        lodash2.prototype.toJSON =
          lodash2.prototype.valueOf =
          lodash2.prototype.value =
            wrapperValue
        lodash2.prototype.first = lodash2.prototype.head
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator
        }
        return lodash2
      }
      var _ = runInContext()
      if (freeModule) {
        ;(freeModule.exports = _)._ = _
        freeExports._ = _
      } else {
        root._ = _
      }
    }).call(lodash)
  })(lodash$1, lodash$1.exports)
  return lodash$1.exports
}
requireLodash()
function createWebHMUrl(
  uid,
  {version, blockRef, blockRange, hostname, latest, path, originHomeId} = {},
) {
  let webPath = `/hm/${uid}`
  if (originHomeId?.uid === uid) {
    webPath = ''
  }
  const urlHost =
    hostname === void 0
      ? DEFAULT_GATEWAY_URL
      : hostname === null
      ? ''
      : hostname
  let res = `${urlHost}${webPath}`
  if (path && path.length) {
    res += `/${path.join('/')}`
  }
  if (res === '') res = '/'
  res += getHMQueryString({latest, version})
  if (blockRef) {
    res += `#${blockRef}${serializeBlockRange(blockRange)}`
  }
  return res
}
function getHMQueryString({version, latest}) {
  const query = {}
  if (version) {
    query.v = version
  }
  if (latest) {
    query.l = null
  }
  return serializeQueryString(query)
}
function packBaseId(uid, path) {
  const filteredPath = path?.filter((p) => p !== '') || []
  const restPath = filteredPath.length ? `/${filteredPath.join('/')}` : ''
  return `${HYPERMEDIA_SCHEME}://${uid}${restPath}`
}
function parseCustomURL(url) {
  if (!url) return null
  const [scheme, rest] = url.split('://')
  if (!rest) return null
  const [pathAndQuery, fragment = null] = rest.split('#')
  const [path, queryString] = pathAndQuery?.split('?') || []
  const query = new URLSearchParams(queryString)
  const queryObject = Object.fromEntries(query.entries())
  return {
    scheme: scheme || null,
    path: path?.split('/') || [],
    query: queryObject,
    fragment,
  }
}
function hmId(idPath, opts = {}) {
  const [uid, ...path] = (idPath || '').split('/')
  const effectivePath = opts.path || path || null
  return {
    ...opts,
    uid: uid || '',
    id: uid ? packBaseId(uid, effectivePath) : '',
    path: effectivePath,
    version: opts.version || null,
    blockRef: opts.blockRef || null,
    blockRange: opts.blockRange || null,
    hostname: opts.hostname || null,
    scheme: null,
  }
}
function unpackHmId(hypermediaId) {
  if (!hypermediaId) return null
  const parsed = parseCustomURL(hypermediaId)
  if (!parsed) return null
  let uid
  let path
  let hostname = null
  if (parsed.scheme === 'https' || parsed.scheme === 'http') {
    if (parsed.path[1] !== 'hm') return null
    hostname = parsed.path[0]
    uid = parsed.path[2]
    path = parsed.path.slice(3)
  } else if (parsed.scheme === HYPERMEDIA_SCHEME) {
    uid = parsed.path[0]
    path = parsed.path.slice(1)
  } else {
    return null
  }
  const version = parsed.query.v || null
  const latest = parsed.query.l === null || parsed.query.l === '' || !version
  const fragment = parseFragment(parsed.fragment)
  let blockRange = null
  if (fragment) {
    if ('start' in fragment) {
      blockRange = {
        start: fragment.start,
        end: fragment.end,
      }
    } else if ('expanded' in fragment) {
      blockRange = {
        expanded: fragment.expanded,
      }
    }
  }
  return {
    id: packBaseId(uid || '', path),
    uid: uid || '',
    path: path || null,
    version,
    blockRef: fragment ? fragment.blockId : null,
    blockRange,
    hostname: hostname || null,
    latest,
    scheme: parsed.scheme,
  }
}
function serializeQueryString(query) {
  const queryString = Object.entries(query)
    .map(([key, value]) => (value === null ? key : `${key}=${value}`))
    .join('&')
  if (!queryString) return ''
  return `?${queryString}`
}
function parseFragment(input) {
  if (!input) return null
  const regex = /^(\S{8})((\+)|\[(\d+)\:(\d+)\])?$/
  const match2 = input.match(regex)
  if (match2) {
    const blockId = match2[1] || ''
    const expanded = match2[3]
    const rangeStart = match2[4]
    const rangeEnd = match2[5]
    if (expanded === '+') {
      return {
        type: 'block',
        blockId,
        expanded: true,
      }
    } else if (
      typeof rangeStart !== 'undefined' &&
      typeof rangeEnd !== 'undefined'
    ) {
      return {
        type: 'block-range',
        blockId,
        start: parseInt(rangeStart),
        end: parseInt(rangeEnd),
      }
    } else {
      return {
        type: 'block',
        blockId,
        expanded: false,
      }
    }
  } else {
    return {
      type: 'block',
      blockId: input,
      expanded: false,
    }
  }
}
function serializeBlockRange(range) {
  let res = ''
  if (range) {
    if ('expanded' in range && range.expanded) {
      res += '+'
    } else if ('start' in range) {
      res += `[${range.start}:${range.end}]`
    }
  }
  return res
}
function hmIdPathToEntityQueryPath(path) {
  const filteredPath = path?.filter((term) => !!term)
  return filteredPath?.length ? `/${filteredPath.join('/')}` : ''
}
function entityQueryPathToHmIdPath(path) {
  if (!path) return []
  if (path === '/') return []
  return path.split('/').filter(Boolean)
}
function createGRPCClient(transport2) {
  return {
    activityFeed: createPromiseClient(ActivityFeed, transport2),
    daemon: createPromiseClient(Daemon, transport2),
    comments: createPromiseClient(Comments, transport2),
    documents: createPromiseClient(Documents, transport2),
    entities: createPromiseClient(Entities, transport2),
    networking: createPromiseClient(Networking, transport2),
    accessControl: createPromiseClient(AccessControl, transport2),
    subscriptions: createPromiseClient(Subscriptions, transport2),
    wallets: createPromiseClient(Wallets, transport2),
    invoices: createPromiseClient(Invoices, transport2),
    resources: createPromiseClient(Resources, transport2),
  }
}
class Subscribable {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set()
    this.subscribe = this.subscribe.bind(this)
  }
  subscribe(listener) {
    const identity = {
      listener,
    }
    this.listeners.add(identity)
    this.onSubscribe()
    return () => {
      this.listeners.delete(identity)
      this.onUnsubscribe()
    }
  }
  hasListeners() {
    return this.listeners.size > 0
  }
  onSubscribe() {}
  onUnsubscribe() {}
}
const isServer = typeof window === 'undefined' || 'Deno' in window
function noop() {
  return void 0
}
function functionalUpdate(updater, input) {
  return typeof updater === 'function' ? updater(input) : updater
}
function isValidTimeout(value) {
  return typeof value === 'number' && value >= 0 && value !== Infinity
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1
  }
  if (typeof arg2 === 'function') {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2,
    }
  }
  return {
    ...arg2,
    queryKey: arg1,
  }
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey(arg1)
    ? [
        {
          ...arg2,
          queryKey: arg1,
        },
        arg3,
      ]
    : [arg1 || {}, arg2]
}
function matchQuery(filters, query) {
  const {type = 'all', exact, fetchStatus, predicate, queryKey, stale} = filters
  if (isQueryKey(queryKey)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false
    }
  }
  if (type !== 'all') {
    const isActive = query.isActive()
    if (type === 'active' && !isActive) {
      return false
    }
    if (type === 'inactive' && isActive) {
      return false
    }
  }
  if (typeof stale === 'boolean' && query.isStale() !== stale) {
    return false
  }
  if (
    typeof fetchStatus !== 'undefined' &&
    fetchStatus !== query.state.fetchStatus
  ) {
    return false
  }
  if (predicate && !predicate(query)) {
    return false
  }
  return true
}
function matchMutation(filters, mutation) {
  const {exact, fetching, predicate, mutationKey} = filters
  if (isQueryKey(mutationKey)) {
    if (!mutation.options.mutationKey) {
      return false
    }
    if (exact) {
      if (
        hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)
      ) {
        return false
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false
    }
  }
  if (
    typeof fetching === 'boolean' &&
    (mutation.state.status === 'loading') !== fetching
  ) {
    return false
  }
  if (predicate && !predicate(mutation)) {
    return false
  }
  return true
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn =
    (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey
  return hashFn(queryKey)
}
function hashQueryKey(queryKey) {
  return JSON.stringify(queryKey, (_, val) =>
    isPlainObject(val)
      ? Object.keys(val)
          .sort()
          .reduce((result, key) => {
            result[key] = val[key]
            return result
          }, {})
      : val,
  )
}
function partialMatchKey(a, b) {
  return partialDeepEqual(a, b)
}
function partialDeepEqual(a, b) {
  if (a === b) {
    return true
  }
  if (typeof a !== typeof b) {
    return false
  }
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))
  }
  return false
}
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a
  }
  const array = isPlainArray(a) && isPlainArray(b)
  if (array || (isPlainObject(a) && isPlainObject(b))) {
    const aSize = array ? a.length : Object.keys(a).length
    const bItems = array ? b : Object.keys(b)
    const bSize = bItems.length
    const copy = array ? [] : {}
    let equalItems = 0
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i]
      copy[key] = replaceEqualDeep(a[key], b[key])
      if (copy[key] === a[key]) {
        equalItems++
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy
  }
  return b
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false
  }
  const ctor = o.constructor
  if (typeof ctor === 'undefined') {
    return true
  }
  const prot = ctor.prototype
  if (!hasObjectPrototype(prot)) {
    return false
  }
  if (!prot.hasOwnProperty('isPrototypeOf')) {
    return false
  }
  return true
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === '[object Object]'
}
function isQueryKey(value) {
  return Array.isArray(value)
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout)
  })
}
function scheduleMicrotask(callback) {
  sleep(0).then(callback)
}
function getAbortController() {
  if (typeof AbortController === 'function') {
    return new AbortController()
  }
  return
}
function replaceData(prevData, data, options) {
  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
    return prevData
  } else if (typeof options.structuralSharing === 'function') {
    return options.structuralSharing(prevData, data)
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data)
  }
  return data
}
class FocusManager extends Subscribable {
  constructor() {
    super()
    this.setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus()
        window.addEventListener('visibilitychange', listener, false)
        window.addEventListener('focus', listener, false)
        return () => {
          window.removeEventListener('visibilitychange', listener)
          window.removeEventListener('focus', listener)
        }
      }
      return
    }
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup)
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup
      ;(_this$cleanup = this.cleanup) == null
        ? void 0
        : _this$cleanup.call(this)
      this.cleanup = void 0
    }
  }
  setEventListener(setup2) {
    var _this$cleanup2
    this.setup = setup2
    ;(_this$cleanup2 = this.cleanup) == null
      ? void 0
      : _this$cleanup2.call(this)
    this.cleanup = setup2((focused) => {
      if (typeof focused === 'boolean') {
        this.setFocused(focused)
      } else {
        this.onFocus()
      }
    })
  }
  setFocused(focused) {
    const changed = this.focused !== focused
    if (changed) {
      this.focused = focused
      this.onFocus()
    }
  }
  onFocus() {
    this.listeners.forEach(({listener}) => {
      listener()
    })
  }
  isFocused() {
    if (typeof this.focused === 'boolean') {
      return this.focused
    }
    if (typeof document === 'undefined') {
      return true
    }
    return [void 0, 'visible', 'prerender'].includes(document.visibilityState)
  }
}
const focusManager = new FocusManager()
const onlineEvents = ['online', 'offline']
class OnlineManager extends Subscribable {
  constructor() {
    super()
    this.setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onOnline()
        onlineEvents.forEach((event) => {
          window.addEventListener(event, listener, false)
        })
        return () => {
          onlineEvents.forEach((event) => {
            window.removeEventListener(event, listener)
          })
        }
      }
      return
    }
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup)
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup
      ;(_this$cleanup = this.cleanup) == null
        ? void 0
        : _this$cleanup.call(this)
      this.cleanup = void 0
    }
  }
  setEventListener(setup2) {
    var _this$cleanup2
    this.setup = setup2
    ;(_this$cleanup2 = this.cleanup) == null
      ? void 0
      : _this$cleanup2.call(this)
    this.cleanup = setup2((online) => {
      if (typeof online === 'boolean') {
        this.setOnline(online)
      } else {
        this.onOnline()
      }
    })
  }
  setOnline(online) {
    const changed = this.online !== online
    if (changed) {
      this.online = online
      this.onOnline()
    }
  }
  onOnline() {
    this.listeners.forEach(({listener}) => {
      listener()
    })
  }
  isOnline() {
    if (typeof this.online === 'boolean') {
      return this.online
    }
    if (
      typeof navigator === 'undefined' ||
      typeof navigator.onLine === 'undefined'
    ) {
      return true
    }
    return navigator.onLine
  }
}
const onlineManager = new OnlineManager()
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4)
}
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : 'online') === 'online'
    ? onlineManager.isOnline()
    : true
}
class CancelledError {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert
    this.silent = options == null ? void 0 : options.silent
  }
}
function isCancelledError(value) {
  return value instanceof CancelledError
}
function createRetryer(config) {
  let isRetryCancelled = false
  let failureCount = 0
  let isResolved = false
  let continueFn
  let promiseResolve
  let promiseReject
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve
    promiseReject = outerReject
  })
  const cancel2 = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions))
      config.abort == null ? void 0 : config.abort()
    }
  }
  const cancelRetry = () => {
    isRetryCancelled = true
  }
  const continueRetry = () => {
    isRetryCancelled = false
  }
  const shouldPause = () =>
    !focusManager.isFocused() ||
    (config.networkMode !== 'always' && !onlineManager.isOnline())
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true
      config.onSuccess == null ? void 0 : config.onSuccess(value)
      continueFn == null ? void 0 : continueFn()
      promiseResolve(value)
    }
  }
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true
      config.onError == null ? void 0 : config.onError(value)
      continueFn == null ? void 0 : continueFn()
      promiseReject(value)
    }
  }
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        const canContinue = isResolved || !shouldPause()
        if (canContinue) {
          continueResolve(value)
        }
        return canContinue
      }
      config.onPause == null ? void 0 : config.onPause()
    }).then(() => {
      continueFn = void 0
      if (!isResolved) {
        config.onContinue == null ? void 0 : config.onContinue()
      }
    })
  }
  const run = () => {
    if (isResolved) {
      return
    }
    let promiseOrValue
    try {
      promiseOrValue = config.fn()
    } catch (error) {
      promiseOrValue = Promise.reject(error)
    }
    Promise.resolve(promiseOrValue)
      .then(resolve)
      .catch((error) => {
        var _config$retry, _config$retryDelay
        if (isResolved) {
          return
        }
        const retry = (_config$retry = config.retry) != null ? _config$retry : 3
        const retryDelay =
          (_config$retryDelay = config.retryDelay) != null
            ? _config$retryDelay
            : defaultRetryDelay
        const delay =
          typeof retryDelay === 'function'
            ? retryDelay(failureCount, error)
            : retryDelay
        const shouldRetry =
          retry === true ||
          (typeof retry === 'number' && failureCount < retry) ||
          (typeof retry === 'function' && retry(failureCount, error))
        if (isRetryCancelled || !shouldRetry) {
          reject(error)
          return
        }
        failureCount++
        config.onFail == null ? void 0 : config.onFail(failureCount, error)
        sleep(delay)
          .then(() => {
            if (shouldPause()) {
              return pause()
            }
            return
          })
          .then(() => {
            if (isRetryCancelled) {
              reject(error)
            } else {
              run()
            }
          })
      })
  }
  if (canFetch(config.networkMode)) {
    run()
  } else {
    pause().then(run)
  }
  return {
    promise,
    cancel: cancel2,
    continue: () => {
      const didContinue = continueFn == null ? void 0 : continueFn()
      return didContinue ? promise : Promise.resolve()
    },
    cancelRetry,
    continueRetry,
  }
}
const defaultLogger = console
function createNotifyManager() {
  let queue = []
  let transactions = 0
  let notifyFn = (callback) => {
    callback()
  }
  let batchNotifyFn = (callback) => {
    callback()
  }
  const batch = (callback) => {
    let result
    transactions++
    try {
      result = callback()
    } finally {
      transactions--
      if (!transactions) {
        flush()
      }
    }
    return result
  }
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback)
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback)
      })
    }
  }
  const batchCalls = (callback) => {
    return (...args) => {
      schedule(() => {
        callback(...args)
      })
    }
  }
  const flush = () => {
    const originalQueue = queue
    queue = []
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback)
          })
        })
      })
    }
  }
  const setNotifyFunction = (fn) => {
    notifyFn = fn
  }
  const setBatchNotifyFunction = (fn) => {
    batchNotifyFn = fn
  }
  return {
    batch,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction,
  }
}
const notifyManager = createNotifyManager()
class Removable {
  destroy() {
    this.clearGcTimeout()
  }
  scheduleGc() {
    this.clearGcTimeout()
    if (isValidTimeout(this.cacheTime)) {
      this.gcTimeout = setTimeout(() => {
        this.optionalRemove()
      }, this.cacheTime)
    }
  }
  updateCacheTime(newCacheTime) {
    this.cacheTime = Math.max(
      this.cacheTime || 0,
      newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3,
    )
  }
  clearGcTimeout() {
    if (this.gcTimeout) {
      clearTimeout(this.gcTimeout)
      this.gcTimeout = void 0
    }
  }
}
class Query extends Removable {
  constructor(config) {
    super()
    this.abortSignalConsumed = false
    this.defaultOptions = config.defaultOptions
    this.setOptions(config.options)
    this.observers = []
    this.cache = config.cache
    this.logger = config.logger || defaultLogger
    this.queryKey = config.queryKey
    this.queryHash = config.queryHash
    this.initialState = config.state || getDefaultState$1(this.options)
    this.state = this.initialState
    this.scheduleGc()
  }
  get meta() {
    return this.options.meta
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options,
    }
    this.updateCacheTime(this.options.cacheTime)
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === 'idle') {
      this.cache.remove(this)
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options)
    this.dispatch({
      data,
      type: 'success',
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual,
    })
    return data
  }
  setState(state, setStateOptions) {
    this.dispatch({
      type: 'setState',
      state,
      setStateOptions,
    })
  }
  cancel(options) {
    var _this$retryer
    const promise = this.promise
    ;(_this$retryer = this.retryer) == null
      ? void 0
      : _this$retryer.cancel(options)
    return promise ? promise.then(noop).catch(noop) : Promise.resolve()
  }
  destroy() {
    super.destroy()
    this.cancel({
      silent: true,
    })
  }
  reset() {
    this.destroy()
    this.setState(this.initialState)
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false)
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive()
  }
  isStale() {
    return (
      this.state.isInvalidated ||
      !this.state.dataUpdatedAt ||
      this.observers.some((observer) => observer.getCurrentResult().isStale)
    )
  }
  isStaleByTime(staleTime = 0) {
    return (
      this.state.isInvalidated ||
      !this.state.dataUpdatedAt ||
      !timeUntilStale(this.state.dataUpdatedAt, staleTime)
    )
  }
  onFocus() {
    var _this$retryer2
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())
    if (observer) {
      observer.refetch({
        cancelRefetch: false,
      })
    }
    ;(_this$retryer2 = this.retryer) == null
      ? void 0
      : _this$retryer2.continue()
  }
  onOnline() {
    var _this$retryer3
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())
    if (observer) {
      observer.refetch({
        cancelRefetch: false,
      })
    }
    ;(_this$retryer3 = this.retryer) == null
      ? void 0
      : _this$retryer3.continue()
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer)
      this.clearGcTimeout()
      this.cache.notify({
        type: 'observerAdded',
        query: this,
        observer,
      })
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer)
      if (!this.observers.length) {
        if (this.retryer) {
          if (this.abortSignalConsumed) {
            this.retryer.cancel({
              revert: true,
            })
          } else {
            this.retryer.cancelRetry()
          }
        }
        this.scheduleGc()
      }
      this.cache.notify({
        type: 'observerRemoved',
        query: this,
        observer,
      })
    }
  }
  getObserversCount() {
    return this.observers.length
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.dispatch({
        type: 'invalidate',
      })
    }
  }
  fetch(options, fetchOptions) {
    var _this$options$behavio, _context$fetchOptions
    if (this.state.fetchStatus !== 'idle') {
      if (
        this.state.dataUpdatedAt &&
        fetchOptions != null &&
        fetchOptions.cancelRefetch
      ) {
        this.cancel({
          silent: true,
        })
      } else if (this.promise) {
        var _this$retryer4
        ;(_this$retryer4 = this.retryer) == null
          ? void 0
          : _this$retryer4.continueRetry()
        return this.promise
      }
    }
    if (options) {
      this.setOptions(options)
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn)
      if (observer) {
        this.setOptions(observer.options)
      }
    }
    if (process.env.NODE_ENV !== 'production') {
      if (!Array.isArray(this.options.queryKey)) {
        this.logger.error(
          "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']",
        )
      }
    }
    const abortController = getAbortController()
    const queryFnContext = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta,
    }
    const addSignalProperty = (object) => {
      Object.defineProperty(object, 'signal', {
        enumerable: true,
        get: () => {
          if (abortController) {
            this.abortSignalConsumed = true
            return abortController.signal
          }
          return void 0
        },
      })
    }
    addSignalProperty(queryFnContext)
    const fetchFn = () => {
      if (!this.options.queryFn) {
        return Promise.reject(
          "Missing queryFn for queryKey '" + this.options.queryHash + "'",
        )
      }
      this.abortSignalConsumed = false
      return this.options.queryFn(queryFnContext)
    }
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn,
    }
    addSignalProperty(context)
    ;(_this$options$behavio = this.options.behavior) == null
      ? void 0
      : _this$options$behavio.onFetch(context)
    this.revertState = this.state
    if (
      this.state.fetchStatus === 'idle' ||
      this.state.fetchMeta !==
        ((_context$fetchOptions = context.fetchOptions) == null
          ? void 0
          : _context$fetchOptions.meta)
    ) {
      var _context$fetchOptions2
      this.dispatch({
        type: 'fetch',
        meta:
          (_context$fetchOptions2 = context.fetchOptions) == null
            ? void 0
            : _context$fetchOptions2.meta,
      })
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.dispatch({
          type: 'error',
          error,
        })
      }
      if (!isCancelledError(error)) {
        var _this$cache$config$on,
          _this$cache$config,
          _this$cache$config$on2,
          _this$cache$config2
        ;(_this$cache$config$on = (_this$cache$config = this.cache.config)
          .onError) == null
          ? void 0
          : _this$cache$config$on.call(_this$cache$config, error, this)
        ;(_this$cache$config$on2 = (_this$cache$config2 = this.cache.config)
          .onSettled) == null
          ? void 0
          : _this$cache$config$on2.call(
              _this$cache$config2,
              this.state.data,
              error,
              this,
            )
        if (process.env.NODE_ENV !== 'production') {
          this.logger.error(error)
        }
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc()
      }
      this.isFetchingOptimistic = false
    }
    this.retryer = createRetryer({
      fn: context.fetchFn,
      abort:
        abortController == null
          ? void 0
          : abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _this$cache$config$on3,
          _this$cache$config3,
          _this$cache$config$on4,
          _this$cache$config4
        if (typeof data === 'undefined') {
          if (process.env.NODE_ENV !== 'production') {
            this.logger.error(
              'Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ' +
                this.queryHash,
            )
          }
          onError(new Error(this.queryHash + ' data is undefined'))
          return
        }
        this.setData(data)
        ;(_this$cache$config$on3 = (_this$cache$config3 = this.cache.config)
          .onSuccess) == null
          ? void 0
          : _this$cache$config$on3.call(_this$cache$config3, data, this)
        ;(_this$cache$config$on4 = (_this$cache$config4 = this.cache.config)
          .onSettled) == null
          ? void 0
          : _this$cache$config$on4.call(
              _this$cache$config4,
              data,
              this.state.error,
              this,
            )
        if (!this.isFetchingOptimistic) {
          this.scheduleGc()
        }
        this.isFetchingOptimistic = false
      },
      onError,
      onFail: (failureCount, error) => {
        this.dispatch({
          type: 'failed',
          failureCount,
          error,
        })
      },
      onPause: () => {
        this.dispatch({
          type: 'pause',
        })
      },
      onContinue: () => {
        this.dispatch({
          type: 'continue',
        })
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
    })
    this.promise = this.retryer.promise
    return this.promise
  }
  dispatch(action) {
    const reducer = (state) => {
      var _action$meta, _action$dataUpdatedAt
      switch (action.type) {
        case 'failed':
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error,
          }
        case 'pause':
          return {
            ...state,
            fetchStatus: 'paused',
          }
        case 'continue':
          return {
            ...state,
            fetchStatus: 'fetching',
          }
        case 'fetch':
          return {
            ...state,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta:
              (_action$meta = action.meta) != null ? _action$meta : null,
            fetchStatus: canFetch(this.options.networkMode)
              ? 'fetching'
              : 'paused',
            ...(!state.dataUpdatedAt && {
              error: null,
              status: 'loading',
            }),
          }
        case 'success':
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt:
              (_action$dataUpdatedAt = action.dataUpdatedAt) != null
                ? _action$dataUpdatedAt
                : Date.now(),
            error: null,
            isInvalidated: false,
            status: 'success',
            ...(!action.manual && {
              fetchStatus: 'idle',
              fetchFailureCount: 0,
              fetchFailureReason: null,
            }),
          }
        case 'error':
          const error = action.error
          if (isCancelledError(error) && error.revert && this.revertState) {
            return {
              ...this.revertState,
              fetchStatus: 'idle',
            }
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: 'idle',
            status: 'error',
          }
        case 'invalidate':
          return {
            ...state,
            isInvalidated: true,
          }
        case 'setState':
          return {
            ...state,
            ...action.state,
          }
      }
    }
    this.state = reducer(this.state)
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate(action)
      })
      this.cache.notify({
        query: this,
        type: 'updated',
        action,
      })
    })
  }
}
function getDefaultState$1(options) {
  const data =
    typeof options.initialData === 'function'
      ? options.initialData()
      : options.initialData
  const hasData = typeof data !== 'undefined'
  const initialDataUpdatedAt = hasData
    ? typeof options.initialDataUpdatedAt === 'function'
      ? options.initialDataUpdatedAt()
      : options.initialDataUpdatedAt
    : 0
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData
      ? initialDataUpdatedAt != null
        ? initialDataUpdatedAt
        : Date.now()
      : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? 'success' : 'loading',
    fetchStatus: 'idle',
  }
}
class QueryCache extends Subscribable {
  constructor(config) {
    super()
    this.config = config || {}
    this.queries = []
    this.queriesMap = {}
  }
  build(client, options, state) {
    var _options$queryHash
    const queryKey = options.queryKey
    const queryHash =
      (_options$queryHash = options.queryHash) != null
        ? _options$queryHash
        : hashQueryKeyByOptions(queryKey, options)
    let query = this.get(queryHash)
    if (!query) {
      query = new Query({
        cache: this,
        logger: client.getLogger(),
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey),
      })
      this.add(query)
    }
    return query
  }
  add(query) {
    if (!this.queriesMap[query.queryHash]) {
      this.queriesMap[query.queryHash] = query
      this.queries.push(query)
      this.notify({
        type: 'added',
        query,
      })
    }
  }
  remove(query) {
    const queryInMap = this.queriesMap[query.queryHash]
    if (queryInMap) {
      query.destroy()
      this.queries = this.queries.filter((x) => x !== query)
      if (queryInMap === query) {
        delete this.queriesMap[query.queryHash]
      }
      this.notify({
        type: 'removed',
        query,
      })
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        this.remove(query)
      })
    })
  }
  get(queryHash) {
    return this.queriesMap[queryHash]
  }
  getAll() {
    return this.queries
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  find(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2)
    if (typeof filters.exact === 'undefined') {
      filters.exact = true
    }
    return this.queries.find((query) => matchQuery(filters, query))
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  findAll(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2)
    return Object.keys(filters).length > 0
      ? this.queries.filter((query) => matchQuery(filters, query))
      : this.queries
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach(({listener}) => {
        listener(event)
      })
    })
  }
  onFocus() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onFocus()
      })
    })
  }
  onOnline() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onOnline()
      })
    })
  }
}
class Mutation extends Removable {
  constructor(config) {
    super()
    this.defaultOptions = config.defaultOptions
    this.mutationId = config.mutationId
    this.mutationCache = config.mutationCache
    this.logger = config.logger || defaultLogger
    this.observers = []
    this.state = config.state || getDefaultState()
    this.setOptions(config.options)
    this.scheduleGc()
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options,
    }
    this.updateCacheTime(this.options.cacheTime)
  }
  get meta() {
    return this.options.meta
  }
  setState(state) {
    this.dispatch({
      type: 'setState',
      state,
    })
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer)
      this.clearGcTimeout()
      this.mutationCache.notify({
        type: 'observerAdded',
        mutation: this,
        observer,
      })
    }
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((x) => x !== observer)
    this.scheduleGc()
    this.mutationCache.notify({
      type: 'observerRemoved',
      mutation: this,
      observer,
    })
  }
  optionalRemove() {
    if (!this.observers.length) {
      if (this.state.status === 'loading') {
        this.scheduleGc()
      } else {
        this.mutationCache.remove(this)
      }
    }
  }
  continue() {
    var _this$retryer$continu, _this$retryer
    return (_this$retryer$continu =
      (_this$retryer = this.retryer) == null
        ? void 0
        : _this$retryer.continue()) != null
      ? _this$retryer$continu
      : this.execute()
  }
  async execute() {
    const executeMutation = () => {
      var _this$options$retry
      this.retryer = createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject('No mutationFn found')
          }
          return this.options.mutationFn(this.state.variables)
        },
        onFail: (failureCount, error) => {
          this.dispatch({
            type: 'failed',
            failureCount,
            error,
          })
        },
        onPause: () => {
          this.dispatch({
            type: 'pause',
          })
        },
        onContinue: () => {
          this.dispatch({
            type: 'continue',
          })
        },
        retry:
          (_this$options$retry = this.options.retry) != null
            ? _this$options$retry
            : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
      })
      return this.retryer.promise
    }
    const restored = this.state.status === 'loading'
    try {
      var _this$mutationCache$c3,
        _this$mutationCache$c4,
        _this$options$onSucce,
        _this$options2,
        _this$mutationCache$c5,
        _this$mutationCache$c6,
        _this$options$onSettl,
        _this$options3
      if (!restored) {
        var _this$mutationCache$c,
          _this$mutationCache$c2,
          _this$options$onMutat,
          _this$options
        this.dispatch({
          type: 'loading',
          variables: this.options.variables,
        })
        await ((_this$mutationCache$c = (_this$mutationCache$c2 =
          this.mutationCache.config).onMutate) == null
          ? void 0
          : _this$mutationCache$c.call(
              _this$mutationCache$c2,
              this.state.variables,
              this,
            ))
        const context = await ((_this$options$onMutat = (_this$options =
          this.options).onMutate) == null
          ? void 0
          : _this$options$onMutat.call(_this$options, this.state.variables))
        if (context !== this.state.context) {
          this.dispatch({
            type: 'loading',
            context,
            variables: this.state.variables,
          })
        }
      }
      const data = await executeMutation()
      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 =
        this.mutationCache.config).onSuccess) == null
        ? void 0
        : _this$mutationCache$c3.call(
            _this$mutationCache$c4,
            data,
            this.state.variables,
            this.state.context,
            this,
          ))
      await ((_this$options$onSucce = (_this$options2 = this.options)
        .onSuccess) == null
        ? void 0
        : _this$options$onSucce.call(
            _this$options2,
            data,
            this.state.variables,
            this.state.context,
          ))
      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 =
        this.mutationCache.config).onSettled) == null
        ? void 0
        : _this$mutationCache$c5.call(
            _this$mutationCache$c6,
            data,
            null,
            this.state.variables,
            this.state.context,
            this,
          ))
      await ((_this$options$onSettl = (_this$options3 = this.options)
        .onSettled) == null
        ? void 0
        : _this$options$onSettl.call(
            _this$options3,
            data,
            null,
            this.state.variables,
            this.state.context,
          ))
      this.dispatch({
        type: 'success',
        data,
      })
      return data
    } catch (error) {
      try {
        var _this$mutationCache$c7,
          _this$mutationCache$c8,
          _this$options$onError,
          _this$options4,
          _this$mutationCache$c9,
          _this$mutationCache$c10,
          _this$options$onSettl2,
          _this$options5
        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 =
          this.mutationCache.config).onError) == null
          ? void 0
          : _this$mutationCache$c7.call(
              _this$mutationCache$c8,
              error,
              this.state.variables,
              this.state.context,
              this,
            ))
        if (process.env.NODE_ENV !== 'production') {
          this.logger.error(error)
        }
        await ((_this$options$onError = (_this$options4 = this.options)
          .onError) == null
          ? void 0
          : _this$options$onError.call(
              _this$options4,
              error,
              this.state.variables,
              this.state.context,
            ))
        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 =
          this.mutationCache.config).onSettled) == null
          ? void 0
          : _this$mutationCache$c9.call(
              _this$mutationCache$c10,
              void 0,
              error,
              this.state.variables,
              this.state.context,
              this,
            ))
        await ((_this$options$onSettl2 = (_this$options5 = this.options)
          .onSettled) == null
          ? void 0
          : _this$options$onSettl2.call(
              _this$options5,
              void 0,
              error,
              this.state.variables,
              this.state.context,
            ))
        throw error
      } finally {
        this.dispatch({
          type: 'error',
          error,
        })
      }
    }
  }
  dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case 'failed':
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error,
          }
        case 'pause':
          return {
            ...state,
            isPaused: true,
          }
        case 'continue':
          return {
            ...state,
            isPaused: false,
          }
        case 'loading':
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !canFetch(this.options.networkMode),
            status: 'loading',
            variables: action.variables,
          }
        case 'success':
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: 'success',
            isPaused: false,
          }
        case 'error':
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: 'error',
          }
        case 'setState':
          return {
            ...state,
            ...action.state,
          }
      }
    }
    this.state = reducer(this.state)
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onMutationUpdate(action)
      })
      this.mutationCache.notify({
        mutation: this,
        type: 'updated',
        action,
      })
    })
  }
}
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: 'idle',
    variables: void 0,
  }
}
class MutationCache extends Subscribable {
  constructor(config) {
    super()
    this.config = config || {}
    this.mutations = []
    this.mutationId = 0
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      logger: client.getLogger(),
      mutationId: ++this.mutationId,
      options: client.defaultMutationOptions(options),
      state,
      defaultOptions: options.mutationKey
        ? client.getMutationDefaults(options.mutationKey)
        : void 0,
    })
    this.add(mutation)
    return mutation
  }
  add(mutation) {
    this.mutations.push(mutation)
    this.notify({
      type: 'added',
      mutation,
    })
  }
  remove(mutation) {
    this.mutations = this.mutations.filter((x) => x !== mutation)
    this.notify({
      type: 'removed',
      mutation,
    })
  }
  clear() {
    notifyManager.batch(() => {
      this.mutations.forEach((mutation) => {
        this.remove(mutation)
      })
    })
  }
  getAll() {
    return this.mutations
  }
  find(filters) {
    if (typeof filters.exact === 'undefined') {
      filters.exact = true
    }
    return this.mutations.find((mutation) => matchMutation(filters, mutation))
  }
  findAll(filters) {
    return this.mutations.filter((mutation) => matchMutation(filters, mutation))
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach(({listener}) => {
        listener(event)
      })
    })
  }
  resumePausedMutations() {
    var _this$resuming
    this.resuming = (
      (_this$resuming = this.resuming) != null
        ? _this$resuming
        : Promise.resolve()
    )
      .then(() => {
        const pausedMutations = this.mutations.filter((x) => x.state.isPaused)
        return notifyManager.batch(() =>
          pausedMutations.reduce(
            (promise, mutation) =>
              promise.then(() => mutation.continue().catch(noop)),
            Promise.resolve(),
          ),
        )
      })
      .then(() => {
        this.resuming = void 0
      })
    return this.resuming
  }
}
function infiniteQueryBehavior() {
  return {
    onFetch: (context) => {
      context.fetchFn = () => {
        var _context$fetchOptions,
          _context$fetchOptions2,
          _context$fetchOptions3,
          _context$fetchOptions4,
          _context$state$data,
          _context$state$data2
        const refetchPage =
          (_context$fetchOptions = context.fetchOptions) == null
            ? void 0
            : (_context$fetchOptions2 = _context$fetchOptions.meta) == null
            ? void 0
            : _context$fetchOptions2.refetchPage
        const fetchMore =
          (_context$fetchOptions3 = context.fetchOptions) == null
            ? void 0
            : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null
            ? void 0
            : _context$fetchOptions4.fetchMore
        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam
        const isFetchingNextPage =
          (fetchMore == null ? void 0 : fetchMore.direction) === 'forward'
        const isFetchingPreviousPage =
          (fetchMore == null ? void 0 : fetchMore.direction) === 'backward'
        const oldPages =
          ((_context$state$data = context.state.data) == null
            ? void 0
            : _context$state$data.pages) || []
        const oldPageParams =
          ((_context$state$data2 = context.state.data) == null
            ? void 0
            : _context$state$data2.pageParams) || []
        let newPageParams = oldPageParams
        let cancelled = false
        const addSignalProperty = (object) => {
          Object.defineProperty(object, 'signal', {
            enumerable: true,
            get: () => {
              var _context$signal
              if (
                (_context$signal = context.signal) != null &&
                _context$signal.aborted
              ) {
                cancelled = true
              } else {
                var _context$signal2
                ;(_context$signal2 = context.signal) == null
                  ? void 0
                  : _context$signal2.addEventListener('abort', () => {
                      cancelled = true
                    })
              }
              return context.signal
            },
          })
        }
        const queryFn =
          context.options.queryFn ||
          (() =>
            Promise.reject(
              "Missing queryFn for queryKey '" +
                context.options.queryHash +
                "'",
            ))
        const buildNewPages = (pages, param, page, previous) => {
          newPageParams = previous
            ? [param, ...newPageParams]
            : [...newPageParams, param]
          return previous ? [page, ...pages] : [...pages, page]
        }
        const fetchPage = (pages, manual, param, previous) => {
          if (cancelled) {
            return Promise.reject('Cancelled')
          }
          if (typeof param === 'undefined' && !manual && pages.length) {
            return Promise.resolve(pages)
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            meta: context.options.meta,
          }
          addSignalProperty(queryFnContext)
          const queryFnResult = queryFn(queryFnContext)
          const promise2 = Promise.resolve(queryFnResult).then((page) =>
            buildNewPages(pages, param, page, previous),
          )
          return promise2
        }
        let promise
        if (!oldPages.length) {
          promise = fetchPage([])
        } else if (isFetchingNextPage) {
          const manual = typeof pageParam !== 'undefined'
          const param = manual
            ? pageParam
            : getNextPageParam(context.options, oldPages)
          promise = fetchPage(oldPages, manual, param)
        } else if (isFetchingPreviousPage) {
          const manual = typeof pageParam !== 'undefined'
          const param = manual
            ? pageParam
            : getPreviousPageParam(context.options, oldPages)
          promise = fetchPage(oldPages, manual, param, true)
        } else {
          newPageParams = []
          const manual = typeof context.options.getNextPageParam === 'undefined'
          const shouldFetchFirstPage =
            refetchPage && oldPages[0]
              ? refetchPage(oldPages[0], 0, oldPages)
              : true
          promise = shouldFetchFirstPage
            ? fetchPage([], manual, oldPageParams[0])
            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))
          for (let i = 1; i < oldPages.length; i++) {
            promise = promise.then((pages) => {
              const shouldFetchNextPage =
                refetchPage && oldPages[i]
                  ? refetchPage(oldPages[i], i, oldPages)
                  : true
              if (shouldFetchNextPage) {
                const param = manual
                  ? oldPageParams[i]
                  : getNextPageParam(context.options, pages)
                return fetchPage(pages, manual, param)
              }
              return Promise.resolve(
                buildNewPages(pages, oldPageParams[i], oldPages[i]),
              )
            })
          }
        }
        const finalPromise = promise.then((pages) => ({
          pages,
          pageParams: newPageParams,
        }))
        return finalPromise
      }
    },
  }
}
function getNextPageParam(options, pages) {
  return options.getNextPageParam == null
    ? void 0
    : options.getNextPageParam(pages[pages.length - 1], pages)
}
function getPreviousPageParam(options, pages) {
  return options.getPreviousPageParam == null
    ? void 0
    : options.getPreviousPageParam(pages[0], pages)
}
class QueryClient {
  constructor(config = {}) {
    this.queryCache = config.queryCache || new QueryCache()
    this.mutationCache = config.mutationCache || new MutationCache()
    this.logger = config.logger || defaultLogger
    this.defaultOptions = config.defaultOptions || {}
    this.queryDefaults = []
    this.mutationDefaults = []
    this.mountCount = 0
    if (process.env.NODE_ENV !== 'production' && config.logger) {
      this.logger.error(
        'Passing a custom logger has been deprecated and will be removed in the next major version.',
      )
    }
  }
  mount() {
    this.mountCount++
    if (this.mountCount !== 1) return
    this.unsubscribeFocus = focusManager.subscribe(() => {
      if (focusManager.isFocused()) {
        this.resumePausedMutations()
        this.queryCache.onFocus()
      }
    })
    this.unsubscribeOnline = onlineManager.subscribe(() => {
      if (onlineManager.isOnline()) {
        this.resumePausedMutations()
        this.queryCache.onOnline()
      }
    })
  }
  unmount() {
    var _this$unsubscribeFocu, _this$unsubscribeOnli
    this.mountCount--
    if (this.mountCount !== 0) return
    ;(_this$unsubscribeFocu = this.unsubscribeFocus) == null
      ? void 0
      : _this$unsubscribeFocu.call(this)
    this.unsubscribeFocus = void 0
    ;(_this$unsubscribeOnli = this.unsubscribeOnline) == null
      ? void 0
      : _this$unsubscribeOnli.call(this)
    this.unsubscribeOnline = void 0
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  isFetching(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2)
    filters.fetchStatus = 'fetching'
    return this.queryCache.findAll(filters).length
  }
  isMutating(filters) {
    return this.mutationCache.findAll({
      ...filters,
      fetching: true,
    }).length
  }
  /**
   * @deprecated This method will accept only queryKey in the next major version.
   */
  getQueryData(queryKey, filters) {
    var _this$queryCache$find
    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) ==
      null
      ? void 0
      : _this$queryCache$find.state.data
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  ensureQueryData(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)
    const cachedData = this.getQueryData(parsedOptions.queryKey)
    return cachedData
      ? Promise.resolve(cachedData)
      : this.fetchQuery(parsedOptions)
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  getQueriesData(queryKeyOrFilters) {
    return this.getQueryCache()
      .findAll(queryKeyOrFilters)
      .map(({queryKey, state}) => {
        const data = state.data
        return [queryKey, data]
      })
  }
  setQueryData(queryKey, updater, options) {
    const query = this.queryCache.find(queryKey)
    const prevData = query == null ? void 0 : query.state.data
    const data = functionalUpdate(updater, prevData)
    if (typeof data === 'undefined') {
      return void 0
    }
    const parsedOptions = parseQueryArgs(queryKey)
    const defaultedOptions = this.defaultQueryOptions(parsedOptions)
    return this.queryCache.build(this, defaultedOptions).setData(data, {
      ...options,
      manual: true,
    })
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  setQueriesData(queryKeyOrFilters, updater, options) {
    return notifyManager.batch(() =>
      this.getQueryCache()
        .findAll(queryKeyOrFilters)
        .map(({queryKey}) => [
          queryKey,
          this.setQueryData(queryKey, updater, options),
        ]),
    )
  }
  getQueryState(queryKey, filters) {
    var _this$queryCache$find2
    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) ==
      null
      ? void 0
      : _this$queryCache$find2.state
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  removeQueries(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2)
    const queryCache = this.queryCache
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query)
      })
    })
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  resetQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)
    const queryCache = this.queryCache
    const refetchFilters = {
      type: 'active',
      ...filters,
    }
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset()
      })
      return this.refetchQueries(refetchFilters, options)
    })
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  cancelQueries(arg1, arg2, arg3) {
    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)
    if (typeof cancelOptions.revert === 'undefined') {
      cancelOptions.revert = true
    }
    const promises = notifyManager.batch(() =>
      this.queryCache
        .findAll(filters)
        .map((query) => query.cancel(cancelOptions)),
    )
    return Promise.all(promises).then(noop).catch(noop)
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  invalidateQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)
    return notifyManager.batch(() => {
      var _ref, _filters$refetchType
      this.queryCache.findAll(filters).forEach((query) => {
        query.invalidate()
      })
      if (filters.refetchType === 'none') {
        return Promise.resolve()
      }
      const refetchFilters = {
        ...filters,
        type:
          (_ref =
            (_filters$refetchType = filters.refetchType) != null
              ? _filters$refetchType
              : filters.type) != null
            ? _ref
            : 'active',
      }
      return this.refetchQueries(refetchFilters, options)
    })
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  refetchQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)
    const promises = notifyManager.batch(() =>
      this.queryCache
        .findAll(filters)
        .filter((query) => !query.isDisabled())
        .map((query) => {
          var _options$cancelRefetc
          return query.fetch(void 0, {
            ...options,
            cancelRefetch:
              (_options$cancelRefetc =
                options == null ? void 0 : options.cancelRefetch) != null
                ? _options$cancelRefetc
                : true,
            meta: {
              refetchPage: filters.refetchPage,
            },
          })
        }),
    )
    let promise = Promise.all(promises).then(noop)
    if (!(options != null && options.throwOnError)) {
      promise = promise.catch(noop)
    }
    return promise
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  fetchQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)
    const defaultedOptions = this.defaultQueryOptions(parsedOptions)
    if (typeof defaultedOptions.retry === 'undefined') {
      defaultedOptions.retry = false
    }
    const query = this.queryCache.build(this, defaultedOptions)
    return query.isStaleByTime(defaultedOptions.staleTime)
      ? query.fetch(defaultedOptions)
      : Promise.resolve(query.state.data)
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  prefetchQuery(arg1, arg2, arg3) {
    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop)
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  fetchInfiniteQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)
    parsedOptions.behavior = infiniteQueryBehavior()
    return this.fetchQuery(parsedOptions)
  }
  /**
   * @deprecated This method should be used with only one object argument.
   */
  prefetchInfiniteQuery(arg1, arg2, arg3) {
    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop)
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations()
  }
  getQueryCache() {
    return this.queryCache
  }
  getMutationCache() {
    return this.mutationCache
  }
  getLogger() {
    return this.logger
  }
  getDefaultOptions() {
    return this.defaultOptions
  }
  setDefaultOptions(options) {
    this.defaultOptions = options
  }
  setQueryDefaults(queryKey, options) {
    const result = this.queryDefaults.find(
      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),
    )
    if (result) {
      result.defaultOptions = options
    } else {
      this.queryDefaults.push({
        queryKey,
        defaultOptions: options,
      })
    }
  }
  getQueryDefaults(queryKey) {
    if (!queryKey) {
      return void 0
    }
    const firstMatchingDefaults = this.queryDefaults.find((x) =>
      partialMatchKey(queryKey, x.queryKey),
    )
    if (process.env.NODE_ENV !== 'production') {
      const matchingDefaults = this.queryDefaults.filter((x) =>
        partialMatchKey(queryKey, x.queryKey),
      )
      if (matchingDefaults.length > 1) {
        this.logger.error(
          "[QueryClient] Several query defaults match with key '" +
            JSON.stringify(queryKey) +
            "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.",
        )
      }
    }
    return firstMatchingDefaults == null
      ? void 0
      : firstMatchingDefaults.defaultOptions
  }
  setMutationDefaults(mutationKey, options) {
    const result = this.mutationDefaults.find(
      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),
    )
    if (result) {
      result.defaultOptions = options
    } else {
      this.mutationDefaults.push({
        mutationKey,
        defaultOptions: options,
      })
    }
  }
  getMutationDefaults(mutationKey) {
    if (!mutationKey) {
      return void 0
    }
    const firstMatchingDefaults = this.mutationDefaults.find((x) =>
      partialMatchKey(mutationKey, x.mutationKey),
    )
    if (process.env.NODE_ENV !== 'production') {
      const matchingDefaults = this.mutationDefaults.filter((x) =>
        partialMatchKey(mutationKey, x.mutationKey),
      )
      if (matchingDefaults.length > 1) {
        this.logger.error(
          "[QueryClient] Several mutation defaults match with key '" +
            JSON.stringify(mutationKey) +
            "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.",
        )
      }
    }
    return firstMatchingDefaults == null
      ? void 0
      : firstMatchingDefaults.defaultOptions
  }
  defaultQueryOptions(options) {
    if (options != null && options._defaulted) {
      return options
    }
    const defaultedOptions = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
      ...options,
      _defaulted: true,
    }
    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions,
      )
    }
    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {
      defaultedOptions.refetchOnReconnect =
        defaultedOptions.networkMode !== 'always'
    }
    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {
      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense
    }
    return defaultedOptions
  }
  defaultMutationOptions(options) {
    if (options != null && options._defaulted) {
      return options
    }
    return {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(
        options == null ? void 0 : options.mutationKey,
      ),
      ...options,
      _defaulted: true,
    }
  }
  clear() {
    this.queryCache.clear()
    this.mutationCache.clear()
  }
}
function documentMetadataParseAdjustments(metadata) {
  if (metadata?.theme === '[object Object]') {
    metadata.theme = void 0
  }
}
const queryCacheErrorSubscriptions = /* @__PURE__ */ new Set()
new QueryClient({
  queryCache: new QueryCache({
    onError: (err, query) => {
      queryCacheErrorSubscriptions.forEach((handler) => handler(err, query))
    },
  }),
  defaultOptions: {
    mutations: {
      networkMode: 'always',
    },
    queries: {
      networkMode: 'always',
      useErrorBoundary: true,
      retryOnMount: false,
      staleTime: Infinity,
      refetchOnReconnect: false,
      onError: (err) => {
        console.log(`Query error: ${JSON.stringify(err)}`)
      },
      retry: 4,
      retryDelay: (attempt) =>
        Math.min(attempt > 1 ? 2 ** attempt * 1e3 : 1e3, 30 * 1e3),
      keepPreviousData: true,
    },
  },
})
z$1.array(
  z$1.object({
    status: z$1.union([
      z$1.literal('open'),
      z$1.literal('settled'),
      z$1.literal('error'),
    ]),
  }),
)
function getGlobal() {
  if (typeof globalThis !== 'undefined') {
    return globalThis
  }
  if (typeof self !== 'undefined') {
    return self
  }
  if (typeof window !== 'undefined') {
    return window
  }
  if (typeof global !== 'undefined') {
    return global
  }
}
function getDevTools() {
  const w = getGlobal()
  if (w.__xstate__) {
    return w.__xstate__
  }
  return void 0
}
const devToolsAdapter = (service) => {
  if (typeof window === 'undefined') {
    return
  }
  const devTools = getDevTools()
  if (devTools) {
    devTools.register(service)
  }
}
class Mailbox {
  constructor(_process) {
    this._process = _process
    this._active = false
    this._current = null
    this._last = null
  }
  start() {
    this._active = true
    this.flush()
  }
  clear() {
    if (this._current) {
      this._current.next = null
      this._last = this._current
    }
  }
  enqueue(event) {
    const enqueued = {
      value: event,
      next: null,
    }
    if (this._current) {
      this._last.next = enqueued
      this._last = enqueued
      return
    }
    this._current = enqueued
    this._last = enqueued
    if (this._active) {
      this.flush()
    }
  }
  flush() {
    while (this._current) {
      const consumed = this._current
      this._process(consumed.value)
      this._current = consumed.next
    }
    this._last = null
  }
}
const STATE_DELIMITER = '.'
const TARGETLESS_KEY = ''
const NULL_EVENT = ''
const STATE_IDENTIFIER$1 = '#'
const WILDCARD = '*'
const XSTATE_INIT = 'xstate.init'
const XSTATE_STOP = 'xstate.stop'
function createAfterEvent(delayRef, id) {
  return {
    type: `xstate.after.${delayRef}.${id}`,
  }
}
function createDoneStateEvent(id, output) {
  return {
    type: `xstate.done.state.${id}`,
    output,
  }
}
function createDoneActorEvent(invokeId, output) {
  return {
    type: `xstate.done.actor.${invokeId}`,
    output,
    actorId: invokeId,
  }
}
function createErrorActorEvent(id, error) {
  return {
    type: `xstate.error.actor.${id}`,
    error,
    actorId: id,
  }
}
function createInitEvent(input) {
  return {
    type: XSTATE_INIT,
    input,
  }
}
function reportUnhandledError(err) {
  setTimeout(() => {
    throw err
  })
}
const symbolObservable = (() =>
  (typeof Symbol === 'function' && Symbol.observable) || '@@observable')()
function matchesState(parentStateId, childStateId) {
  const parentStateValue = toStateValue(parentStateId)
  const childStateValue = toStateValue(childStateId)
  if (typeof childStateValue === 'string') {
    if (typeof parentStateValue === 'string') {
      return childStateValue === parentStateValue
    }
    return false
  }
  if (typeof parentStateValue === 'string') {
    return parentStateValue in childStateValue
  }
  return Object.keys(parentStateValue).every((key) => {
    if (!(key in childStateValue)) {
      return false
    }
    return matchesState(parentStateValue[key], childStateValue[key])
  })
}
function toStatePath(stateId) {
  if (isArray(stateId)) {
    return stateId
  }
  const result = []
  let segment = ''
  for (let i = 0; i < stateId.length; i++) {
    const char = stateId.charCodeAt(i)
    switch (char) {
      // \
      case 92:
        segment += stateId[i + 1]
        i++
        continue
      // .
      case 46:
        result.push(segment)
        segment = ''
        continue
    }
    segment += stateId[i]
  }
  result.push(segment)
  return result
}
function toStateValue(stateValue) {
  if (isMachineSnapshot(stateValue)) {
    return stateValue.value
  }
  if (typeof stateValue !== 'string') {
    return stateValue
  }
  const statePath = toStatePath(stateValue)
  return pathToStateValue(statePath)
}
function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0]
  }
  const value = {}
  let marker = value
  for (let i = 0; i < statePath.length - 1; i++) {
    if (i === statePath.length - 2) {
      marker[statePath[i]] = statePath[i + 1]
    } else {
      const previous = marker
      marker = {}
      previous[statePath[i]] = marker
    }
  }
  return value
}
function mapValues(collection, iteratee) {
  const result = {}
  const collectionKeys = Object.keys(collection)
  for (let i = 0; i < collectionKeys.length; i++) {
    const key = collectionKeys[i]
    result[key] = iteratee(collection[key], key, collection, i)
  }
  return result
}
function toArrayStrict(value) {
  if (isArray(value)) {
    return value
  }
  return [value]
}
function toArray(value) {
  if (value === void 0) {
    return []
  }
  return toArrayStrict(value)
}
function resolveOutput(mapper, context, event, self2) {
  if (typeof mapper === 'function') {
    return mapper({
      context,
      event,
      self: self2,
    })
  }
  return mapper
}
function isArray(value) {
  return Array.isArray(value)
}
function isErrorActorEvent(event) {
  return event.type.startsWith('xstate.error.actor')
}
function toTransitionConfigArray(configLike) {
  return toArrayStrict(configLike).map((transitionLike) => {
    if (
      typeof transitionLike === 'undefined' ||
      typeof transitionLike === 'string'
    ) {
      return {
        target: transitionLike,
      }
    }
    return transitionLike
  })
}
function normalizeTarget(target) {
  if (target === void 0 || target === TARGETLESS_KEY) {
    return void 0
  }
  return toArray(target)
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  const isObserver = typeof nextHandler === 'object'
  const self2 = isObserver ? nextHandler : void 0
  return {
    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self2),
    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self2),
    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(
      self2,
    ),
  }
}
function createInvokeId(stateNodeId, index) {
  return `${index}.${stateNodeId}`
}
function resolveReferencedActor(machine, src) {
  const match2 = src.match(/^xstate\.invoke\.(\d+)\.(.*)/)
  if (!match2) {
    return machine.implementations.actors[src]
  }
  const [, indexStr, nodeId] = match2
  const node = machine.getStateNodeById(nodeId)
  const invokeConfig = node.config.invoke
  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig)
    .src
}
function createScheduledEventId(actorRef, id) {
  return `${actorRef.sessionId}.${id}`
}
let idCounter = 0
function createSystem(rootActor, options) {
  const children = /* @__PURE__ */ new Map()
  const keyedActors = /* @__PURE__ */ new Map()
  const reverseKeyedActors = /* @__PURE__ */ new WeakMap()
  const inspectionObservers = /* @__PURE__ */ new Set()
  const timerMap = {}
  const {clock, logger} = options
  const scheduler = {
    schedule: (
      source,
      target,
      event,
      delay,
      id = Math.random().toString(36).slice(2),
    ) => {
      const scheduledEvent = {
        source,
        target,
        event,
        delay,
        id,
        startedAt: Date.now(),
      }
      const scheduledEventId = createScheduledEventId(source, id)
      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent
      const timeout = clock.setTimeout(() => {
        delete timerMap[scheduledEventId]
        delete system._snapshot._scheduledEvents[scheduledEventId]
        system._relay(source, target, event)
      }, delay)
      timerMap[scheduledEventId] = timeout
    },
    cancel: (source, id) => {
      const scheduledEventId = createScheduledEventId(source, id)
      const timeout = timerMap[scheduledEventId]
      delete timerMap[scheduledEventId]
      delete system._snapshot._scheduledEvents[scheduledEventId]
      if (timeout !== void 0) {
        clock.clearTimeout(timeout)
      }
    },
    cancelAll: (actorRef) => {
      for (const scheduledEventId in system._snapshot._scheduledEvents) {
        const scheduledEvent =
          system._snapshot._scheduledEvents[scheduledEventId]
        if (scheduledEvent.source === actorRef) {
          scheduler.cancel(actorRef, scheduledEvent.id)
        }
      }
    },
  }
  const sendInspectionEvent = (event) => {
    if (!inspectionObservers.size) {
      return
    }
    const resolvedInspectionEvent = {
      ...event,
      rootId: rootActor.sessionId,
    }
    inspectionObservers.forEach((observer) =>
      observer.next?.(resolvedInspectionEvent),
    )
  }
  const system = {
    _snapshot: {
      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {},
    },
    _bookId: () => `x:${idCounter++}`,
    _register: (sessionId, actorRef) => {
      children.set(sessionId, actorRef)
      return sessionId
    },
    _unregister: (actorRef) => {
      children.delete(actorRef.sessionId)
      const systemId = reverseKeyedActors.get(actorRef)
      if (systemId !== void 0) {
        keyedActors.delete(systemId)
        reverseKeyedActors.delete(actorRef)
      }
    },
    get: (systemId) => {
      return keyedActors.get(systemId)
    },
    _set: (systemId, actorRef) => {
      const existing = keyedActors.get(systemId)
      if (existing && existing !== actorRef) {
        throw new Error(`Actor with system ID '${systemId}' already exists.`)
      }
      keyedActors.set(systemId, actorRef)
      reverseKeyedActors.set(actorRef, systemId)
    },
    inspect: (observerOrFn) => {
      const observer = toObserver(observerOrFn)
      inspectionObservers.add(observer)
      return {
        unsubscribe() {
          inspectionObservers.delete(observer)
        },
      }
    },
    _sendInspectionEvent: sendInspectionEvent,
    _relay: (source, target, event) => {
      system._sendInspectionEvent({
        type: '@xstate.event',
        sourceRef: source,
        actorRef: target,
        event,
      })
      target._send(event)
    },
    scheduler,
    getSnapshot: () => {
      return {
        _scheduledEvents: {
          ...system._snapshot._scheduledEvents,
        },
      }
    },
    start: () => {
      const scheduledEvents = system._snapshot._scheduledEvents
      system._snapshot._scheduledEvents = {}
      for (const scheduledId in scheduledEvents) {
        const {source, target, event, delay, id} = scheduledEvents[scheduledId]
        scheduler.schedule(source, target, event, delay, id)
      }
    },
    _clock: clock,
    _logger: logger,
  }
  return system
}
let executingCustomAction = false
const $$ACTOR_TYPE = 1
let ProcessingStatus = /* @__PURE__ */ (function (ProcessingStatus2) {
  ProcessingStatus2[(ProcessingStatus2['NotStarted'] = 0)] = 'NotStarted'
  ProcessingStatus2[(ProcessingStatus2['Running'] = 1)] = 'Running'
  ProcessingStatus2[(ProcessingStatus2['Stopped'] = 2)] = 'Stopped'
  return ProcessingStatus2
})({})
const defaultOptions = {
  clock: {
    setTimeout: (fn, ms) => {
      return setTimeout(fn, ms)
    },
    clearTimeout: (id) => {
      return clearTimeout(id)
    },
  },
  logger: console.log.bind(console),
  devTools: false,
}
class Actor {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(logic, options) {
    this.logic = logic
    this._snapshot = void 0
    this.clock = void 0
    this.options = void 0
    this.id = void 0
    this.mailbox = new Mailbox(this._process.bind(this))
    this.observers = /* @__PURE__ */ new Set()
    this.eventListeners = /* @__PURE__ */ new Map()
    this.logger = void 0
    this._processingStatus = ProcessingStatus.NotStarted
    this._parent = void 0
    this._syncSnapshot = void 0
    this.ref = void 0
    this._actorScope = void 0
    this._systemId = void 0
    this.sessionId = void 0
    this.system = void 0
    this._doneEvent = void 0
    this.src = void 0
    this._deferred = []
    const resolvedOptions = {
      ...defaultOptions,
      ...options,
    }
    const {clock, logger, parent, syncSnapshot, id, systemId, inspect} =
      resolvedOptions
    this.system = parent
      ? parent.system
      : createSystem(this, {
          clock,
          logger,
        })
    if (inspect && !parent) {
      this.system.inspect(toObserver(inspect))
    }
    this.sessionId = this.system._bookId()
    this.id = id ?? this.sessionId
    this.logger = options?.logger ?? this.system._logger
    this.clock = options?.clock ?? this.system._clock
    this._parent = parent
    this._syncSnapshot = syncSnapshot
    this.options = resolvedOptions
    this.src = resolvedOptions.src ?? logic
    this.ref = this
    this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (fn) => {
        this._deferred.push(fn)
      },
      system: this.system,
      stopChild: (child) => {
        if (child._parent !== this) {
          throw new Error(
            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`,
          )
        }
        child._stop()
      },
      emit: (emittedEvent) => {
        const listeners = this.eventListeners.get(emittedEvent.type)
        const wildcardListener = this.eventListeners.get('*')
        if (!listeners && !wildcardListener) {
          return
        }
        const allListeners = [
          ...(listeners ? listeners.values() : []),
          ...(wildcardListener ? wildcardListener.values() : []),
        ]
        for (const handler of allListeners) {
          handler(emittedEvent)
        }
      },
      actionExecutor: (action) => {
        const exec = () => {
          this._actorScope.system._sendInspectionEvent({
            type: '@xstate.action',
            actorRef: this,
            action: {
              type: action.type,
              params: action.params,
            },
          })
          if (!action.exec) {
            return
          }
          const saveExecutingCustomAction = executingCustomAction
          try {
            executingCustomAction = true
            action.exec(action.info, action.params)
          } finally {
            executingCustomAction = saveExecutingCustomAction
          }
        }
        if (this._processingStatus === ProcessingStatus.Running) {
          exec()
        } else {
          this._deferred.push(exec)
        }
      },
    }
    this.send = this.send.bind(this)
    this.system._sendInspectionEvent({
      type: '@xstate.actor',
      actorRef: this,
    })
    if (systemId) {
      this._systemId = systemId
      this.system._set(systemId, this)
    }
    this._initState(options?.snapshot ?? options?.state)
    if (systemId && this._snapshot.status !== 'active') {
      this.system._unregister(this)
    }
  }
  _initState(persistedState) {
    try {
      this._snapshot = persistedState
        ? this.logic.restoreSnapshot
          ? this.logic.restoreSnapshot(persistedState, this._actorScope)
          : persistedState
        : this.logic.getInitialSnapshot(this._actorScope, this.options?.input)
    } catch (err) {
      this._snapshot = {
        status: 'error',
        output: void 0,
        error: err,
      }
    }
  }
  update(snapshot, event) {
    this._snapshot = snapshot
    let deferredFn
    while ((deferredFn = this._deferred.shift())) {
      try {
        deferredFn()
      } catch (err) {
        this._deferred.length = 0
        this._snapshot = {
          ...snapshot,
          status: 'error',
          error: err,
        }
      }
    }
    switch (this._snapshot.status) {
      case 'active':
        for (const observer of this.observers) {
          try {
            observer.next?.(snapshot)
          } catch (err) {
            reportUnhandledError(err)
          }
        }
        break
      case 'done':
        for (const observer of this.observers) {
          try {
            observer.next?.(snapshot)
          } catch (err) {
            reportUnhandledError(err)
          }
        }
        this._stopProcedure()
        this._complete()
        this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output)
        if (this._parent) {
          this.system._relay(this, this._parent, this._doneEvent)
        }
        break
      case 'error':
        this._error(this._snapshot.error)
        break
    }
    this.system._sendInspectionEvent({
      type: '@xstate.snapshot',
      actorRef: this,
      event,
      snapshot,
    })
  }
  /**
   * Subscribe an observer to an actors snapshot values.
   *
   * @remarks
   * The observer will receive the actors snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(nextListenerOrObserver, errorListener, completeListener) {
    const observer = toObserver(
      nextListenerOrObserver,
      errorListener,
      completeListener,
    )
    if (this._processingStatus !== ProcessingStatus.Stopped) {
      this.observers.add(observer)
    } else {
      switch (this._snapshot.status) {
        case 'done':
          try {
            observer.complete?.()
          } catch (err) {
            reportUnhandledError(err)
          }
          break
        case 'error': {
          const err = this._snapshot.error
          if (!observer.error) {
            reportUnhandledError(err)
          } else {
            try {
              observer.error(err)
            } catch (err2) {
              reportUnhandledError(err2)
            }
          }
          break
        }
      }
    }
    return {
      unsubscribe: () => {
        this.observers.delete(observer)
      },
    }
  }
  on(type, handler) {
    let listeners = this.eventListeners.get(type)
    if (!listeners) {
      listeners = /* @__PURE__ */ new Set()
      this.eventListeners.set(type, listeners)
    }
    const wrappedHandler = handler.bind(void 0)
    listeners.add(wrappedHandler)
    return {
      unsubscribe: () => {
        listeners.delete(wrappedHandler)
      },
    }
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === ProcessingStatus.Running) {
      return this
    }
    if (this._syncSnapshot) {
      this.subscribe({
        next: (snapshot) => {
          if (snapshot.status === 'active') {
            this.system._relay(this, this._parent, {
              type: `xstate.snapshot.${this.id}`,
              snapshot,
            })
          }
        },
        error: () => {},
      })
    }
    this.system._register(this.sessionId, this)
    if (this._systemId) {
      this.system._set(this._systemId, this)
    }
    this._processingStatus = ProcessingStatus.Running
    const initEvent = createInitEvent(this.options.input)
    this.system._sendInspectionEvent({
      type: '@xstate.event',
      sourceRef: this._parent,
      actorRef: this,
      event: initEvent,
    })
    const status = this._snapshot.status
    switch (status) {
      case 'done':
        this.update(this._snapshot, initEvent)
        return this
      case 'error':
        this._error(this._snapshot.error)
        return this
    }
    if (!this._parent) {
      this.system.start()
    }
    if (this.logic.start) {
      try {
        this.logic.start(this._snapshot, this._actorScope)
      } catch (err) {
        this._snapshot = {
          ...this._snapshot,
          status: 'error',
          error: err,
        }
        this._error(err)
        return this
      }
    }
    this.update(this._snapshot, initEvent)
    if (this.options.devTools) {
      this.attachDevTools()
    }
    this.mailbox.start()
    return this
  }
  _process(event) {
    let nextState
    let caughtError
    try {
      nextState = this.logic.transition(this._snapshot, event, this._actorScope)
    } catch (err) {
      caughtError = {
        err,
      }
    }
    if (caughtError) {
      const {err} = caughtError
      this._snapshot = {
        ...this._snapshot,
        status: 'error',
        error: err,
      }
      this._error(err)
      return
    }
    this.update(nextState, event)
    if (event.type === XSTATE_STOP) {
      this._stopProcedure()
      this._complete()
    }
  }
  _stop() {
    if (this._processingStatus === ProcessingStatus.Stopped) {
      return this
    }
    this.mailbox.clear()
    if (this._processingStatus === ProcessingStatus.NotStarted) {
      this._processingStatus = ProcessingStatus.Stopped
      return this
    }
    this.mailbox.enqueue({
      type: XSTATE_STOP,
    })
    return this
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent) {
      throw new Error('A non-root actor cannot be stopped directly.')
    }
    return this._stop()
  }
  _complete() {
    for (const observer of this.observers) {
      try {
        observer.complete?.()
      } catch (err) {
        reportUnhandledError(err)
      }
    }
    this.observers.clear()
  }
  _reportError(err) {
    if (!this.observers.size) {
      if (!this._parent) {
        reportUnhandledError(err)
      }
      return
    }
    let reportError = false
    for (const observer of this.observers) {
      const errorListener = observer.error
      reportError ||= !errorListener
      try {
        errorListener?.(err)
      } catch (err2) {
        reportUnhandledError(err2)
      }
    }
    this.observers.clear()
    if (reportError) {
      reportUnhandledError(err)
    }
  }
  _error(err) {
    this._stopProcedure()
    this._reportError(err)
    if (this._parent) {
      this.system._relay(
        this,
        this._parent,
        createErrorActorEvent(this.id, err),
      )
    }
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    if (this._processingStatus !== ProcessingStatus.Running) {
      return this
    }
    this.system.scheduler.cancelAll(this)
    this.mailbox.clear()
    this.mailbox = new Mailbox(this._process.bind(this))
    this._processingStatus = ProcessingStatus.Stopped
    this.system._unregister(this)
    return this
  }
  /** @internal */
  _send(event) {
    if (this._processingStatus === ProcessingStatus.Stopped) {
      return
    }
    this.mailbox.enqueue(event)
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(event) {
    this.system._relay(void 0, this, event)
  }
  attachDevTools() {
    const {devTools} = this.options
    if (devTools) {
      const resolvedDevToolsAdapter =
        typeof devTools === 'function' ? devTools : devToolsAdapter
      resolvedDevToolsAdapter(this)
    }
  }
  toJSON() {
    return {
      xstate$$type: $$ACTOR_TYPE,
      id: this.id,
    }
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(options) {
    return this.logic.getPersistedSnapshot(this._snapshot, options)
  }
  [symbolObservable]() {
    return this
  }
  /**
   * Read an actors snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot
  }
}
function createActor(logic, ...[options]) {
  return new Actor(logic, options)
}
function resolveCancel(_, snapshot, actionArgs, actionParams, {sendId}) {
  const resolvedSendId =
    typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId
  return [
    snapshot,
    {
      sendId: resolvedSendId,
    },
    void 0,
  ]
}
function executeCancel(actorScope, params) {
  actorScope.defer(() => {
    actorScope.system.scheduler.cancel(actorScope.self, params.sendId)
  })
}
function cancel(sendId) {
  function cancel2(_args, _params) {}
  cancel2.type = 'xstate.cancel'
  cancel2.sendId = sendId
  cancel2.resolve = resolveCancel
  cancel2.execute = executeCancel
  return cancel2
}
function resolveSpawn(
  actorScope,
  snapshot,
  actionArgs,
  _actionParams,
  {id, systemId, src, input, syncSnapshot},
) {
  const logic =
    typeof src === 'string'
      ? resolveReferencedActor(snapshot.machine, src)
      : src
  const resolvedId = typeof id === 'function' ? id(actionArgs) : id
  let actorRef
  let resolvedInput = void 0
  if (logic) {
    resolvedInput =
      typeof input === 'function'
        ? input({
            context: snapshot.context,
            event: actionArgs.event,
            self: actorScope.self,
          })
        : input
    actorRef = createActor(logic, {
      id: resolvedId,
      src,
      parent: actorScope.self,
      syncSnapshot,
      systemId,
      input: resolvedInput,
    })
  }
  return [
    cloneMachineSnapshot(snapshot, {
      children: {
        ...snapshot.children,
        [resolvedId]: actorRef,
      },
    }),
    {
      id,
      systemId,
      actorRef,
      src,
      input: resolvedInput,
    },
    void 0,
  ]
}
function executeSpawn(actorScope, {actorRef}) {
  if (!actorRef) {
    return
  }
  actorScope.defer(() => {
    if (actorRef._processingStatus === ProcessingStatus.Stopped) {
      return
    }
    actorRef.start()
  })
}
function spawnChild(
  ...[src, {id, systemId, input, syncSnapshot = false} = {}]
) {
  function spawnChild2(_args, _params) {}
  spawnChild2.type = 'xstate.spawnChild'
  spawnChild2.id = id
  spawnChild2.systemId = systemId
  spawnChild2.src = src
  spawnChild2.input = input
  spawnChild2.syncSnapshot = syncSnapshot
  spawnChild2.resolve = resolveSpawn
  spawnChild2.execute = executeSpawn
  return spawnChild2
}
function resolveStop(_, snapshot, args, actionParams, {actorRef}) {
  const actorRefOrString =
    typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef
  const resolvedActorRef =
    typeof actorRefOrString === 'string'
      ? snapshot.children[actorRefOrString]
      : actorRefOrString
  let children = snapshot.children
  if (resolvedActorRef) {
    children = {
      ...children,
    }
    delete children[resolvedActorRef.id]
  }
  return [
    cloneMachineSnapshot(snapshot, {
      children,
    }),
    resolvedActorRef,
    void 0,
  ]
}
function executeStop(actorScope, actorRef) {
  if (!actorRef) {
    return
  }
  actorScope.system._unregister(actorRef)
  if (actorRef._processingStatus !== ProcessingStatus.Running) {
    actorScope.stopChild(actorRef)
    return
  }
  actorScope.defer(() => {
    actorScope.stopChild(actorRef)
  })
}
function stopChild(actorRef) {
  function stop(_args, _params) {}
  stop.type = 'xstate.stopChild'
  stop.actorRef = actorRef
  stop.resolve = resolveStop
  stop.execute = executeStop
  return stop
}
function evaluateGuard(guard, context, event, snapshot) {
  const {machine} = snapshot
  const isInline = typeof guard === 'function'
  const resolved = isInline
    ? guard
    : machine.implementations.guards[
        typeof guard === 'string' ? guard : guard.type
      ]
  if (!isInline && !resolved) {
    throw new Error(
      `Guard '${
        typeof guard === 'string' ? guard : guard.type
      }' is not implemented.'.`,
    )
  }
  if (typeof resolved !== 'function') {
    return evaluateGuard(resolved, context, event, snapshot)
  }
  const guardArgs = {
    context,
    event,
  }
  const guardParams =
    isInline || typeof guard === 'string'
      ? void 0
      : 'params' in guard
      ? typeof guard.params === 'function'
        ? guard.params({
            context,
            event,
          })
        : guard.params
      : void 0
  if (!('check' in resolved)) {
    return resolved(guardArgs, guardParams)
  }
  const builtinGuard = resolved
  return builtinGuard.check(
    snapshot,
    guardArgs,
    resolved,
    // this holds all params
  )
}
const isAtomicStateNode = (stateNode) =>
  stateNode.type === 'atomic' || stateNode.type === 'final'
function getChildren(stateNode) {
  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history')
}
function getProperAncestors(stateNode, toStateNode) {
  const ancestors = []
  if (toStateNode === stateNode) {
    return ancestors
  }
  let m = stateNode.parent
  while (m && m !== toStateNode) {
    ancestors.push(m)
    m = m.parent
  }
  return ancestors
}
function getAllStateNodes(stateNodes) {
  const nodeSet = new Set(stateNodes)
  const adjList = getAdjList(nodeSet)
  for (const s of nodeSet) {
    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
      getInitialStateNodesWithTheirAncestors(s).forEach((sn) => nodeSet.add(sn))
    } else {
      if (s.type === 'parallel') {
        for (const child of getChildren(s)) {
          if (child.type === 'history') {
            continue
          }
          if (!nodeSet.has(child)) {
            const initialStates = getInitialStateNodesWithTheirAncestors(child)
            for (const initialStateNode of initialStates) {
              nodeSet.add(initialStateNode)
            }
          }
        }
      }
    }
  }
  for (const s of nodeSet) {
    let m = s.parent
    while (m) {
      nodeSet.add(m)
      m = m.parent
    }
  }
  return nodeSet
}
function getValueFromAdj(baseNode, adjList) {
  const childStateNodes = adjList.get(baseNode)
  if (!childStateNodes) {
    return {}
  }
  if (baseNode.type === 'compound') {
    const childStateNode = childStateNodes[0]
    if (childStateNode) {
      if (isAtomicStateNode(childStateNode)) {
        return childStateNode.key
      }
    } else {
      return {}
    }
  }
  const stateValue = {}
  for (const childStateNode of childStateNodes) {
    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList)
  }
  return stateValue
}
function getAdjList(stateNodes) {
  const adjList = /* @__PURE__ */ new Map()
  for (const s of stateNodes) {
    if (!adjList.has(s)) {
      adjList.set(s, [])
    }
    if (s.parent) {
      if (!adjList.has(s.parent)) {
        adjList.set(s.parent, [])
      }
      adjList.get(s.parent).push(s)
    }
  }
  return adjList
}
function getStateValue(rootNode, stateNodes) {
  const config = getAllStateNodes(stateNodes)
  return getValueFromAdj(rootNode, getAdjList(config))
}
function isInFinalState(stateNodeSet, stateNode) {
  if (stateNode.type === 'compound') {
    return getChildren(stateNode).some(
      (s) => s.type === 'final' && stateNodeSet.has(s),
    )
  }
  if (stateNode.type === 'parallel') {
    return getChildren(stateNode).every((sn) =>
      isInFinalState(stateNodeSet, sn),
    )
  }
  return stateNode.type === 'final'
}
const isStateId = (str) => str[0] === STATE_IDENTIFIER$1
function getCandidates(stateNode, receivedEventType) {
  const candidates =
    stateNode.transitions.get(receivedEventType) ||
    [...stateNode.transitions.keys()]
      .filter((eventDescriptor) => {
        if (eventDescriptor === WILDCARD) {
          return true
        }
        if (!eventDescriptor.endsWith('.*')) {
          return false
        }
        const partialEventTokens = eventDescriptor.split('.')
        const eventTokens = receivedEventType.split('.')
        for (
          let tokenIndex = 0;
          tokenIndex < partialEventTokens.length;
          tokenIndex++
        ) {
          const partialEventToken = partialEventTokens[tokenIndex]
          const eventToken = eventTokens[tokenIndex]
          if (partialEventToken === '*') {
            const isLastToken = tokenIndex === partialEventTokens.length - 1
            return isLastToken
          }
          if (partialEventToken !== eventToken) {
            return false
          }
        }
        return true
      })
      .sort((a, b) => b.length - a.length)
      .flatMap((key) => stateNode.transitions.get(key))
  return candidates
}
function getDelayedTransitions(stateNode) {
  const afterConfig = stateNode.config.after
  if (!afterConfig) {
    return []
  }
  const mutateEntryExit = (delay) => {
    const afterEvent = createAfterEvent(delay, stateNode.id)
    const eventType = afterEvent.type
    stateNode.entry.push(
      raise(afterEvent, {
        id: eventType,
        delay,
      }),
    )
    stateNode.exit.push(cancel(eventType))
    return eventType
  }
  const delayedTransitions = Object.keys(afterConfig).flatMap((delay) => {
    const configTransition = afterConfig[delay]
    const resolvedTransition =
      typeof configTransition === 'string'
        ? {
            target: configTransition,
          }
        : configTransition
    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay
    const eventType = mutateEntryExit(resolvedDelay)
    return toArray(resolvedTransition).map((transition) => ({
      ...transition,
      event: eventType,
      delay: resolvedDelay,
    }))
  })
  return delayedTransitions.map((delayedTransition) => {
    const {delay} = delayedTransition
    return {
      ...formatTransition(
        stateNode,
        delayedTransition.event,
        delayedTransition,
      ),
      delay,
    }
  })
}
function formatTransition(stateNode, descriptor, transitionConfig) {
  const normalizedTarget = normalizeTarget(transitionConfig.target)
  const reenter = transitionConfig.reenter ?? false
  const target = resolveTarget(stateNode, normalizedTarget)
  const transition = {
    ...transitionConfig,
    actions: toArray(transitionConfig.actions),
    guard: transitionConfig.guard,
    target,
    source: stateNode,
    reenter,
    eventType: descriptor,
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: target ? target.map((t) => `#${t.id}`) : void 0,
    }),
  }
  return transition
}
function formatTransitions(stateNode) {
  const transitions = /* @__PURE__ */ new Map()
  if (stateNode.config.on) {
    for (const descriptor of Object.keys(stateNode.config.on)) {
      if (descriptor === NULL_EVENT) {
        throw new Error(
          'Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.',
        )
      }
      const transitionsConfig = stateNode.config.on[descriptor]
      transitions.set(
        descriptor,
        toTransitionConfigArray(transitionsConfig).map((t) =>
          formatTransition(stateNode, descriptor, t),
        ),
      )
    }
  }
  if (stateNode.config.onDone) {
    const descriptor = `xstate.done.state.${stateNode.id}`
    transitions.set(
      descriptor,
      toTransitionConfigArray(stateNode.config.onDone).map((t) =>
        formatTransition(stateNode, descriptor, t),
      ),
    )
  }
  for (const invokeDef of stateNode.invoke) {
    if (invokeDef.onDone) {
      const descriptor = `xstate.done.actor.${invokeDef.id}`
      transitions.set(
        descriptor,
        toTransitionConfigArray(invokeDef.onDone).map((t) =>
          formatTransition(stateNode, descriptor, t),
        ),
      )
    }
    if (invokeDef.onError) {
      const descriptor = `xstate.error.actor.${invokeDef.id}`
      transitions.set(
        descriptor,
        toTransitionConfigArray(invokeDef.onError).map((t) =>
          formatTransition(stateNode, descriptor, t),
        ),
      )
    }
    if (invokeDef.onSnapshot) {
      const descriptor = `xstate.snapshot.${invokeDef.id}`
      transitions.set(
        descriptor,
        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>
          formatTransition(stateNode, descriptor, t),
        ),
      )
    }
  }
  for (const delayedTransition of stateNode.after) {
    let existing = transitions.get(delayedTransition.eventType)
    if (!existing) {
      existing = []
      transitions.set(delayedTransition.eventType, existing)
    }
    existing.push(delayedTransition)
  }
  return transitions
}
function formatInitialTransition(stateNode, _target) {
  const resolvedTarget =
    typeof _target === 'string'
      ? stateNode.states[_target]
      : _target
      ? stateNode.states[_target.target]
      : void 0
  if (!resolvedTarget && _target) {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
      `Initial state node "${_target}" not found on parent state node #${stateNode.id}`,
    )
  }
  const transition = {
    source: stateNode,
    actions:
      !_target || typeof _target === 'string' ? [] : toArray(_target.actions),
    eventType: null,
    reenter: false,
    target: resolvedTarget ? [resolvedTarget] : [],
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: resolvedTarget ? [`#${resolvedTarget.id}`] : [],
    }),
  }
  return transition
}
function resolveTarget(stateNode, targets) {
  if (targets === void 0) {
    return void 0
  }
  return targets.map((target) => {
    if (typeof target !== 'string') {
      return target
    }
    if (isStateId(target)) {
      return stateNode.machine.getStateNodeById(target)
    }
    const isInternalTarget = target[0] === STATE_DELIMITER
    if (isInternalTarget && !stateNode.parent) {
      return getStateNodeByPath(stateNode, target.slice(1))
    }
    const resolvedTarget = isInternalTarget ? stateNode.key + target : target
    if (stateNode.parent) {
      try {
        const targetStateNode = getStateNodeByPath(
          stateNode.parent,
          resolvedTarget,
        )
        return targetStateNode
      } catch (err) {
        throw new Error(`Invalid transition definition for state node '${stateNode.id}':
${err.message}`)
      }
    } else {
      throw new Error(
        `Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`,
      )
    }
  })
}
function resolveHistoryDefaultTransition(stateNode) {
  const normalizedTarget = normalizeTarget(stateNode.config.target)
  if (!normalizedTarget) {
    return stateNode.parent.initial
  }
  return {
    target: normalizedTarget.map((t) =>
      typeof t === 'string' ? getStateNodeByPath(stateNode.parent, t) : t,
    ),
  }
}
function isHistoryNode(stateNode) {
  return stateNode.type === 'history'
}
function getInitialStateNodesWithTheirAncestors(stateNode) {
  const states = getInitialStateNodes(stateNode)
  for (const initialState of states) {
    for (const ancestor of getProperAncestors(initialState, stateNode)) {
      states.add(ancestor)
    }
  }
  return states
}
function getInitialStateNodes(stateNode) {
  const set = /* @__PURE__ */ new Set()
  function iter(descStateNode) {
    if (set.has(descStateNode)) {
      return
    }
    set.add(descStateNode)
    if (descStateNode.type === 'compound') {
      iter(descStateNode.initial.target[0])
    } else if (descStateNode.type === 'parallel') {
      for (const child of getChildren(descStateNode)) {
        iter(child)
      }
    }
  }
  iter(stateNode)
  return set
}
function getStateNode(stateNode, stateKey) {
  if (isStateId(stateKey)) {
    return stateNode.machine.getStateNodeById(stateKey)
  }
  if (!stateNode.states) {
    throw new Error(
      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`,
    )
  }
  const result = stateNode.states[stateKey]
  if (!result) {
    throw new Error(
      `Child state '${stateKey}' does not exist on '${stateNode.id}'`,
    )
  }
  return result
}
function getStateNodeByPath(stateNode, statePath) {
  if (typeof statePath === 'string' && isStateId(statePath)) {
    try {
      return stateNode.machine.getStateNodeById(statePath)
    } catch {}
  }
  const arrayStatePath = toStatePath(statePath).slice()
  let currentStateNode = stateNode
  while (arrayStatePath.length) {
    const key = arrayStatePath.shift()
    if (!key.length) {
      break
    }
    currentStateNode = getStateNode(currentStateNode, key)
  }
  return currentStateNode
}
function getStateNodes(stateNode, stateValue) {
  if (typeof stateValue === 'string') {
    const childStateNode = stateNode.states[stateValue]
    if (!childStateNode) {
      throw new Error(
        `State '${stateValue}' does not exist on '${stateNode.id}'`,
      )
    }
    return [stateNode, childStateNode]
  }
  const childStateKeys = Object.keys(stateValue)
  const childStateNodes = childStateKeys
    .map((subStateKey) => getStateNode(stateNode, subStateKey))
    .filter(Boolean)
  return [stateNode.machine.root, stateNode].concat(
    childStateNodes,
    childStateKeys.reduce((allSubStateNodes, subStateKey) => {
      const subStateNode = getStateNode(stateNode, subStateKey)
      if (!subStateNode) {
        return allSubStateNodes
      }
      const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey])
      return allSubStateNodes.concat(subStateNodes)
    }, []),
  )
}
function transitionAtomicNode(stateNode, stateValue, snapshot, event) {
  const childStateNode = getStateNode(stateNode, stateValue)
  const next = childStateNode.next(snapshot, event)
  if (!next || !next.length) {
    return stateNode.next(snapshot, event)
  }
  return next
}
function transitionCompoundNode(stateNode, stateValue, snapshot, event) {
  const subStateKeys = Object.keys(stateValue)
  const childStateNode = getStateNode(stateNode, subStateKeys[0])
  const next = transitionNode(
    childStateNode,
    stateValue[subStateKeys[0]],
    snapshot,
    event,
  )
  if (!next || !next.length) {
    return stateNode.next(snapshot, event)
  }
  return next
}
function transitionParallelNode(stateNode, stateValue, snapshot, event) {
  const allInnerTransitions = []
  for (const subStateKey of Object.keys(stateValue)) {
    const subStateValue = stateValue[subStateKey]
    if (!subStateValue) {
      continue
    }
    const subStateNode = getStateNode(stateNode, subStateKey)
    const innerTransitions = transitionNode(
      subStateNode,
      subStateValue,
      snapshot,
      event,
    )
    if (innerTransitions) {
      allInnerTransitions.push(...innerTransitions)
    }
  }
  if (!allInnerTransitions.length) {
    return stateNode.next(snapshot, event)
  }
  return allInnerTransitions
}
function transitionNode(stateNode, stateValue, snapshot, event) {
  if (typeof stateValue === 'string') {
    return transitionAtomicNode(stateNode, stateValue, snapshot, event)
  }
  if (Object.keys(stateValue).length === 1) {
    return transitionCompoundNode(stateNode, stateValue, snapshot, event)
  }
  return transitionParallelNode(stateNode, stateValue, snapshot, event)
}
function getHistoryNodes(stateNode) {
  return Object.keys(stateNode.states)
    .map((key) => stateNode.states[key])
    .filter((sn) => sn.type === 'history')
}
function isDescendant(childStateNode, parentStateNode) {
  let marker = childStateNode
  while (marker.parent && marker.parent !== parentStateNode) {
    marker = marker.parent
  }
  return marker.parent === parentStateNode
}
function hasIntersection(s1, s2) {
  const set1 = new Set(s1)
  const set2 = new Set(s2)
  for (const item of set1) {
    if (set2.has(item)) {
      return true
    }
  }
  for (const item of set2) {
    if (set1.has(item)) {
      return true
    }
  }
  return false
}
function removeConflictingTransitions(
  enabledTransitions,
  stateNodeSet,
  historyValue,
) {
  const filteredTransitions = /* @__PURE__ */ new Set()
  for (const t1 of enabledTransitions) {
    let t1Preempted = false
    const transitionsToRemove = /* @__PURE__ */ new Set()
    for (const t2 of filteredTransitions) {
      if (
        hasIntersection(
          computeExitSet([t1], stateNodeSet, historyValue),
          computeExitSet([t2], stateNodeSet, historyValue),
        )
      ) {
        if (isDescendant(t1.source, t2.source)) {
          transitionsToRemove.add(t2)
        } else {
          t1Preempted = true
          break
        }
      }
    }
    if (!t1Preempted) {
      for (const t3 of transitionsToRemove) {
        filteredTransitions.delete(t3)
      }
      filteredTransitions.add(t1)
    }
  }
  return Array.from(filteredTransitions)
}
function findLeastCommonAncestor(stateNodes) {
  const [head, ...tail] = stateNodes
  for (const ancestor of getProperAncestors(head, void 0)) {
    if (tail.every((sn) => isDescendant(sn, ancestor))) {
      return ancestor
    }
  }
}
function getEffectiveTargetStates(transition, historyValue) {
  if (!transition.target) {
    return []
  }
  const targets = /* @__PURE__ */ new Set()
  for (const targetNode of transition.target) {
    if (isHistoryNode(targetNode)) {
      if (historyValue[targetNode.id]) {
        for (const node of historyValue[targetNode.id]) {
          targets.add(node)
        }
      } else {
        for (const node of getEffectiveTargetStates(
          resolveHistoryDefaultTransition(targetNode),
          historyValue,
        )) {
          targets.add(node)
        }
      }
    } else {
      targets.add(targetNode)
    }
  }
  return [...targets]
}
function getTransitionDomain(transition, historyValue) {
  const targetStates = getEffectiveTargetStates(transition, historyValue)
  if (!targetStates) {
    return
  }
  if (
    !transition.reenter &&
    targetStates.every(
      (target) =>
        target === transition.source || isDescendant(target, transition.source),
    )
  ) {
    return transition.source
  }
  const lca = findLeastCommonAncestor(targetStates.concat(transition.source))
  if (lca) {
    return lca
  }
  if (transition.reenter) {
    return
  }
  return transition.source.machine.root
}
function computeExitSet(transitions, stateNodeSet, historyValue) {
  const statesToExit = /* @__PURE__ */ new Set()
  for (const t of transitions) {
    if (t.target?.length) {
      const domain = getTransitionDomain(t, historyValue)
      if (t.reenter && t.source === domain) {
        statesToExit.add(domain)
      }
      for (const stateNode of stateNodeSet) {
        if (isDescendant(stateNode, domain)) {
          statesToExit.add(stateNode)
        }
      }
    }
  }
  return [...statesToExit]
}
function areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {
  if (prevStateNodes.length !== nextStateNodeSet.size) {
    return false
  }
  for (const node of prevStateNodes) {
    if (!nextStateNodeSet.has(node)) {
      return false
    }
  }
  return true
}
function microstep(
  transitions,
  currentSnapshot,
  actorScope,
  event,
  isInitial,
  internalQueue,
) {
  if (!transitions.length) {
    return currentSnapshot
  }
  const mutStateNodeSet = new Set(currentSnapshot._nodes)
  let historyValue = currentSnapshot.historyValue
  const filteredTransitions = removeConflictingTransitions(
    transitions,
    mutStateNodeSet,
    historyValue,
  )
  let nextState = currentSnapshot
  if (!isInitial) {
    ;[nextState, historyValue] = exitStates(
      nextState,
      event,
      actorScope,
      filteredTransitions,
      mutStateNodeSet,
      historyValue,
      internalQueue,
      actorScope.actionExecutor,
    )
  }
  nextState = resolveActionsAndContext(
    nextState,
    event,
    actorScope,
    filteredTransitions.flatMap((t) => t.actions),
    internalQueue,
    void 0,
  )
  nextState = enterStates(
    nextState,
    event,
    actorScope,
    filteredTransitions,
    mutStateNodeSet,
    internalQueue,
    historyValue,
    isInitial,
  )
  const nextStateNodes = [...mutStateNodeSet]
  if (nextState.status === 'done') {
    nextState = resolveActionsAndContext(
      nextState,
      event,
      actorScope,
      nextStateNodes
        .sort((a, b) => b.order - a.order)
        .flatMap((state) => state.exit),
      internalQueue,
      void 0,
    )
  }
  try {
    if (
      historyValue === currentSnapshot.historyValue &&
      areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)
    ) {
      return nextState
    }
    return cloneMachineSnapshot(nextState, {
      _nodes: nextStateNodes,
      historyValue,
    })
  } catch (e) {
    throw e
  }
}
function getMachineOutput(
  snapshot,
  event,
  actorScope,
  rootNode,
  rootCompletionNode,
) {
  if (rootNode.output === void 0) {
    return
  }
  const doneStateEvent = createDoneStateEvent(
    rootCompletionNode.id,
    rootCompletionNode.output !== void 0 && rootCompletionNode.parent
      ? resolveOutput(
          rootCompletionNode.output,
          snapshot.context,
          event,
          actorScope.self,
        )
      : void 0,
  )
  return resolveOutput(
    rootNode.output,
    snapshot.context,
    doneStateEvent,
    actorScope.self,
  )
}
function enterStates(
  currentSnapshot,
  event,
  actorScope,
  filteredTransitions,
  mutStateNodeSet,
  internalQueue,
  historyValue,
  isInitial,
) {
  let nextSnapshot = currentSnapshot
  const statesToEnter = /* @__PURE__ */ new Set()
  const statesForDefaultEntry = /* @__PURE__ */ new Set()
  computeEntrySet(
    filteredTransitions,
    historyValue,
    statesForDefaultEntry,
    statesToEnter,
  )
  if (isInitial) {
    statesForDefaultEntry.add(currentSnapshot.machine.root)
  }
  const completedNodes = /* @__PURE__ */ new Set()
  for (const stateNodeToEnter of [...statesToEnter].sort(
    (a, b) => a.order - b.order,
  )) {
    mutStateNodeSet.add(stateNodeToEnter)
    const actions = []
    actions.push(...stateNodeToEnter.entry)
    for (const invokeDef of stateNodeToEnter.invoke) {
      actions.push(
        spawnChild(invokeDef.src, {
          ...invokeDef,
          syncSnapshot: !!invokeDef.onSnapshot,
        }),
      )
    }
    if (statesForDefaultEntry.has(stateNodeToEnter)) {
      const initialActions = stateNodeToEnter.initial.actions
      actions.push(...initialActions)
    }
    nextSnapshot = resolveActionsAndContext(
      nextSnapshot,
      event,
      actorScope,
      actions,
      internalQueue,
      stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id),
    )
    if (stateNodeToEnter.type === 'final') {
      const parent = stateNodeToEnter.parent
      let ancestorMarker = parent?.type === 'parallel' ? parent : parent?.parent
      let rootCompletionNode = ancestorMarker || stateNodeToEnter
      if (parent?.type === 'compound') {
        internalQueue.push(
          createDoneStateEvent(
            parent.id,
            stateNodeToEnter.output !== void 0
              ? resolveOutput(
                  stateNodeToEnter.output,
                  nextSnapshot.context,
                  event,
                  actorScope.self,
                )
              : void 0,
          ),
        )
      }
      while (
        ancestorMarker?.type === 'parallel' &&
        !completedNodes.has(ancestorMarker) &&
        isInFinalState(mutStateNodeSet, ancestorMarker)
      ) {
        completedNodes.add(ancestorMarker)
        internalQueue.push(createDoneStateEvent(ancestorMarker.id))
        rootCompletionNode = ancestorMarker
        ancestorMarker = ancestorMarker.parent
      }
      if (ancestorMarker) {
        continue
      }
      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {
        status: 'done',
        output: getMachineOutput(
          nextSnapshot,
          event,
          actorScope,
          nextSnapshot.machine.root,
          rootCompletionNode,
        ),
      })
    }
  }
  return nextSnapshot
}
function computeEntrySet(
  transitions,
  historyValue,
  statesForDefaultEntry,
  statesToEnter,
) {
  for (const t of transitions) {
    const domain = getTransitionDomain(t, historyValue)
    for (const s of t.target || []) {
      if (
        !isHistoryNode(s) && // if the target is different than the source then it will *definitely* be entered
        (t.source !== s || // we know that the domain can't lie within the source
          // if it's different than the source then it's outside of it and it means that the target has to be entered as well
          t.source !== domain || // reentering transitions always enter the target, even if it's the source itself
          t.reenter)
      ) {
        statesToEnter.add(s)
        statesForDefaultEntry.add(s)
      }
      addDescendantStatesToEnter(
        s,
        historyValue,
        statesForDefaultEntry,
        statesToEnter,
      )
    }
    const targetStates = getEffectiveTargetStates(t, historyValue)
    for (const s of targetStates) {
      const ancestors = getProperAncestors(s, domain)
      if (domain?.type === 'parallel') {
        ancestors.push(domain)
      }
      addAncestorStatesToEnter(
        statesToEnter,
        historyValue,
        statesForDefaultEntry,
        ancestors,
        !t.source.parent && t.reenter ? void 0 : domain,
      )
    }
  }
}
function addDescendantStatesToEnter(
  stateNode,
  historyValue,
  statesForDefaultEntry,
  statesToEnter,
) {
  if (isHistoryNode(stateNode)) {
    if (historyValue[stateNode.id]) {
      const historyStateNodes = historyValue[stateNode.id]
      for (const s of historyStateNodes) {
        statesToEnter.add(s)
        addDescendantStatesToEnter(
          s,
          historyValue,
          statesForDefaultEntry,
          statesToEnter,
        )
      }
      for (const s of historyStateNodes) {
        addProperAncestorStatesToEnter(
          s,
          stateNode.parent,
          statesToEnter,
          historyValue,
          statesForDefaultEntry,
        )
      }
    } else {
      const historyDefaultTransition =
        resolveHistoryDefaultTransition(stateNode)
      for (const s of historyDefaultTransition.target) {
        statesToEnter.add(s)
        if (historyDefaultTransition === stateNode.parent?.initial) {
          statesForDefaultEntry.add(stateNode.parent)
        }
        addDescendantStatesToEnter(
          s,
          historyValue,
          statesForDefaultEntry,
          statesToEnter,
        )
      }
      for (const s of historyDefaultTransition.target) {
        addProperAncestorStatesToEnter(
          s,
          stateNode.parent,
          statesToEnter,
          historyValue,
          statesForDefaultEntry,
        )
      }
    }
  } else {
    if (stateNode.type === 'compound') {
      const [initialState] = stateNode.initial.target
      if (!isHistoryNode(initialState)) {
        statesToEnter.add(initialState)
        statesForDefaultEntry.add(initialState)
      }
      addDescendantStatesToEnter(
        initialState,
        historyValue,
        statesForDefaultEntry,
        statesToEnter,
      )
      addProperAncestorStatesToEnter(
        initialState,
        stateNode,
        statesToEnter,
        historyValue,
        statesForDefaultEntry,
      )
    } else {
      if (stateNode.type === 'parallel') {
        for (const child of getChildren(stateNode).filter(
          (sn) => !isHistoryNode(sn),
        )) {
          if (![...statesToEnter].some((s) => isDescendant(s, child))) {
            if (!isHistoryNode(child)) {
              statesToEnter.add(child)
              statesForDefaultEntry.add(child)
            }
            addDescendantStatesToEnter(
              child,
              historyValue,
              statesForDefaultEntry,
              statesToEnter,
            )
          }
        }
      }
    }
  }
}
function addAncestorStatesToEnter(
  statesToEnter,
  historyValue,
  statesForDefaultEntry,
  ancestors,
  reentrancyDomain,
) {
  for (const anc of ancestors) {
    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {
      statesToEnter.add(anc)
    }
    if (anc.type === 'parallel') {
      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {
        if (![...statesToEnter].some((s) => isDescendant(s, child))) {
          statesToEnter.add(child)
          addDescendantStatesToEnter(
            child,
            historyValue,
            statesForDefaultEntry,
            statesToEnter,
          )
        }
      }
    }
  }
}
function addProperAncestorStatesToEnter(
  stateNode,
  toStateNode,
  statesToEnter,
  historyValue,
  statesForDefaultEntry,
) {
  addAncestorStatesToEnter(
    statesToEnter,
    historyValue,
    statesForDefaultEntry,
    getProperAncestors(stateNode, toStateNode),
  )
}
function exitStates(
  currentSnapshot,
  event,
  actorScope,
  transitions,
  mutStateNodeSet,
  historyValue,
  internalQueue,
  _actionExecutor,
) {
  let nextSnapshot = currentSnapshot
  const statesToExit = computeExitSet(
    transitions,
    mutStateNodeSet,
    historyValue,
  )
  statesToExit.sort((a, b) => b.order - a.order)
  let changedHistory
  for (const exitStateNode of statesToExit) {
    for (const historyNode of getHistoryNodes(exitStateNode)) {
      let predicate
      if (historyNode.history === 'deep') {
        predicate = (sn) =>
          isAtomicStateNode(sn) && isDescendant(sn, exitStateNode)
      } else {
        predicate = (sn) => {
          return sn.parent === exitStateNode
        }
      }
      changedHistory ??= {
        ...historyValue,
      }
      changedHistory[historyNode.id] =
        Array.from(mutStateNodeSet).filter(predicate)
    }
  }
  for (const s of statesToExit) {
    nextSnapshot = resolveActionsAndContext(
      nextSnapshot,
      event,
      actorScope,
      [...s.exit, ...s.invoke.map((def) => stopChild(def.id))],
      internalQueue,
      void 0,
    )
    mutStateNodeSet.delete(s)
  }
  return [nextSnapshot, changedHistory || historyValue]
}
function getAction(machine, actionType) {
  return machine.implementations.actions[actionType]
}
function resolveAndExecuteActionsWithContext(
  currentSnapshot,
  event,
  actorScope,
  actions,
  extra,
  retries,
) {
  const {machine} = currentSnapshot
  let intermediateSnapshot = currentSnapshot
  for (const action of actions) {
    const isInline = typeof action === 'function'
    const resolvedAction = isInline
      ? action
      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`
        // it's fine to cast this here to get a common type and lack of errors in the rest of the code
        // our logic below makes sure that we call those 2 "variants" correctly
        getAction(machine, typeof action === 'string' ? action : action.type)
    const actionArgs = {
      context: intermediateSnapshot.context,
      event,
      self: actorScope.self,
      system: actorScope.system,
    }
    const actionParams =
      isInline || typeof action === 'string'
        ? void 0
        : 'params' in action
        ? typeof action.params === 'function'
          ? action.params({
              context: intermediateSnapshot.context,
              event,
            })
          : action.params
        : void 0
    if (!resolvedAction || !('resolve' in resolvedAction)) {
      actorScope.actionExecutor({
        type:
          typeof action === 'string'
            ? action
            : typeof action === 'object'
            ? action.type
            : action.name || '(anonymous)',
        info: actionArgs,
        params: actionParams,
        exec: resolvedAction,
      })
      continue
    }
    const builtinAction = resolvedAction
    const [nextState, params, actions2] = builtinAction.resolve(
      actorScope,
      intermediateSnapshot,
      actionArgs,
      actionParams,
      resolvedAction,
      // this holds all params
      extra,
    )
    intermediateSnapshot = nextState
    if ('retryResolve' in builtinAction) {
      retries?.push([builtinAction, params])
    }
    if ('execute' in builtinAction) {
      actorScope.actionExecutor({
        type: builtinAction.type,
        info: actionArgs,
        params,
        exec: builtinAction.execute.bind(null, actorScope, params),
      })
    }
    if (actions2) {
      intermediateSnapshot = resolveAndExecuteActionsWithContext(
        intermediateSnapshot,
        event,
        actorScope,
        actions2,
        extra,
        retries,
      )
    }
  }
  return intermediateSnapshot
}
function resolveActionsAndContext(
  currentSnapshot,
  event,
  actorScope,
  actions,
  internalQueue,
  deferredActorIds,
) {
  const retries = deferredActorIds ? [] : void 0
  const nextState = resolveAndExecuteActionsWithContext(
    currentSnapshot,
    event,
    actorScope,
    actions,
    {
      internalQueue,
      deferredActorIds,
    },
    retries,
  )
  retries?.forEach(([builtinAction, params]) => {
    builtinAction.retryResolve(actorScope, nextState, params)
  })
  return nextState
}
function macrostep(snapshot, event, actorScope, internalQueue) {
  let nextSnapshot = snapshot
  const microstates = []
  function addMicrostate(microstate, event2, transitions) {
    actorScope.system._sendInspectionEvent({
      type: '@xstate.microstep',
      actorRef: actorScope.self,
      event: event2,
      snapshot: microstate,
      _transitions: transitions,
    })
    microstates.push(microstate)
  }
  if (event.type === XSTATE_STOP) {
    nextSnapshot = cloneMachineSnapshot(
      stopChildren(nextSnapshot, event, actorScope),
      {
        status: 'stopped',
      },
    )
    addMicrostate(nextSnapshot, event, [])
    return {
      snapshot: nextSnapshot,
      microstates,
    }
  }
  let nextEvent = event
  if (nextEvent.type !== XSTATE_INIT) {
    const currentEvent = nextEvent
    const isErr = isErrorActorEvent(currentEvent)
    const transitions = selectTransitions(currentEvent, nextSnapshot)
    if (isErr && !transitions.length) {
      nextSnapshot = cloneMachineSnapshot(snapshot, {
        status: 'error',
        error: currentEvent.error,
      })
      addMicrostate(nextSnapshot, currentEvent, [])
      return {
        snapshot: nextSnapshot,
        microstates,
      }
    }
    nextSnapshot = microstep(
      transitions,
      snapshot,
      actorScope,
      nextEvent,
      false,
      // isInitial
      internalQueue,
    )
    addMicrostate(nextSnapshot, currentEvent, transitions)
  }
  let shouldSelectEventlessTransitions = true
  while (nextSnapshot.status === 'active') {
    let enabledTransitions = shouldSelectEventlessTransitions
      ? selectEventlessTransitions(nextSnapshot, nextEvent)
      : []
    const previousState = enabledTransitions.length ? nextSnapshot : void 0
    if (!enabledTransitions.length) {
      if (!internalQueue.length) {
        break
      }
      nextEvent = internalQueue.shift()
      enabledTransitions = selectTransitions(nextEvent, nextSnapshot)
    }
    nextSnapshot = microstep(
      enabledTransitions,
      nextSnapshot,
      actorScope,
      nextEvent,
      false,
      internalQueue,
    )
    shouldSelectEventlessTransitions = nextSnapshot !== previousState
    addMicrostate(nextSnapshot, nextEvent, enabledTransitions)
  }
  if (nextSnapshot.status !== 'active') {
    stopChildren(nextSnapshot, nextEvent, actorScope)
  }
  return {
    snapshot: nextSnapshot,
    microstates,
  }
}
function stopChildren(nextState, event, actorScope) {
  return resolveActionsAndContext(
    nextState,
    event,
    actorScope,
    Object.values(nextState.children).map((child) => stopChild(child)),
    [],
    void 0,
  )
}
function selectTransitions(event, nextState) {
  return nextState.machine.getTransitionData(nextState, event)
}
function selectEventlessTransitions(nextState, event) {
  const enabledTransitionSet = /* @__PURE__ */ new Set()
  const atomicStates = nextState._nodes.filter(isAtomicStateNode)
  for (const stateNode of atomicStates) {
    loop: for (const s of [stateNode].concat(
      getProperAncestors(stateNode, void 0),
    )) {
      if (!s.always) {
        continue
      }
      for (const transition of s.always) {
        if (
          transition.guard === void 0 ||
          evaluateGuard(transition.guard, nextState.context, event, nextState)
        ) {
          enabledTransitionSet.add(transition)
          break loop
        }
      }
    }
  }
  return removeConflictingTransitions(
    Array.from(enabledTransitionSet),
    new Set(nextState._nodes),
    nextState.historyValue,
  )
}
function resolveStateValue(rootNode, stateValue) {
  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue))
  return getStateValue(rootNode, [...allStateNodes])
}
function isMachineSnapshot(value) {
  return (
    !!value &&
    typeof value === 'object' &&
    'machine' in value &&
    'value' in value
  )
}
const machineSnapshotMatches = function matches(testValue) {
  return matchesState(testValue, this.value)
}
const machineSnapshotHasTag = function hasTag(tag) {
  return this.tags.has(tag)
}
const machineSnapshotCan = function can(event) {
  const transitionData = this.machine.getTransitionData(this, event)
  return (
    !!transitionData?.length && // Check that at least one transition is not forbidden
    transitionData.some((t) => t.target !== void 0 || t.actions.length)
  )
}
const machineSnapshotToJSON = function toJSON() {
  const {
    _nodes: nodes,
    tags,
    machine,
    getMeta: getMeta2,
    toJSON: toJSON2,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    ...jsonValues
  } = this
  return {
    ...jsonValues,
    tags: Array.from(tags),
  }
}
const machineSnapshotGetMeta = function getMeta() {
  return this._nodes.reduce((acc, stateNode) => {
    if (stateNode.meta !== void 0) {
      acc[stateNode.id] = stateNode.meta
    }
    return acc
  }, {})
}
function createMachineSnapshot(config, machine) {
  return {
    status: config.status,
    output: config.output,
    error: config.error,
    machine,
    context: config.context,
    _nodes: config._nodes,
    value: getStateValue(machine.root, config._nodes),
    tags: new Set(config._nodes.flatMap((sn) => sn.tags)),
    children: config.children,
    historyValue: config.historyValue || {},
    matches: machineSnapshotMatches,
    hasTag: machineSnapshotHasTag,
    can: machineSnapshotCan,
    getMeta: machineSnapshotGetMeta,
    toJSON: machineSnapshotToJSON,
  }
}
function cloneMachineSnapshot(snapshot, config = {}) {
  return createMachineSnapshot(
    {
      ...snapshot,
      ...config,
    },
    snapshot.machine,
  )
}
function getPersistedSnapshot(snapshot, options) {
  const {
    _nodes: nodes,
    tags,
    machine,
    children,
    context,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    getMeta: getMeta2,
    toJSON: toJSON2,
    ...jsonValues
  } = snapshot
  const childrenJson = {}
  for (const id in children) {
    const child = children[id]
    childrenJson[id] = {
      snapshot: child.getPersistedSnapshot(options),
      src: child.src,
      systemId: child._systemId,
      syncSnapshot: child._syncSnapshot,
    }
  }
  const persisted = {
    ...jsonValues,
    context: persistContext(context),
    children: childrenJson,
  }
  return persisted
}
function persistContext(contextPart) {
  let copy
  for (const key in contextPart) {
    const value = contextPart[key]
    if (value && typeof value === 'object') {
      if ('sessionId' in value && 'send' in value && 'ref' in value) {
        copy ??= Array.isArray(contextPart)
          ? contextPart.slice()
          : {
              ...contextPart,
            }
        copy[key] = {
          xstate$$type: $$ACTOR_TYPE,
          id: value.id,
        }
      } else {
        const result = persistContext(value)
        if (result !== value) {
          copy ??= Array.isArray(contextPart)
            ? contextPart.slice()
            : {
                ...contextPart,
              }
          copy[key] = result
        }
      }
    }
  }
  return copy ?? contextPart
}
function resolveRaise(
  _,
  snapshot,
  args,
  actionParams,
  {event: eventOrExpr, id, delay},
  {internalQueue},
) {
  const delaysMap = snapshot.machine.implementations.delays
  if (typeof eventOrExpr === 'string') {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`,
    )
  }
  const resolvedEvent =
    typeof eventOrExpr === 'function'
      ? eventOrExpr(args, actionParams)
      : eventOrExpr
  let resolvedDelay
  if (typeof delay === 'string') {
    const configDelay = delaysMap && delaysMap[delay]
    resolvedDelay =
      typeof configDelay === 'function'
        ? configDelay(args, actionParams)
        : configDelay
  } else {
    resolvedDelay =
      typeof delay === 'function' ? delay(args, actionParams) : delay
  }
  if (typeof resolvedDelay !== 'number') {
    internalQueue.push(resolvedEvent)
  }
  return [
    snapshot,
    {
      event: resolvedEvent,
      id,
      delay: resolvedDelay,
    },
    void 0,
  ]
}
function executeRaise(actorScope, params) {
  const {event, delay, id} = params
  if (typeof delay === 'number') {
    actorScope.defer(() => {
      const self2 = actorScope.self
      actorScope.system.scheduler.schedule(self2, self2, event, delay, id)
    })
    return
  }
}
function raise(eventOrExpr, options) {
  function raise2(_args, _params) {}
  raise2.type = 'xstate.raise'
  raise2.event = eventOrExpr
  raise2.id = options?.id
  raise2.delay = options?.delay
  raise2.resolve = resolveRaise
  raise2.execute = executeRaise
  return raise2
}
function createSpawner(actorScope, {machine, context}, event, spawnedChildren) {
  const spawn = (src, options) => {
    if (typeof src === 'string') {
      const logic = resolveReferencedActor(machine, src)
      if (!logic) {
        throw new Error(
          `Actor logic '${src}' not implemented in machine '${machine.id}'`,
        )
      }
      const actorRef = createActor(logic, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input:
          typeof options?.input === 'function'
            ? options.input({
                context,
                event,
                self: actorScope.self,
              })
            : options?.input,
        src,
        systemId: options?.systemId,
      })
      spawnedChildren[actorRef.id] = actorRef
      return actorRef
    } else {
      const actorRef = createActor(src, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input: options?.input,
        src,
        systemId: options?.systemId,
      })
      return actorRef
    }
  }
  return (src, options) => {
    const actorRef = spawn(src, options)
    spawnedChildren[actorRef.id] = actorRef
    actorScope.defer(() => {
      if (actorRef._processingStatus === ProcessingStatus.Stopped) {
        return
      }
      actorRef.start()
    })
    return actorRef
  }
}
function resolveAssign(
  actorScope,
  snapshot,
  actionArgs,
  actionParams,
  {assignment},
) {
  if (!snapshot.context) {
    throw new Error(
      'Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.',
    )
  }
  const spawnedChildren = {}
  const assignArgs = {
    context: snapshot.context,
    event: actionArgs.event,
    spawn: createSpawner(
      actorScope,
      snapshot,
      actionArgs.event,
      spawnedChildren,
    ),
    self: actorScope.self,
    system: actorScope.system,
  }
  let partialUpdate = {}
  if (typeof assignment === 'function') {
    partialUpdate = assignment(assignArgs, actionParams)
  } else {
    for (const key of Object.keys(assignment)) {
      const propAssignment = assignment[key]
      partialUpdate[key] =
        typeof propAssignment === 'function'
          ? propAssignment(assignArgs, actionParams)
          : propAssignment
    }
  }
  const updatedContext = Object.assign({}, snapshot.context, partialUpdate)
  return [
    cloneMachineSnapshot(snapshot, {
      context: updatedContext,
      children: Object.keys(spawnedChildren).length
        ? {
            ...snapshot.children,
            ...spawnedChildren,
          }
        : snapshot.children,
    }),
    void 0,
    void 0,
  ]
}
function assign(assignment) {
  function assign2(_args, _params) {}
  assign2.type = 'xstate.assign'
  assign2.assignment = assignment
  assign2.resolve = resolveAssign
  return assign2
}
const cache = /* @__PURE__ */ new WeakMap()
function memo(object, key, fn) {
  let memoizedData = cache.get(object)
  if (!memoizedData) {
    memoizedData = {
      [key]: fn(),
    }
    cache.set(object, memoizedData)
  } else if (!(key in memoizedData)) {
    memoizedData[key] = fn()
  }
  return memoizedData[key]
}
const EMPTY_OBJECT = {}
const toSerializableAction = (action) => {
  if (typeof action === 'string') {
    return {
      type: action,
    }
  }
  if (typeof action === 'function') {
    if ('resolve' in action) {
      return {
        type: action.type,
      }
    }
    return {
      type: action.name,
    }
  }
  return action
}
class StateNode {
  constructor(config, options) {
    this.config = config
    this.key = void 0
    this.id = void 0
    this.type = void 0
    this.path = void 0
    this.states = void 0
    this.history = void 0
    this.entry = void 0
    this.exit = void 0
    this.parent = void 0
    this.machine = void 0
    this.meta = void 0
    this.output = void 0
    this.order = -1
    this.description = void 0
    this.tags = []
    this.transitions = void 0
    this.always = void 0
    this.parent = options._parent
    this.key = options._key
    this.machine = options._machine
    this.path = this.parent ? this.parent.path.concat(this.key) : []
    this.id =
      this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER)
    this.type =
      this.config.type ||
      (this.config.states && Object.keys(this.config.states).length
        ? 'compound'
        : this.config.history
        ? 'history'
        : 'atomic')
    this.description = this.config.description
    this.order = this.machine.idMap.size
    this.machine.idMap.set(this.id, this)
    this.states = this.config.states
      ? mapValues(this.config.states, (stateConfig, key) => {
          const stateNode = new StateNode(stateConfig, {
            _parent: this,
            _key: key,
            _machine: this.machine,
          })
          return stateNode
        })
      : EMPTY_OBJECT
    if (this.type === 'compound' && !this.config.initial) {
      throw new Error(
        `No initial state specified for compound state node "#${
          this.id
        }". Try adding { initial: "${
          Object.keys(this.states)[0]
        }" } to the state config.`,
      )
    }
    this.history =
      this.config.history === true ? 'shallow' : this.config.history || false
    this.entry = toArray(this.config.entry).slice()
    this.exit = toArray(this.config.exit).slice()
    this.meta = this.config.meta
    this.output =
      this.type === 'final' || !this.parent ? this.config.output : void 0
    this.tags = toArray(config.tags).slice()
  }
  /** @internal */
  _initialize() {
    this.transitions = formatTransitions(this)
    if (this.config.always) {
      this.always = toTransitionConfigArray(this.config.always).map((t) =>
        formatTransition(this, NULL_EVENT, t),
      )
    }
    Object.keys(this.states).forEach((key) => {
      this.states[key]._initialize()
    })
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial
        ? {
            target: this.initial.target,
            source: this,
            actions: this.initial.actions.map(toSerializableAction),
            eventType: null,
            reenter: false,
            toJSON: () => ({
              target: this.initial.target.map((t) => `#${t.id}`),
              source: `#${this.id}`,
              actions: this.initial.actions.map(toSerializableAction),
              eventType: null,
            }),
          }
        : void 0,
      history: this.history,
      states: mapValues(this.states, (state) => {
        return state.definition
      }),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((t) => ({
        ...t,
        actions: t.actions.map(toSerializableAction),
      })),
      entry: this.entry.map(toSerializableAction),
      exit: this.exit.map(toSerializableAction),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags,
    }
  }
  /** @internal */
  toJSON() {
    return this.definition
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return memo(this, 'invoke', () =>
      toArray(this.config.invoke).map((invokeConfig, i) => {
        const {src, systemId} = invokeConfig
        const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i)
        const sourceName =
          typeof src === 'string'
            ? src
            : `xstate.invoke.${createInvokeId(this.id, i)}`
        return {
          ...invokeConfig,
          src: sourceName,
          id: resolvedId,
          systemId,
          toJSON() {
            const {onDone, onError, ...invokeDefValues} = invokeConfig
            return {
              ...invokeDefValues,
              type: 'xstate.invoke',
              src: sourceName,
              id: resolvedId,
            }
          },
        }
      }),
    )
  }
  /** The mapping of events to transitions. */
  get on() {
    return memo(this, 'on', () => {
      const transitions = this.transitions
      return [...transitions]
        .flatMap(([descriptor, t]) => t.map((t2) => [descriptor, t2]))
        .reduce((map, [descriptor, transition]) => {
          map[descriptor] = map[descriptor] || []
          map[descriptor].push(transition)
          return map
        }, {})
    })
  }
  get after() {
    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this))
  }
  get initial() {
    return memo(this, 'initial', () =>
      formatInitialTransition(this, this.config.initial),
    )
  }
  /** @internal */
  next(snapshot, event) {
    const eventType = event.type
    const actions = []
    let selectedTransition
    const candidates = memo(this, `candidates-${eventType}`, () =>
      getCandidates(this, eventType),
    )
    for (const candidate of candidates) {
      const {guard} = candidate
      const resolvedContext = snapshot.context
      let guardPassed = false
      try {
        guardPassed =
          !guard || evaluateGuard(guard, resolvedContext, event, snapshot)
      } catch (err) {
        const guardType =
          typeof guard === 'string'
            ? guard
            : typeof guard === 'object'
            ? guard.type
            : void 0
        throw new Error(`Unable to evaluate guard ${
          guardType ? `'${guardType}' ` : ''
        }in transition for event '${eventType}' in state node '${this.id}':
${err.message}`)
      }
      if (guardPassed) {
        actions.push(...candidate.actions)
        selectedTransition = candidate
        break
      }
    }
    return selectedTransition ? [selectedTransition] : void 0
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return memo(this, 'events', () => {
      const {states} = this
      const events = new Set(this.ownEvents)
      if (states) {
        for (const stateId of Object.keys(states)) {
          const state = states[stateId]
          if (state.states) {
            for (const event of state.events) {
              events.add(`${event}`)
            }
          }
        }
      }
      return Array.from(events)
    })
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const events = new Set(
      [...this.transitions.keys()].filter((descriptor) => {
        return this.transitions
          .get(descriptor)
          .some(
            (transition) =>
              !(
                !transition.target &&
                !transition.actions.length &&
                !transition.reenter
              ),
          )
      }),
    )
    return Array.from(events)
  }
}
const STATE_IDENTIFIER = '#'
class StateMachine {
  constructor(config, implementations) {
    this.config = config
    this.version = void 0
    this.schemas = void 0
    this.implementations = void 0
    this.__xstatenode = true
    this.idMap = /* @__PURE__ */ new Map()
    this.root = void 0
    this.id = void 0
    this.states = void 0
    this.events = void 0
    this.id = config.id || '(machine)'
    this.implementations = {
      actors: implementations?.actors ?? {},
      actions: implementations?.actions ?? {},
      delays: implementations?.delays ?? {},
      guards: implementations?.guards ?? {},
    }
    this.version = this.config.version
    this.schemas = this.config.schemas
    this.transition = this.transition.bind(this)
    this.getInitialSnapshot = this.getInitialSnapshot.bind(this)
    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this)
    this.restoreSnapshot = this.restoreSnapshot.bind(this)
    this.start = this.start.bind(this)
    this.root = new StateNode(config, {
      _key: this.id,
      _machine: this,
    })
    this.root._initialize()
    this.states = this.root.states
    this.events = this.root.events
  }
  /**
   * Clones this state machine with the provided implementations and merges the
   * `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
   *   `context`) to recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(implementations) {
    const {actions, guards, actors, delays} = this.implementations
    return new StateMachine(this.config, {
      actions: {
        ...actions,
        ...implementations.actions,
      },
      guards: {
        ...guards,
        ...implementations.guards,
      },
      actors: {
        ...actors,
        ...implementations.actors,
      },
      delays: {
        ...delays,
        ...implementations.delays,
      },
    })
  }
  resolveState(config) {
    const resolvedStateValue = resolveStateValue(this.root, config.value)
    const nodeSet = getAllStateNodes(
      getStateNodes(this.root, resolvedStateValue),
    )
    return createMachineSnapshot(
      {
        _nodes: [...nodeSet],
        context: config.context || {},
        children: {},
        status: isInFinalState(nodeSet, this.root)
          ? 'done'
          : config.status || 'active',
        output: config.output,
        error: config.error,
        historyValue: config.historyValue,
      },
      this,
    )
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).snapshot
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).microstates
  }
  getTransitionData(snapshot, event) {
    return transitionNode(this.root, snapshot.value, snapshot, event) || []
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(actorScope, initEvent, internalQueue) {
    const {context} = this.config
    const preInitial = createMachineSnapshot(
      {
        context: typeof context !== 'function' && context ? context : {},
        _nodes: [this.root],
        children: {},
        status: 'active',
      },
      this,
    )
    if (typeof context === 'function') {
      const assignment = ({spawn, event, self: self2}) =>
        context({
          spawn,
          input: event.input,
          self: self2,
        })
      return resolveActionsAndContext(
        preInitial,
        initEvent,
        actorScope,
        [assign(assignment)],
        internalQueue,
        void 0,
      )
    }
    return preInitial
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(actorScope, input) {
    const initEvent = createInitEvent(input)
    const internalQueue = []
    const preInitialState = this.getPreInitialState(
      actorScope,
      initEvent,
      internalQueue,
    )
    const nextState = microstep(
      [
        {
          target: [...getInitialStateNodes(this.root)],
          source: this.root,
          reenter: true,
          actions: [],
          eventType: null,
          toJSON: null,
          // TODO: fix
        },
      ],
      preInitialState,
      actorScope,
      initEvent,
      true,
      internalQueue,
    )
    const {snapshot: macroState} = macrostep(
      nextState,
      initEvent,
      actorScope,
      internalQueue,
    )
    return macroState
  }
  start(snapshot) {
    Object.values(snapshot.children).forEach((child) => {
      if (child.getSnapshot().status === 'active') {
        child.start()
      }
    })
  }
  getStateNodeById(stateId) {
    const fullPath = toStatePath(stateId)
    const relativePath = fullPath.slice(1)
    const resolvedStateId = isStateId(fullPath[0])
      ? fullPath[0].slice(STATE_IDENTIFIER.length)
      : fullPath[0]
    const stateNode = this.idMap.get(resolvedStateId)
    if (!stateNode) {
      throw new Error(
        `Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`,
      )
    }
    return getStateNodeByPath(stateNode, relativePath)
  }
  get definition() {
    return this.root.definition
  }
  toJSON() {
    return this.definition
  }
  getPersistedSnapshot(snapshot, options) {
    return getPersistedSnapshot(snapshot, options)
  }
  restoreSnapshot(snapshot, _actorScope) {
    const children = {}
    const snapshotChildren = snapshot.children
    Object.keys(snapshotChildren).forEach((actorId) => {
      const actorData = snapshotChildren[actorId]
      const childState = actorData.snapshot
      const src = actorData.src
      const logic =
        typeof src === 'string' ? resolveReferencedActor(this, src) : src
      if (!logic) {
        return
      }
      const actorRef = createActor(logic, {
        id: actorId,
        parent: _actorScope.self,
        syncSnapshot: actorData.syncSnapshot,
        snapshot: childState,
        src,
        systemId: actorData.systemId,
      })
      children[actorId] = actorRef
    })
    const restoredSnapshot = createMachineSnapshot(
      {
        ...snapshot,
        children,
        _nodes: Array.from(
          getAllStateNodes(getStateNodes(this.root, snapshot.value)),
        ),
      },
      this,
    )
    const seen = /* @__PURE__ */ new Set()
    function reviveContext(contextPart, children2) {
      if (seen.has(contextPart)) {
        return
      }
      seen.add(contextPart)
      for (const key in contextPart) {
        const value = contextPart[key]
        if (value && typeof value === 'object') {
          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {
            contextPart[key] = children2[value.id]
            continue
          }
          reviveContext(value, children2)
        }
      }
    }
    reviveContext(restoredSnapshot.context, children)
    return restoredSnapshot
  }
}
function createMachine(config, implementations) {
  return new StateMachine(config, implementations)
}
function setup({schemas, actors, actions, guards, delays}) {
  return {
    createMachine: (config) =>
      createMachine(
        {
          ...config,
          schemas,
        },
        {
          actors,
          actions,
          guards,
          delays,
        },
      ),
  }
}
const defaultContext = {
  selection: null,
  blockId: '',
  rangeStart: null,
  rangeEnd: null,
  mouseDown: false,
}
setup({
  actions: {
    setMouse: assign(({context, event}) => {
      return {
        ...context,
        mouseDown: event.type == 'MOUSEDOWN',
      }
    }),
    setRange: () => {},
    clearContext: assign(() => {
      document.getSelection()?.empty()
      return defaultContext
    }),
  },
}).createMachine({
  context: {
    selection: null,
    blockId: '',
    rangeStart: null,
    rangeEnd: null,
    expanded: false,
    mouseDown: false,
  },
  id: 'Range Selection',
  initial: 'disable',
  on: {
    ENABLE: {
      target: '.idle',
    },
    DISABLE: {
      target: '.disable',
    },
    MOUSEDOWN: {
      actions: ['setMouse'],
    },
    MOUSEUP: {
      actions: ['setMouse'],
    },
  },
  states: {
    disable: {},
    idle: {
      on: {
        SELECT: {
          target: 'active',
        },
      },
    },
    active: {
      initial: 'selecting',
      states: {
        selecting: {
          after: {
            300: {
              target: 'selected',
              guard: ({context}) => !context.mouseDown,
            },
          },
          on: {
            SELECT: {
              target: 'selecting',
              reenter: true,
            },
            MOUSEUP: {
              target: 'selected',
            },
          },
        },
        selected: {
          entry: ['setRange'],
          on: {
            SELECT: {
              target: 'selecting',
              action: ['clearContext'],
            },
            CREATE_COMMENT: {
              target: '#Range Selection.idle',
              actions: ['clearContext'],
            },
          },
        },
        commenting: {
          on: {
            COMMENT_SUBMIT: {
              target: '#Range Selection.idle',
            },
            COMMENT_CANCEL: {
              target: 'selected',
            },
          },
        },
      },
    },
  },
})
const exploreRouteSchema = z$1.object({
  key: z$1.literal('explore'),
})
const contactsRouteSchema = z$1.object({key: z$1.literal('contacts')})
const contactRouteSchema = z$1.object({
  key: z$1.literal('contact'),
  id: unpackedHmIdSchema,
})
const documentDirectoryAccessorySchema = z$1.object({
  key: z$1.literal('directory'),
})
const documentContactsAccessorySchema = z$1.object({
  key: z$1.literal('contacts'),
})
const documentCollaboratorsAccessorySchema = z$1.object({
  key: z$1.literal('collaborators'),
})
z$1.object({
  key: z$1.literal('suggested-changes'),
})
const documentOptionsAccessorySchema = z$1.object({
  key: z$1.literal('options'),
})
const documentActivityAccessorySchema = z$1.object({
  key: z$1.literal('activity'),
  width: z$1.number().optional(),
  openComment: z$1.string().optional(),
  openBlockId: z$1.string().optional(),
  blockRange: BlockRangeSchema.nullable().optional(),
  autoFocus: z$1.boolean().optional(),
  isReplying: z$1.boolean().optional(),
  filterEventType: z$1.array(z$1.string()).optional(),
})
const documentAccessorySchema = z$1.discriminatedUnion('key', [
  documentActivityAccessorySchema,
  documentDirectoryAccessorySchema,
  documentCollaboratorsAccessorySchema,
  documentContactsAccessorySchema,
  documentOptionsAccessorySchema,
])
const documentRouteSchema = z$1.object({
  key: z$1.literal('document'),
  id: unpackedHmIdSchema,
  isBlockFocused: z$1.boolean().optional(),
  immediatelyPromptPush: z$1.boolean().optional(),
  immediatelyPromptNotifs: z$1.boolean().optional(),
  immediatelyPromptTemplate: z$1.boolean().optional(),
  accessory: documentAccessorySchema.nullable().optional(),
})
const feedRouteSchema = z$1.object({
  key: z$1.literal('feed'),
  id: unpackedHmIdSchema,
  accessory: documentAccessorySchema.nullable().optional(),
})
const draftRouteSchema = z$1.object({
  key: z$1.literal('draft'),
  id: z$1.string(),
  locationUid: z$1.string().optional(),
  locationPath: z$1.array(z$1.string()).optional(),
  editUid: z$1.string().optional(),
  editPath: z$1.array(z$1.string()).optional(),
  deps: z$1.array(z$1.string()).optional(),
  accessory: documentAccessorySchema.nullable().optional(),
})
const favoritesSchema = z$1.object({
  key: z$1.literal('favorites'),
})
const draftsSchema = z$1.object({
  key: z$1.literal('drafts'),
})
const settingsRouteSchema = z$1.object({key: z$1.literal('settings')})
const deletedContentRouteSchema = z$1.object({
  key: z$1.literal('deleted-content'),
})
const draftRebaseRouteSchema = z$1.object({
  key: z$1.literal('draft-rebase'),
  documentId: z$1.string(),
  sourceVersion: z$1.string(),
  targetVersion: z$1.string(),
})
const libraryRouteSchema = z$1.object({
  key: z$1.literal('library'),
  expandedIds: z$1.array(z$1.string()).optional(),
  displayMode: z$1.enum(['all', 'subscribed', 'favorites']).optional(),
  grouping: z$1.enum(['site', 'none']).optional(),
})
z$1.discriminatedUnion('key', [
  libraryRouteSchema,
  contactsRouteSchema,
  contactRouteSchema,
  settingsRouteSchema,
  documentRouteSchema,
  draftRouteSchema,
  draftRebaseRouteSchema,
  exploreRouteSchema,
  favoritesSchema,
  draftsSchema,
  deletedContentRouteSchema,
  feedRouteSchema,
])
reactExports.createContext({
  ipfsFileUrl: DAEMON_FILE_URL,
  openUrl: () => {
    console.error('UniversalAppContext not set. Can not openUrl')
  },
})
function getDaemonFileUrl(ipfsUrl) {
  if (ipfsUrl) {
    return `${DAEMON_FILE_URL}/${extractIpfsUrlCid(ipfsUrl)}`
  }
  return ''
}
function extractIpfsUrlCid(cidOrIPFSUrl) {
  const regex = /^ipfs:\/\/(.+)$/
  const match2 = cidOrIPFSUrl.match(regex)
  return match2 ? match2[1] : cidOrIPFSUrl
}
function EmailContent({notification}) {
  const {authorName, authorAvatar, fallbackLetter, createdAt} =
    getNotificationMeta(notification)
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlSection, {
      backgroundColor: '#f9f9f9',
      borderRadius: '6px',
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
          width: '10%',
          verticalAlign: 'top',
          children: authorAvatar.length
            ? // <MjmlImage
              //   src={authorAvatar}
              //   alt="Sender Avatar"
              //   width="28px"
              //   height="28px"
              //   borderRadius="50%"
              //   paddingBottom="4px"
              // />
              /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlRaw, {
                children: /* @__PURE__ */ jsxRuntimeExports.jsx('img', {
                  src: authorAvatar,
                  alt: 'Sender Avatar',
                  style: {
                    width: '28px',
                    height: '28px',
                    borderRadius: '50%',
                    marginLeft: '23px',
                  },
                }),
              })
            : /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlRaw, {
                children: /* @__PURE__ */ jsxRuntimeExports.jsx('div', {
                  style: {
                    width: '28px',
                    height: '28px',
                    borderRadius: '50%',
                    backgroundColor: '#ccc',
                    textAlign: 'center',
                    lineHeight: '28px',
                    fontWeight: 'bold',
                    fontSize: '14px',
                    color: '#ffffff',
                    fontFamily: 'sans-serif',
                    marginLeft: '23px',
                  },
                  children: fallbackLetter,
                }),
              }),
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
          width: '90%',
          verticalAlign: 'middle',
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlText, {
            fontSize: '12px',
            fontWeight: 'bold',
            paddingBottom: '4px',
            paddingRight: '10px',
            children: [
              authorName,
              createdAt &&
                /* @__PURE__ */ jsxRuntimeExports.jsxs('span', {
                  style: {
                    color: '#888',
                    fontWeight: 'normal',
                    fontSize: '12px',
                  },
                  children: [' ', createdAt],
                }),
            ],
          }),
        }),
        notification.type === 'change'
          ? renderChange({
              targetDocName:
                notification.targetMeta?.name ?? 'Untitled Document',
              isNewDocument: notification.isNewDocument,
            })
          : notification.type === 'mention'
          ? /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
              width: '100%',
              verticalAlign: 'middle',
              children: notification.comment
                ? renderMention({
                    blocks: notification.comment.content.map(
                      (n) => new BlockNode(n),
                    ),
                    targetDocName:
                      notification.targetMeta?.name ?? 'Untitled Document',
                    resolvedNames: notification.resolvedNames,
                  })
                : // Document mention
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlText, {
                    fontSize: '14px',
                    padding: '12px 25px',
                    children: [
                      'was mentioned in',
                      ' ',
                      /* @__PURE__ */ jsxRuntimeExports.jsx('span', {
                        style: {
                          backgroundColor: '#eee',
                          borderRadius: '4px',
                          padding: '4px 8px',
                          display: 'inline-block',
                        },
                        children:
                          notification.targetMeta?.name ?? 'Untitled Document',
                      }),
                    ],
                  }),
            })
          : notification.type === 'reply'
          ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlColumn, {
              width: '100%',
              verticalAlign: 'middle',
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
                  fontSize: '14px',
                  color: '#666',
                  paddingBottom: '8px',
                  children: 'New reply:',
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
                  padding: '0 0 8px 23px',
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
                    'border-left': '1px solid #20C997',
                    children: renderBlocks(
                      notification.comment.content.map((n) => new BlockNode(n)),
                      notification.url,
                      notification.resolvedNames,
                    ),
                  }),
                }),
              ],
            })
          : // Default to comment
            /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlColumn, {
              width: '100%',
              verticalAlign: 'middle',
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
                  fontSize: '14px',
                  color: '#666',
                  paddingBottom: '8px',
                  children: 'Commented:',
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
                  padding: '0 0 8px 23px',
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
                    'border-left': '1px solid #20C997',
                    children: renderBlocks(
                      notification.comment.content.map((n) => new BlockNode(n)),
                      notification.url,
                      notification.resolvedNames,
                    ),
                  }),
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
                  padding: '0 0 16px 0',
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlText, {
                      fontSize: '14px',
                      color: '#888',
                      children: [
                        'on:',
                        ' ',
                        /* @__PURE__ */ jsxRuntimeExports.jsx('span', {
                          style: {
                            backgroundColor: '#eee',
                            borderRadius: '4px',
                            padding: '2px 6px',
                            display: 'inline-block',
                          },
                          children:
                            notification.targetMeta?.name ??
                            'Untitled Document',
                        }),
                      ],
                    }),
                  }),
                }),
              ],
            }),
      ],
    }),
  })
}
function renderMention({blocks, targetDocName, resolvedNames}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
        padding: '0',
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
            fontSize: '14px',
            color: '#666',
            paddingBottom: '8px',
            children: 'Mentioned:',
          }),
        }),
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
        padding: '0 0 8px 23px',
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
          'border-left': '1px solid #20C997',
          children: renderBlocks(blocks, '', resolvedNames),
        }),
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
        padding: '0 0 16px 0',
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlText, {
            fontSize: '14px',
            color: '#888',
            children: [
              'on:',
              ' ',
              /* @__PURE__ */ jsxRuntimeExports.jsx('span', {
                style: {
                  backgroundColor: '#eee',
                  borderRadius: '4px',
                  padding: '2px 6px',
                  display: 'inline-block',
                },
                children: targetDocName,
              }),
            ],
          }),
        }),
      }),
    ],
  })
}
function renderChange({targetDocName, isNewDocument}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
      padding: '0',
      textAlign: 'left',
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlColumn, {
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
            fontSize: '16px',
            padding: '12px 25px',
            children: isNewDocument
              ? 'has created a new document:'
              : 'has made a new change to document:',
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
            fontSize: '14px',
            children: /* @__PURE__ */ jsxRuntimeExports.jsx('span', {
              style: {
                backgroundColor: '#eee',
                borderRadius: '4px',
                padding: '4px 8px',
                display: 'inline-block',
              },
              children: targetDocName,
            }),
          }),
        ],
      }),
    }),
  })
}
function renderBlocks(blocks, notifUrl, resolvedNames) {
  return blocks.map((blockNode, index) =>
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      React.Fragment,
      {
        children: [
          renderBlock(blockNode, notifUrl, resolvedNames),
          blockNode.children?.length
            ? renderBlocks(blockNode.children, notifUrl, resolvedNames)
            : null,
        ],
      },
      index,
    ),
  )
}
function renderBlock(blockNode, notifUrl, resolvedNames) {
  const {type, text, annotations, link, attributes} = blockNode.block
  const innerHtml = renderInlineTextWithAnnotations(
    text,
    annotations,
    resolvedNames,
  )
  if (type === 'Paragraph') {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
      align: 'left',
      paddingBottom: '8px',
      fontSize: '14px',
      children: /* @__PURE__ */ jsxRuntimeExports.jsx('span', {
        dangerouslySetInnerHTML: {__html: innerHtml},
      }),
    })
  }
  if (type === 'Heading') {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
      align: 'left',
      paddingBottom: '8px',
      fontSize: '24px',
      fontWeight: 'bold',
      children: /* @__PURE__ */ jsxRuntimeExports.jsx('span', {
        dangerouslySetInnerHTML: {__html: innerHtml},
      }),
    })
  }
  if (type === 'Image') {
    const width = attributes?.fields?.width?.kind?.value ?? 400
    let src = void 0
    if (link?.startsWith('ipfs://')) {
      const cid = extractIpfsUrlCid(link)
      src = `http://localhost:58001/ipfs/${cid}`
    } else {
      src = link
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlImage, {
          src,
          alt: text || 'Image',
          width,
          paddingBottom: '8px',
        }),
        text &&
          /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
            fontSize: '12px',
            color: '#666',
            paddingBottom: '12px',
            align: 'center',
            children: text,
          }),
      ],
    })
  }
  if (type === 'Video') {
    if (link?.includes('youtube.com') || link?.includes('youtu.be')) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlButton, {
        href: link,
        backgroundColor: '#FF0000',
        fontSize: '14px',
        align: 'left',
        children: 'Watch Video on YouTube',
      })
    } else {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlButton, {
        href: notifUrl,
        backgroundColor: '#068f7b',
        fontSize: '14px',
        align: 'left',
        children: 'Watch Video in the Comment',
      })
    }
  }
  if (type === 'WebEmbed') {
    if (link?.includes('instagram.com')) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlButton, {
        href: link,
        backgroundColor: '#346DB7',
        fontSize: '14px',
        align: 'left',
        children: 'Open in Instagram',
      })
    } else if (link.includes('x.com')) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlButton, {
        href: link,
        backgroundColor: '#346DB7',
        fontSize: '14px',
        align: 'left',
        children: 'Open in X.com',
      })
    }
  }
  if (type === 'Button') {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlButton, {
      href: link,
      backgroundColor: '#068f7b',
      fontSize: '14px',
      align: 'left',
      children: attributes.fields?.name?.kind?.value || link,
    })
  }
  if (type === 'Math') {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
      align: 'left',
      paddingBottom: '8px',
      fontSize: '14px',
      fontFamily: 'monospace',
      color: '#888',
      children: text,
    })
  }
  if (type === 'Code') {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
      align: 'left',
      paddingBottom: '8px',
      fontSize: '14px',
      fontFamily: 'monospace',
      color: '#666',
      backgroundColor: '#f2f2f2',
      padding: '12px',
      children: /* @__PURE__ */ jsxRuntimeExports.jsx('code', {children: text}),
    })
  }
  if (type === 'Embed') {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlButton, {
      href: link,
      backgroundColor: '#346DB7',
      fontSize: '14px',
      align: 'left',
      children: 'Open Embed',
    })
  }
  return null
}
function renderInlineTextWithAnnotations(text, annotations, resolvedNames) {
  if (!annotations.length) return text
  let result = []
  let lastIndex = 0
  annotations.forEach((annotation, index) => {
    const start = annotation.starts[0]
    const end = annotation.ends[0]
    if (start > lastIndex) {
      result.push(text.slice(lastIndex, start))
    }
    let annotatedText = text.slice(start, end)
    if (annotation.type === 'Bold') {
      annotatedText = `<b>${annotatedText}</b>`
    } else if (annotation.type === 'Italic') {
      annotatedText = `<i>${annotatedText}</i>`
    } else if (annotation.type === 'Strike') {
      annotatedText = `<s>${annotatedText}</s>`
    } else if (annotation.type === 'Code') {
      annotatedText = `<code>${annotatedText}</code>`
    } else if (annotation.type === 'Link') {
      let href = annotation.link
      if (href?.startsWith('hm://')) {
        const unpacked = unpackHmId(href)
        href = createWebHMUrl(unpacked.uid, {
          // @ts-ignore
          path: unpacked.path,
          // @ts-ignore
          hostname: unpacked.hostname ?? null,
        })
      }
      annotatedText = `<a href="${href}" style="color: #346DB7;">${annotatedText}</a>`
    } else if (annotation.type === 'Embed') {
      const resolved = resolvedNames?.[annotation.link] || annotation.link
      let href = annotation.link
      if (href?.startsWith('hm://')) {
        const unpacked = unpackHmId(href)
        href = createWebHMUrl(unpacked.uid, {
          // @ts-ignore
          path: unpacked.path,
          // @ts-ignore
          hostname: unpacked.hostname ?? null,
        })
      }
      annotatedText = `<a href="${href}" style="color: #008060;">@${resolved}</a>`
    }
    result.push(annotatedText)
    lastIndex = end
  })
  if (lastIndex < text.length) {
    result.push(text.slice(lastIndex))
  }
  return result.join('')
}
function getNotificationMeta(notification) {
  const authorMeta = notification.authorMeta
  const authorName =
    authorMeta?.name ||
    ('comment' in notification && notification.comment
      ? notification.comment.author
      : 'authorAccountId' in notification
      ? notification.authorAccountId
      : 'Unknown')
  const authorAvatar = authorMeta?.icon ? getDaemonFileUrl(authorMeta.icon) : ''
  const createdAt = (() => {
    if (notification.type === 'comment' || notification.type === 'reply') {
      return notification.comment.createTime?.seconds
        ? format(
            new Date(Number(notification.comment.createTime.seconds) * 1e3),
            'MMM d',
          )
        : ''
    }
    if (notification.type === 'mention') {
      return notification.comment?.createTime?.seconds
        ? format(
            new Date(Number(notification.comment.createTime.seconds) * 1e3),
            'MMM d',
          )
        : ''
    }
    return ''
  })()
  return {
    authorName,
    authorAvatar,
    fallbackLetter: authorName?.[0]?.toUpperCase?.() || '?',
    createdAt,
  }
}
function EmailHeader() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
    padding: '16px 24px',
    'border-bottom': '1px solid #eee',
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlGroup, {
      width: '70%',
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
          width: '24px',
          paddingRight: '10px',
          verticalAlign: 'middle',
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlImage, {
            src: 'https://iili.io/FJ0pBl1.png',
            alt: 'Seed Logo',
            width: '16px',
            height: '20px',
            padding: '0',
          }),
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
          padding: '0',
          verticalAlign: 'middle',
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlText, {
            fontSize: '16px',
            fontWeight: 'bold',
            color: '#068f7b',
            padding: '0',
            children: 'Seed Hypermedia',
          }),
        }),
      ],
    }),
  })
}
function NotifSettings({url}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlColumn, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlText, {
        align: 'center',
        fontSize: '14px',
        color: '#666666',
        children: [
          'Subscribed by mistake?',
          ' ',
          /* @__PURE__ */ jsxRuntimeExports.jsx('a', {
            href: url,
            style: {color: '#0066cc', textDecoration: 'underline'},
            children: 'Click here to unsubscribe',
          }),
        ],
      }),
    }),
  })
}
async function createNotificationsEmail(email, opts, notifications) {
  if (!notifications.length) return
  const grouped = {
    change: {},
    comment: {},
    mention: {},
    reply: {},
  }
  for (const notif of notifications) {
    const type = notif.notif.type
    const docId = notif.notif.targetId.id
    if (!grouped[type][docId]) grouped[type][docId] = []
    grouped[type][docId].push(notif)
  }
  const subscriberNames = /* @__PURE__ */ new Set()
  const notificationsByDocument = {}
  for (const notification of notifications) {
    if (!notificationsByDocument[notification.notif.targetId.id]) {
      notificationsByDocument[notification.notif.targetId.id] = []
    }
    notificationsByDocument[notification.notif.targetId.id].push(notification)
    subscriberNames.add(notification.accountMeta?.name || 'Subscriber')
  }
  const docNotifs = Object.values(notificationsByDocument)
  const baseNotifsSubject =
    notifications?.length > 1
      ? `${notifications?.length} Notifications`
      : 'Notification'
  let subject = baseNotifsSubject
  const singleDocumentTitle = notifications.every(
    // @ts-ignore
    (n) => n.notif.targetMeta?.name === notifications[0].notif.targetMeta?.name,
  )
    ? // @ts-ignore
      notifications?.[0].notif.targetMeta?.name
    : void 0
  if (singleDocumentTitle) {
    subject = `${baseNotifsSubject} on ${singleDocumentTitle}`
  }
  const firstNotificationSummary = getNotificationSummary(
    // @ts-ignore
    notifications?.[0].notif,
    // @ts-ignore
    notifications?.[0].accountMeta,
  )
  const notifSettingsUrl = `${SITE_BASE_URL.replace(
    /\/$/,
    '',
  )}/hm/email-notifications?token=${opts.adminToken}`
  const text = `${baseNotifsSubject}

// @ts-expect-error
${docNotifs
  .map((notifications2) => {
    const docName =
      notifications2?.[0]?.notif?.targetMeta?.name || 'Untitled Document'
    const lines = notifications2
      .map((notification) => {
        const {notif} = notification
        if (notif.type === 'comment') {
          return `New comment from ${
            notif.authorMeta?.name || 'an account you are subscribed to'
          } on ${notif.url}`
        }
        if (notif.type === 'change') {
          return `New document change from ${
            notif.authorMeta?.name || notif.authorAccountId
          } on ${notif.url}`
        }
        if (notif.type === 'mention') {
          return `${
            notif.authorMeta?.name || notif.authorAccountId
          } mentioned ${
            notification.accountMeta?.name || 'an account you are subscribed to'
          } on ${notif.url}`
        }
        if (notif.type === 'reply') {
          return `${
            notif.authorMeta?.name || notif.comment.author
          } replied to ${
            notification.accountMeta?.name || 'an account you are subscribed to'
          } comment on ${notif.url}`
        }
        return ''
      })
      .join('\n')
    return `${docName}

${lines}

${notifications2?.[0]?.notif?.url}`
  })
  .join('\n')}

Subscribed by mistake? Click here to unsubscribe: ${notifSettingsUrl}`
  const {html: emailHtml} = renderReactToMjml(
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Mjml, {
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlHead, {
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlTitle, {
              children: subject,
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlPreview, {
              children:
                notifications.length > 1
                  ? `${firstNotificationSummary} and more`
                  : firstNotificationSummary,
            }),
          ],
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(MjmlBody, {
          width: 500,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(EmailHeader, {}),
            ['change', 'comment', 'mention', 'reply'].map((type) => {
              const docs = grouped[type]
              const docEntries = Object.entries(docs)
              if (!docEntries.length) return null
              const totalCount = docEntries.flatMap(([, n]) => n).length
              const sectionTitle = (() => {
                switch (type) {
                  case 'comment':
                    return `New comment${totalCount === 1 ? '' : 's'}`
                  case 'mention':
                    return `Mention${totalCount === 1 ? '' : 's'}`
                  case 'reply':
                    return `Repl${totalCount === 1 ? 'y' : 'ies'}`
                  case 'change':
                  default:
                    return 'Document changes'
                }
              })()
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                jsxRuntimeExports.Fragment,
                {
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
                      padding: '10px 0px 0px',
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        MjmlColumn,
                        {
                          padding: '0px',
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            MjmlText,
                            {
                              fontSize: '20px',
                              fontWeight: 'bold',
                              children: sectionTitle,
                            },
                          ),
                        },
                      ),
                    }),
                    docEntries.map(([docId, docNotifs2]) => {
                      const targetName =
                        docNotifs2?.[0]?.notif?.targetMeta?.name ||
                        'Untitled Document'
                      const docUrl = docNotifs2?.[0]?.notif?.url
                      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        jsxRuntimeExports.Fragment,
                        {
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
                              padding: '0px 0px 10px',
                              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                MjmlColumn,
                                {
                                  children:
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      MjmlText,
                                      {
                                        fontSize: '14px',
                                        color: '#888',
                                        children:
                                          type === 'comment'
                                            ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                jsxRuntimeExports.Fragment,
                                                {
                                                  children: [
                                                    docNotifs2.length,
                                                    ' comment',
                                                    docNotifs2.length === 1
                                                      ? ''
                                                      : 's',
                                                    ' on',
                                                    ' ',
                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      'span',
                                                      {
                                                        style: {
                                                          fontWeight: 'bold',
                                                          color: 'black',
                                                          backgroundColor:
                                                            'lightgray',
                                                        },
                                                        children: targetName,
                                                      },
                                                    ),
                                                  ],
                                                },
                                              )
                                            : type === 'mention'
                                            ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                jsxRuntimeExports.Fragment,
                                                {
                                                  children: [
                                                    docNotifs2.length,
                                                    ' mention',
                                                    docNotifs2.length === 1
                                                      ? ''
                                                      : 's',
                                                    ' on',
                                                    ' ',
                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      'span',
                                                      {
                                                        style: {
                                                          fontWeight: 'bold',
                                                          color: 'black',
                                                          backgroundColor:
                                                            'lightgray',
                                                        },
                                                        children: targetName,
                                                      },
                                                    ),
                                                  ],
                                                },
                                              )
                                            : type === 'reply'
                                            ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                                jsxRuntimeExports.Fragment,
                                                {
                                                  children: [
                                                    docNotifs2.length,
                                                    ' repl',
                                                    totalCount === 1
                                                      ? 'y'
                                                      : 'ies',
                                                    ' on',
                                                    ' ',
                                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                      'span',
                                                      {
                                                        style: {
                                                          fontWeight: 'bold',
                                                          color: 'black',
                                                          backgroundColor:
                                                            'lightgray',
                                                        },
                                                        children: targetName,
                                                      },
                                                    ),
                                                  ],
                                                },
                                              )
                                            : null,
                                      },
                                    ),
                                },
                              ),
                            }),
                            docNotifs2.map(({notif}) => {
                              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                jsxRuntimeExports.Fragment,
                                {
                                  children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      EmailContent,
                                      {
                                        notification: notif,
                                      },
                                      'comment' in notif && notif.comment
                                        ? notif.comment.id
                                        : Math.random(),
                                    ),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      MjmlSection,
                                      {
                                        padding: '0px',
                                        children:
                                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                                            MjmlColumn,
                                            {
                                              children:
                                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                                  MjmlText,
                                                  {
                                                    lineHeight: '1',
                                                    fontSize: '1px',
                                                    children: '',
                                                  },
                                                ),
                                            },
                                          ),
                                      },
                                    ),
                                  ],
                                },
                              )
                            }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(MjmlSection, {
                              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                MjmlColumn,
                                {
                                  children:
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      MjmlButton,
                                      {
                                        align: 'left',
                                        href: docUrl,
                                        backgroundColor: '#008060',
                                        children:
                                          type === 'comment'
                                            ? 'View Comment'
                                            : type === 'mention'
                                            ? 'View Mention'
                                            : type === 'reply'
                                            ? 'View Reply'
                                            : 'View Change',
                                      },
                                    ),
                                },
                              ),
                            }),
                          ],
                        },
                      )
                    }),
                  ],
                },
              )
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NotifSettings, {
              url: notifSettingsUrl,
            }),
          ],
        }),
        ';',
      ],
    }),
  )
  return {email, subject, text, html: emailHtml, subscriberNames}
}
function getNotificationSummary(notification, accountMeta) {
  if (notification.type === 'change') {
    return `${notification.authorMeta?.name || 'Someone'} made changes to ${
      notification.targetMeta?.name || 'a document'
    }.`
  }
  if (notification.type === 'comment') {
    return `${notification.authorMeta?.name || 'Someone'} commented on ${
      notification.targetMeta?.name || 'a document'
    }.`
  }
  if (notification.type === 'mention') {
    if (notification.source === 'comment') {
      return `${notification.authorMeta?.name || 'Someone'} mentioned ${
        accountMeta?.name || 'an account you are subscribed to'
      } in a comment on ${notification.targetMeta?.name || 'a document'}.`
    } else {
      return `${notification.authorMeta?.name || 'Someone'} mentioned ${
        accountMeta?.name || 'an account you are subscribed to'
      } in ${notification.targetMeta?.name || 'a document'}.`
    }
  }
  if (notification.type === 'reply') {
    return `${notification.authorMeta?.name || 'Someone'} replied to ${
      accountMeta?.name || 'an account you are subscribed to'
    } comment on ${notification.targetMeta?.name || 'a document'}.`
  }
  return ''
}
function renderReactToMjml(email) {
  return mjml2html(renderToMjmlExports.renderToMjml(email))
}
console.log('DAEMON_HTTP_URL', DAEMON_HTTP_URL)
const transport = createGrpcWebTransport({
  baseUrl: DAEMON_HTTP_URL,
  httpVersion: '1.1',
  // interceptors: [loggingInterceptor],
})
const grpcClient = createGRPCClient(transport)
async function getMetadata(id) {
  try {
    const rawDoc = await grpcClient.documents.getDocument({
      account: id.uid,
      path: hmIdPathToEntityQueryPath(id.path),
      version: id.latest ? void 0 : id.version || void 0,
    })
    const metadataJSON = rawDoc.metadata?.toJson({emitDefaultValues: true})
    documentMetadataParseAdjustments(metadataJSON)
    return {
      id,
      metadata: HMDocumentMetadataSchema.parse(metadataJSON),
    }
  } catch (e) {
    return {id, metadata: {}}
  }
}
async function getAccount(accountUid, {discover} = {}) {
  try {
    const grpcAccount = await grpcClient.documents.getAccount({
      id: accountUid,
    })
    const serverAccount = toPlainMessage(grpcAccount)
    if (serverAccount.aliasAccount) {
      return await getAccount(serverAccount.aliasAccount)
    }
    const serverMetadata = grpcAccount.metadata?.toJson() || {}
    const metadata = HMDocumentMetadataSchema.parse(serverMetadata)
    return {
      id: hmId(accountUid),
      metadata,
    }
  } catch (e) {
    console.error('Error getting account ' + accountUid, e)
    return {id: hmId(accountUid), metadata: {}}
  }
}
async function getComment(id) {
  try {
    const rawDoc = await grpcClient.comments.getComment({
      id,
    })
    return HMCommentSchema.parse(rawDoc.toJson())
  } catch (error) {
    if (error?.code === 'not_found' || error?.message?.includes('not found')) {
      console.warn(`Comment ${id} not found, treating as acceptable warning`)
      return null
    }
    throw error
  }
}
async function getDocument(resourceId, {discover} = {}) {
  const {version, uid, latest} = resourceId
  const path = hmIdPathToEntityQueryPath(resourceId.path)
  const apiDoc = await grpcClient.documents.getDocument({
    account: uid,
    path,
    version: latest ? void 0 : version || void 0,
  })
  const serverDoc = toPlainMessage(apiDoc)
  return serverDoc
}
dotenv.config()
const transporter =
  ENABLE_EMAIL_NOTIFICATIONS &&
  NOTIFY_SMTP_HOST &&
  NOTIFY_SMTP_USER &&
  NOTIFY_SMTP_PASSWORD
    ? nodemailer.createTransport({
        host: NOTIFY_SMTP_HOST,
        port: NOTIFY_SMTP_PORT ? parseInt(NOTIFY_SMTP_PORT, 10) : 587,
        secure: true,
        auth: {
          user: NOTIFY_SMTP_USER,
          pass: NOTIFY_SMTP_PASSWORD,
        },
      })
    : null
async function sendEmail(to, subject, body, senderLabel) {
  if (!transporter) {
    console.error('Email notifier is not enabled')
    return
  }
  console.log(`Sending email to ${to} with subject ${subject}`)
  const from = NOTIFY_SENDER
  const info = await transporter.sendMail({
    from,
    to,
    subject,
    text: body.text,
    html: body.html,
  })
  return info
}
let isProcessing = false
async function initEmailNotifier() {
  console.log('Email Notifications Enabled')
  await handleEmailNotifications()
  const handleEmailNotificationsIntervalSeconds = 10
  setInterval(() => {
    handleEmailNotifications()
      .then(() => {})
      .catch((err) => {
        console.error('Error handling email notifications', err)
      })
  }, 1e3 * handleEmailNotificationsIntervalSeconds)
}
async function handleEmailNotifications() {
  if (isProcessing) {
    console.log('~~ skipping - already processing notifications')
    return
  }
  isProcessing = true
  try {
    const lastProcessedBlobCid = getNotifierLastProcessedBlobCid()
    console.log(
      '~~ handleEmailNotifications lastProcessedBlobCid',
      lastProcessedBlobCid,
    )
    if (lastProcessedBlobCid) {
      await handleEmailNotificationsAfterBlobCid(lastProcessedBlobCid)
    } else {
      await resetNotifierLastProcessedBlobCid()
    }
    const newLastProcessedBlobCid = getNotifierLastProcessedBlobCid()
    console.log(
      '~~ handleEmailNotifications newLastProcessedBlobCid',
      newLastProcessedBlobCid,
    )
  } finally {
    isProcessing = false
  }
}
async function resetNotifierLastProcessedBlobCid() {
  const {events} = await grpcClient.activityFeed.listEvents({
    pageToken: void 0,
    pageSize: 5,
  })
  const event = events.at(0)
  if (!event) return
  const lastBlobCid =
    event.data.case === 'newBlob' && event.data.value?.cid
      ? event.data.value.cid
      : void 0
  if (!lastBlobCid) return
  setNotifierLastProcessedBlobCid(lastBlobCid)
}
async function handleEmailNotificationsAfterBlobCid(lastProcessedBlobCid) {
  const eventsToProcess = await loadEventsAfterBlobCid(lastProcessedBlobCid)
  console.log(
    '~~ handleEmailNotificationsAfterBlobCid eventsToProcess',
    eventsToProcess.length,
  )
  if (eventsToProcess.length === 0) return
  await handleEventsForEmailNotifications(eventsToProcess)
  await markEventsAsProcessed(eventsToProcess)
}
async function handleEventsForEmailNotifications(events) {
  console.log('~~ handleEventsForEmailNotifications', events.length)
  const allEmails = getAllEmails()
  const accountNotificationOptions = {}
  const emailOptions = {}
  for (const email of allEmails) {
    emailOptions[email.email] = {
      adminToken: email.adminToken,
      isUnsubscribed: email.isUnsubscribed,
      createdAt: email.createdAt,
    }
  }
  const notificationsToSend = {}
  const accountMetas = {}
  async function appendNotification(email, accountId, notif) {
    if (!notificationsToSend[email]) {
      notificationsToSend[email] = []
    }
    if (accountMetas[accountId] === void 0) {
      try {
        accountMetas[accountId] = (await getAccount(accountId)).metadata
      } catch (error) {
        console.error(`Error getting account ${accountId}:`, error)
        accountMetas[accountId] = null
      }
    }
    notificationsToSend[email].push({
      accountId,
      accountMeta: accountMetas[accountId],
      notif,
    })
  }
  for (const email of allEmails) {
    for (const account of email.subscriptions) {
      const opts = emailOptions[email.email]
      if (opts.isUnsubscribed) continue
      if (!accountNotificationOptions[account.id]) {
        accountNotificationOptions[account.id] = {
          notifyAllMentions: account.notifyAllMentions,
          notifyAllReplies: account.notifyAllReplies,
          notifySiteDiscussions: account.notifySiteDiscussions,
          notifyOwnedDocChange: account.notifyOwnedDocChange,
          notifyAllComments: account.notifyAllComments,
          emails: [],
        }
      }
      if (
        !accountNotificationOptions[account.id].emails.includes(email.email)
      ) {
        accountNotificationOptions[account.id].emails.push(email.email)
      }
    }
  }
  const newComments = []
  for (const event of events) {
    if (event.data.case === 'newBlob') {
      const blob = event.data.value
      try {
        if (blob.blobType === 'Ref') {
          try {
            const unpacked = unpackHmId(blob.resource)
            if (!unpacked?.uid) continue
            const refData = await loadRefFromIpfs(blob.cid)
            const changeCid = refData.heads?.[0]?.toString()
            const changeData = await grpcClient.documents.getDocumentChange({
              id: changeCid,
            })
            const changeDataWithOps = await loadRefFromIpfs(changeCid)
            const changedDoc = await getDocument(unpacked)
            const targetMeta2 = changedDoc?.metadata ?? {}
            const docUrl = `${SITE_BASE_URL.replace(/\/$/, '')}/hm/${
              unpacked.uid
            }/${(unpacked.path || []).join('/')}`
            const prevVersionId = {
              ...unpacked,
              version:
                changeDataWithOps.deps && changeDataWithOps.deps.length > 0
                  ? changeDataWithOps.deps
                      .map((cid) => cid.toString())
                      .join('.')
                  : null,
            }
            const isNewDocument =
              Array.isArray(changeData.deps) && changeData.deps.length === 0
            if (prevVersionId) {
              const prevVersionDoc = await getDocument(prevVersionId)
              const mentionsMap = getMentionsFromOps(changeDataWithOps.body.ops)
              const previousMentionsByBlockId = {}
              for (const loaded of prevVersionDoc.content ?? []) {
                const blockId = loaded.block?.id
                if (!blockId) continue
                const accountIds = getMentionsFromBlock(loaded.block)
                if (accountIds.size > 0) {
                  previousMentionsByBlockId[blockId] = accountIds
                }
              }
              for (const [blockId, newMentions] of Object.entries(
                mentionsMap,
              )) {
                const oldMentions =
                  previousMentionsByBlockId[blockId] ??
                  /* @__PURE__ */ new Set()
                for (const accountLink of newMentions) {
                  const accountId = accountLink.slice('hm://'.length)
                  if (oldMentions.has(accountId)) continue
                  const account = accountNotificationOptions[accountId]
                  if (!account?.notifyAllMentions) continue
                  const authorMeta = (await getAccount(blob.author)).metadata
                  for (const email of account.emails) {
                    console.log(
                      `~~ document mention check: ${accountId} (${email}) - mention: true`,
                    )
                    await appendNotification(email, accountId, {
                      type: 'mention',
                      source: 'document',
                      authorAccountId: blob.author,
                      authorMeta,
                      targetMeta: targetMeta2,
                      targetId: unpacked,
                      url: docUrl,
                    })
                  }
                }
              }
            }
            for (const accountId in accountNotificationOptions) {
              if (accountId !== unpacked.uid) continue
              const account = accountNotificationOptions[accountId]
              if (!account) continue
              const {notifyOwnedDocChange, emails} = account
              if (!notifyOwnedDocChange) continue
              const authorMeta = (await getAccount(blob.author)).metadata
              for (const email of emails) {
                console.log(
                  `~~ document change check: ${accountId} (${email}) - document change: true`,
                )
                await appendNotification(email, accountId, {
                  type: 'change',
                  authorAccountId: blob.author,
                  authorMeta,
                  targetMeta: targetMeta2,
                  targetId: unpacked,
                  url: docUrl,
                  isNewDocument,
                })
              }
            }
          } catch (e) {
            console.error('Error processing Ref event', e)
          }
        }
        if (blob.blobType !== 'Comment') continue
        const comment = await grpcClient.comments.getComment({id: blob.cid})
        const parentComments = await getParentComments(comment)
        let commentAuthorMeta = null
        let targetMeta = null
        try {
          commentAuthorMeta = (await getAccount(comment.author)).metadata
        } catch (error) {
          console.error(
            `Error getting comment author ${comment.author}:`,
            error,
          )
        }
        try {
          targetMeta = (
            await getMetadata(
              hmId(comment.targetAccount, {
                path: entityQueryPathToHmIdPath(comment.targetPath),
              }),
            )
          ).metadata
        } catch (error) {
          console.error(
            `Error getting target metadata for ${comment.targetAccount}:`,
            error,
          )
        }
        newComments.push({
          comment: toPlainMessage(comment),
          parentComments,
          parentAuthors: /* @__PURE__ */ new Set(),
          // Not used anymore
          commentAuthorMeta,
          targetMeta,
          mentions: /* @__PURE__ */ new Set(),
          // Not used anymore
        })
      } catch (e) {
        console.error('Failed to process event', event, e)
      }
    }
  }
  for (const newComment of newComments) {
    const comment = newComment.comment
    const commentIdParts = comment.id.split('/')
    const commentTimestampId = commentIdParts[1]
    if (!commentTimestampId) {
      console.error('Invalid comment ID format:', comment.id)
      continue
    }
    const commentUrl = createWebHMUrl(comment.author, {
      path: [commentTimestampId],
      hostname: SITE_BASE_URL.replace(/\/$/, ''),
    })
    const targetDocId = hmId(comment.targetAccount, {
      path: entityQueryPathToHmIdPath(comment.targetPath),
    })
    const mentionedUsers = /* @__PURE__ */ new Set()
    for (const rawBlockNode of comment.content) {
      const blockNode = HMBlockNodeSchema.parse(rawBlockNode)
      for (const annotation of blockNode.block?.annotations || []) {
        if (annotation.type === 'Embed') {
          const hmId2 = unpackHmId(annotation.link)
          if (hmId2 && !hmId2.path?.length) {
            mentionedUsers.add(hmId2.uid)
          }
        }
      }
    }
    let parentCommentAuthor = null
    if (comment.replyParent) {
      try {
        const parentComment = await getComment(comment.replyParent)
        if (parentComment) {
          parentCommentAuthor = parentComment.author
        }
      } catch (error) {
        console.error(
          `Error getting parent comment ${comment.replyParent}:`,
          error,
        )
      }
    }
    for (const accountId in accountNotificationOptions) {
      const account = accountNotificationOptions[accountId]
      ;(!comment.threadRoot || comment.threadRoot === '') &&
        (!comment.replyParent || comment.replyParent === '')
      let shouldNotify = false
      let notificationReason = ''
      if (
        accountId === comment.targetAccount &&
        account?.notifySiteDiscussions
      ) {
        shouldNotify = true
        notificationReason = 'site discussion'
      }
      if (mentionedUsers.has(accountId) && account?.notifyAllMentions) {
        shouldNotify = true
        notificationReason = 'mention'
      }
      if (parentCommentAuthor === accountId && account?.notifyAllReplies) {
        shouldNotify = true
        notificationReason = 'reply'
      }
      if (!shouldNotify || !account) continue
      for (const email of account.emails) {
        console.log(
          `~~ ${notificationReason} check: ${accountId} (${email}) - ${notificationReason}: true`,
        )
        if (notificationReason === 'mention') {
          await appendNotification(email, accountId, {
            type: 'mention',
            authorAccountId: comment.author,
            authorMeta: newComment.commentAuthorMeta,
            targetMeta: newComment.targetMeta,
            targetId: targetDocId,
            url: commentUrl,
            source: 'comment',
            comment: newComment.comment,
            resolvedNames: await resolveAnnotationNames(
              newComment.comment.content.map((n) => new BlockNode(n)),
            ),
          })
        } else if (notificationReason === 'reply') {
          await appendNotification(email, accountId, {
            type: 'reply',
            comment: newComment.comment,
            parentComments: newComment.parentComments,
            authorMeta: newComment.commentAuthorMeta,
            targetMeta: newComment.targetMeta,
            targetId: targetDocId,
            url: commentUrl,
            resolvedNames: await resolveAnnotationNames(
              newComment.comment.content.map((n) => new BlockNode(n)),
            ),
          })
        } else {
          await appendNotification(email, accountId, {
            type: 'comment',
            comment: newComment.comment,
            parentComments: newComment.parentComments,
            authorMeta: newComment.commentAuthorMeta,
            targetMeta: newComment.targetMeta,
            targetId: targetDocId,
            url: commentUrl,
            resolvedNames: await resolveAnnotationNames(
              newComment.comment.content.map((n) => new BlockNode(n)),
            ),
          })
        }
      }
    }
    for (const email of allEmails) {
      for (const subscription of email.subscriptions) {
        if (
          subscription.id === comment.author &&
          subscription.notifyAllComments
        ) {
          console.log(
            `~~ user comment check: ${comment.author} (${email.email}) - user comment: true`,
          )
          await appendNotification(email.email, comment.author, {
            type: 'comment',
            comment: newComment.comment,
            parentComments: newComment.parentComments,
            authorMeta: newComment.commentAuthorMeta,
            targetMeta: newComment.targetMeta,
            targetId: targetDocId,
            url: commentUrl,
            resolvedNames: await resolveAnnotationNames(
              newComment.comment.content.map((n) => new BlockNode(n)),
            ),
          })
        }
      }
    }
  }
  const emailsToSend = Object.entries(notificationsToSend)
  console.log('~~ emailsToSend count:', emailsToSend.length)
  for (const [email, notifications] of emailsToSend) {
    const opts = emailOptions[email]
    if (opts.isUnsubscribed) continue
    console.log(
      `~~ processing email ${email} with ${notifications.length} notifications`,
    )
    const notificationEmail = await createNotificationsEmail(
      email,
      // @ts-expect-error
      opts,
      notifications,
    )
    if (notificationEmail) {
      const {subject, text, html} = notificationEmail
      console.log('SENDING EMAIL!!!!', email)
      await sendEmail(email, subject, {text, html})
    }
  }
}
async function getParentComments(comment) {
  const parentComments = []
  let currentComment = comment
  while (currentComment.replyParent) {
    try {
      const parentComment = await grpcClient.comments.getComment({
        id: currentComment.replyParent,
      })
      const parentCommentPlain = toPlainMessage(parentComment)
      parentComments.push(parentCommentPlain)
      currentComment = parentCommentPlain
    } catch (error) {
      if (
        error?.code === 'not_found' ||
        error?.message?.includes('not found')
      ) {
        console.warn(
          `Parent comment ${currentComment.replyParent} not found, stopping parent traversal`,
        )
        break
      }
      throw error
    }
  }
  return parentComments
}
async function markEventsAsProcessed(events) {
  const newestEvent = events.at(0)
  if (!newestEvent) return
  const lastProcessedBlobCid = newestEvent.data.value?.cid
  if (!lastProcessedBlobCid) return
  console.log('~~ markEventsAsProcessed setting CID to:', lastProcessedBlobCid)
  await setNotifierLastProcessedBlobCid(lastProcessedBlobCid)
}
async function loadEventsAfterBlobCid(lastProcessedBlobCid) {
  const eventsAfterBlobCid = []
  let currentPageToken
  while (true) {
    const {events, nextPageToken} = await grpcClient.activityFeed.listEvents({
      pageToken: currentPageToken,
      pageSize: 2,
    })
    for (const event of events) {
      if (event.data.case === 'newBlob' && event.data.value?.cid) {
        if (event.data.value.cid === lastProcessedBlobCid) {
          return eventsAfterBlobCid
        }
        eventsAfterBlobCid.push(toPlainMessage(event))
      }
    }
    if (!nextPageToken) break
    currentPageToken = nextPageToken
  }
  return eventsAfterBlobCid
}
async function resolveAnnotationNames(blocks) {
  const resolvedNames = {}
  for (const block of blocks) {
    const blockNode = HMBlockNodeSchema.parse(block)
    for (const annotation of blockNode.block?.annotations || []) {
      if (annotation.type === 'Embed' && annotation.link) {
        const unpacked = unpackHmId(annotation.link)
        if (unpacked) {
          const isAccountLink = !unpacked.path || unpacked.path.length === 0
          try {
            if (isAccountLink) {
              const account = await getAccount(unpacked.uid)
              resolvedNames[annotation.link] = account.metadata?.name
                ? account.metadata?.name
                : `@${unpacked.uid.slice(0, 6)}`
            } else {
              const meta = await getMetadata(unpacked)
              resolvedNames[annotation.link] = meta.metadata?.name
                ? meta.metadata?.name
                : `@${unpacked.uid.slice(0, 6)}`
            }
          } catch {
            resolvedNames[annotation.link] = `@${unpacked.uid.slice(0, 6)}`
          }
        }
      }
    }
  }
  return resolvedNames
}
function getMentionsFromOps(ops) {
  const mentionMap = {}
  for (const op of ops) {
    if (op.type !== 'ReplaceBlock' || !op.block?.annotations) continue
    const mentions = op.block.annotations
      .filter((a) => a.type === 'Embed' && a.link?.startsWith('hm://'))
      .map((a) => a.link)
    if (mentions.length > 0 && op.block.id) {
      mentionMap[op.block.id] = new Set(mentions)
    }
  }
  return mentionMap
}
function getMentionsFromBlock(block) {
  const accountIds = /* @__PURE__ */ new Set()
  if (!block?.content || !Array.isArray(block.content)) return accountIds
  for (const item of block.content) {
    if (
      item.type === 'InlineEmbed' &&
      typeof item.ref === 'string' &&
      item.ref.startsWith('hm://')
    ) {
      const ref = item.ref.slice(5)
      if (ref && !ref.includes('/')) {
        accountIds.add(ref)
      }
    }
  }
  return accountIds
}
async function loadRefFromIpfs(cid) {
  const url = `${DAEMON_HTTP_URL}/ipfs/${cid}`
  const buffer = await fetch(url).then((res) => res.arrayBuffer())
  return decode(new Uint8Array(buffer))
}
console.log('HELLO NOTIFY SERVER')
async function initializeServer() {
  await initDatabase()
  await initEmailNotifier()
}
initializeServer()
  .then(() => {
    console.log('Server initialized and cache warmed')
    console.log('Server is running and will stay alive...')
    setInterval(() => {}, 3e4)
  })
  .catch((e) => {
    console.error('Error initializing server', e)
    process.exit(1)
  })
//# sourceMappingURL=index.js.map
